<?xml version="1.0" encoding="UTF-8"?>
<svg width="920" height="600" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      text { font-family: 'Fira Sans', sans-serif; font-size: 12px; fill: #666; }
      .bucket { fill: #4A90E2; stroke: #2171B5; stroke-width: 2; }
      .key { fill: #E94B3C; stroke: #C0392B; stroke-width: 1; }
      .value { fill: #50C878; stroke: #228B22; stroke-width: 1; }
      .operation { fill: #9B59B6; stroke: #8E44AD; stroke-width: 1; }
      .time { fill: #F39C12; stroke: #E67E22; stroke-width: 1; }
    </style>
  </defs>
  <text x="10" y="20" font-weight="bold">Hash Table Operations: Insert, Search, Delete</text>

  <!-- Insert Operation -->
  <text x="50" y="50" font-weight="bold">Insert Operation</text>
  <rect x="40" y="60" width="60" height="25" class="operation" rx="5"/>
  <text x="45" y="75">Insert(K,V)</text>

  <text x="120" y="75">1. Compute hash: index = h(K)</text>
  <text x="120" y="90">2. Check if bucket[index] is empty</text>
  <text x="120" y="105">3. If collision, resolve (chain/probe)</text>
  <text x="120" y="120">4. Store key-value pair</text>

  <rect x="40" y="140" width="30" height="20" class="bucket" rx="3"/>
  <text x="45" y="153">5</text>
  <rect x="90" y="140" width="25" height="20" class="key" rx="3"/>
  <text x="95" y="153">K</text>
  <rect x="125" y="140" width="25" height="20" class="value" rx="3"/>
  <text x="130" y="153">V</text>

  <!-- Search Operation -->
  <text x="50" y="190" font-weight="bold">Search Operation</text>
  <rect x="40" y="200" width="60" height="25" class="operation" rx="5"/>
  <text x="45" y="215">Search(K)</text>

  <text x="120" y="215">1. Compute hash: index = h(K)</text>
  <text x="120" y="230">2. Check bucket[index]</text>
  <text x="120" y="245">3. If collision, traverse chain/probe</text>
  <text x="120" y="260">4. Compare keys until match found</text>
  <text x="120" y="275">5. Return value or null</text>

  <rect x="40" y="285" width="30" height="20" class="bucket" rx="3"/>
  <text x="45" y="298">5</text>
  <rect x="90" y="285" width="25" height="20" class="key" rx="3"/>
  <text x="95" y="298">K</text>
  <rect x="125" y="285" width="25" height="20" class="value" rx="3"/>
  <text x="130" y="298">V</text>
  <line x1="155" y1="295" x2="175" y2="295" stroke="#666" stroke-width="2"/>
  <text x="185" y="298">Found!</text>

  <!-- Delete Operation -->
  <text x="50" y="330" font-weight="bold">Delete Operation</text>
  <rect x="40" y="340" width="60" height="25" class="operation" rx="5"/>
  <text x="45" y="355">Delete(K)</text>

  <text x="120" y="355">1. Compute hash: index = h(K)</text>
  <text x="120" y="370">2. Find key in bucket[index]</text>
  <text x="120" y="385">3. Remove key-value pair</text>
  <text x="120" y="400">4. Handle chain/probe cleanup</text>

  <rect x="40" y="410" width="30" height="20" class="bucket" rx="3"/>
  <text x="45" y="423">5</text>
  <rect x="90" y="410" width="25" height="20" class="key" rx="3" opacity="0.3"/>
  <text x="95" y="423">K</text>
  <rect x="125" y="410" width="25" height="20" class="value" rx="3" opacity="0.3"/>
  <text x="130" y="423">V</text>
  <text x="165" y="423">Removed</text>

  <!-- Time Complexity -->
  <text x="450" y="50" font-weight="bold">Average Time Complexity</text>
  <rect x="440" y="60" width="80" height="25" class="time" rx="5"/>
  <text x="445" y="75">Insert: O(1)</text>
  <rect x="440" y="90" width="80" height="25" class="time" rx="5"/>
  <text x="445" y="105">Search: O(1)</text>
  <rect x="440" y="120" width="80" height="25" class="time" rx="5"/>
  <text x="445" y="135">Delete: O(1)</text>

  <text x="450" y="160" font-weight="bold">Worst Case (Collisions)</text>
  <rect x="440" y="170" width="80" height="25" class="time" rx="5"/>
  <text x="445" y="185">Insert: O(n)</text>
  <rect x="440" y="200" width="80" height="25" class="time" rx="5"/>
  <text x="445" y="215">Search: O(n)</text>
  <rect x="440" y="230" width="80" height="25" class="time" rx="5"/>
  <text x="445" y="245">Delete: O(n)</text>

  <!-- Load Factor Impact -->
  <text x="450" y="280" font-weight="bold">Load Factor (α = n/m)</text>
  <text x="450" y="295">• α < 0.75: Good performance</text>
  <text x="450" y="310">• α > 1.0: Severe collisions</text>
  <text x="450" y="325">• Rehash when α exceeds threshold</text>

  <!-- Rehashing -->
  <text x="50" y="470" font-weight="bold">Rehashing Process</text>
  <text x="50" y="485">When load factor too high:</text>
  <text x="50" y="500">1. Create new larger table</text>
  <text x="50" y="515">2. Recompute all hashes</text>
  <text x="50" y="530">3. Redistribute elements</text>
  <text x="50" y="545">4. Delete old table</text>

  <text x="10" y="570">Hash tables provide O(1) average case operations through direct addressing and collision resolution.</text>
  <text x="10" y="585">Load factor management is crucial for maintaining performance guarantees.</text>
</svg>
Beginning
C++17
From Novice to Professional
—
Fifth Edition
—
Ivor Horton
Peter Van Weert

Beginning C++17
From Novice to Professional
Fifth Edition

Ivor Horton
Peter Van Weert

Beginning C++17: From Novice to Professional
Ivor Horton 						Peter Van Weert
Stratford-upon-Avon, Warwickshire, United Kingdom		
Kessel-Lo, Belgium
ISBN-13 (pbk): 978-1-4842-3365-8				
https://doi.org/10.1007/978-1-4842-3366-5

ISBN-13 (electronic): 978-1-4842-3366-5

Library of Congress Control Number: 2018936369
Copyright © 2018 by Ivor Horton and Peter Van Weert
This work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part of the
material is concerned, specifically the rights of translation, reprinting, reuse of illustrations, recitation,
broadcasting, reproduction on microfilms or in any other physical way, and transmission or information storage
and retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology now known or
hereafter developed.
Trademarked names, logos, and images may appear in this book. Rather than use a trademark symbol with
every occurrence of a trademarked name, logo, or image we use the names, logos, and images only in an
editorial fashion and to the benefit of the trademark owner, with no intention of infringement of the trademark.
The use in this publication of trade names, trademarks, service marks, and similar terms, even if they are
not identified as such, is not to be taken as an expression of opinion as to whether or not they are subject to
proprietary rights.
While the advice and information in this book are believed to be true and accurate at the date of publication,
neither the authors nor the editors nor the publisher can accept any legal responsibility for any errors or
omissions that may be made. The publisher makes no warranty, express or implied, with respect to the material
contained herein.
Managing Director, Apress Media LLC: Welmoed Spahr
Acquisitions Editor: Steve Anglin
Development Editor: Matthew Moodie
Coordinating Editor: Mark Powers
Cover designed by eStudioCalamar
Cover image designed by Freepik (www.freepik.com)
Distributed to the book trade worldwide by Springer Science+Business Media New York,
233 Spring Street, 6th Floor, New York, NY 10013. Phone 1-800-SPRINGER, fax (201) 348-4505, e-mail
orders-ny@springer-sbm.com, or visit www.springeronline.com. Apress Media, LLC is a California LLC
and the sole member (owner) is Springer Science + Business Media Finance Inc (SSBM Finance Inc).
SSBM Finance Inc is a Delaware corporation.
For information on translations, please e-mail editorial@apress.com; for reprint, paperback, or audio
rights, please email bookpermissions@springernature.com.
Apress titles may be purchased in bulk for academic, corporate, or promotional use. eBook versions
and licenses are also available for most titles. For more information, reference our Print and eBook Bulk
Sales web page at www.apress.com/bulk-sales.
Any source code or other supplementary material referenced by the author in this book is available to
readers on GitHub via the book’s product page, located at www.apress.com/9781484233658. For more
detailed information, please visit www.apress.com/source-code.
Printed on acid-free paper

This is for Alexander and Henry who are both going to learn programming soon.
If their amazing expertise with Minecraft is anything to go by,
they will be brilliant at it.
—Ivor Horton
For my wonderful family. For all your love and support. For putting up with
me never having the time to help out around the house or to play
with the train set I got you for Christmas.
—Peter Van Weert

Contents
About the Authors�������������������������������������������������������������������������������������������������xxiii
About the Technical Reviewer�������������������������������������������������������������������������������xxv
Introduction���������������������������������������������������������������������������������������������������������xxvii
■Chapter
■
1: Basic Ideas������������������������������������������������������������������������������������������� 1
Modern C++��������������������������������������������������������������������������������������������������������������������� 1
Standard Libraries������������������������������������������������������������������������������������������������������������ 2
C++ Program Concepts���������������������������������������������������������������������������������������������������� 3
Source Files and Header Files���������������������������������������������������������������������������������������������������������������� 3
Comments and Whitespace�������������������������������������������������������������������������������������������������������������������� 4
Preprocessing Directives and Standard Library Headers����������������������������������������������������������������������� 4
Functions������������������������������������������������������������������������������������������������������������������������������������������������ 5
Statements��������������������������������������������������������������������������������������������������������������������������������������������� 5
Data Input and Output���������������������������������������������������������������������������������������������������������������������������� 6
return Statements���������������������������������������������������������������������������������������������������������������������������������� 7
Namespaces������������������������������������������������������������������������������������������������������������������������������������������� 7
Names and Keywords����������������������������������������������������������������������������������������������������������������������������� 8

Classes and Objects��������������������������������������������������������������������������������������������������������� 9
Templates������������������������������������������������������������������������������������������������������������������������� 9
Code Appearance and Programming Style����������������������������������������������������������������������� 9
Creating an Executable�������������������������������������������������������������������������������������������������� 10
Procedural and Object-Oriented Programming�������������������������������������������������������������� 12

v

■ Contents

Representing Numbers��������������������������������������������������������������������������������������������������� 13
Binary Numbers������������������������������������������������������������������������������������������������������������������������������������ 13
Hexadecimal Numbers������������������������������������������������������������������������������������������������������������������������� 14
Negative Binary Numbers��������������������������������������������������������������������������������������������������������������������� 16
Octal Values������������������������������������������������������������������������������������������������������������������������������������������ 17
Bi-Endian and Little-Endian Systems��������������������������������������������������������������������������������������������������� 18
Floating-Point Numbers������������������������������������������������������������������������������������������������������������������������ 19

Representing Characters������������������������������������������������������������������������������������������������ 20
ASCII Codes������������������������������������������������������������������������������������������������������������������������������������������ 21
UCS and Unicode���������������������������������������������������������������������������������������������������������������������������������� 21

C++ Source Characters�������������������������������������������������������������������������������������������������� 22
Escape Sequences������������������������������������������������������������������������������������������������������������������������������� 22

Summary������������������������������������������������������������������������������������������������������������������������ 24
■Chapter
■
2: Introducing Fundamental Types of Data�������������������������������������������� 27
Variables, Data, and Data Types������������������������������������������������������������������������������������� 27
Defining Integer Variables�������������������������������������������������������������������������������������������������������������������� 28
Zero Initialization���������������������������������������������������������������������������������������������������������������������������������� 31
Defining Variables with Fixed Values���������������������������������������������������������������������������������������������������� 32

Integer Literals��������������������������������������������������������������������������������������������������������������� 32
Decimal Integer Literals����������������������������������������������������������������������������������������������������������������������� 32
Hexadecimal Literals���������������������������������������������������������������������������������������������������������������������������� 33
Octal Literals����������������������������������������������������������������������������������������������������������������������������������������� 34
Binary Literals�������������������������������������������������������������������������������������������������������������������������������������� 34

Calculations with Integers���������������������������������������������������������������������������������������������� 35
Compound Arithmetic Expressions������������������������������������������������������������������������������������������������������� 36

Assignment Operations�������������������������������������������������������������������������������������������������� 37
The op= Assignment Operators������������������������������������������������������������������������������������������������������������ 40

The sizeof Operator�������������������������������������������������������������������������������������������������������� 42

vi

■ Contents

Incrementing and Decrementing Integers���������������������������������������������������������������������� 42
Postfix Increment and Decrement Operations�������������������������������������������������������������������������������������� 43

Defining Floating-Point Variables����������������������������������������������������������������������������������� 44
Floating-Point Literals���������������������������������������������������������������������������������������������������� 45
Floating-Point Calculations�������������������������������������������������������������������������������������������� 46
Pitfalls��������������������������������������������������������������������������������������������������������������������������������������������������� 46
Invalid Floating-Point Results��������������������������������������������������������������������������������������������������������������� 47
Mathematical Functions����������������������������������������������������������������������������������������������������������������������� 48

Formatting Stream Output���������������������������������������������������������������������������������������������� 51
Mixed Expressions and Type Conversion������������������������������������������������������������������������ 53
Explicit Type Conversion������������������������������������������������������������������������������������������������� 54
Old-Style Casts������������������������������������������������������������������������������������������������������������������������������������� 56

Finding the Limits����������������������������������������������������������������������������������������������������������� 57
Finding Other Properties of Fundamental Types����������������������������������������������������������������������������������� 58

Working with Character Variables���������������������������������������������������������������������������������� 59
Working with Unicode Characters�������������������������������������������������������������������������������������������������������� 60

The auto Keyword���������������������������������������������������������������������������������������������������������� 61
Summary������������������������������������������������������������������������������������������������������������������������ 62
■Chapter
■
3: Working with Fundamental Data Types���������������������������������������������� 65
Operator Precedence and Associativity�������������������������������������������������������������������������� 65
Bitwise Operators����������������������������������������������������������������������������������������������������������� 67
The Bitwise Shift Operators������������������������������������������������������������������������������������������������������������������ 68
Logical Operations on Bit Patterns������������������������������������������������������������������������������������������������������� 71

Enumerated Data Types�������������������������������������������������������������������������������������������������� 77
Aliases for Data Types���������������������������������������������������������������������������������������������������� 80
The Lifetime of a Variable����������������������������������������������������������������������������������������������� 81
Global Variables�������������������������������������������������������������������������������������������������������������� 82
Summary������������������������������������������������������������������������������������������������������������������������ 85

vii

■ Contents

■Chapter
■
4: Making Decisions������������������������������������������������������������������������������� 89
Comparing Data Values�������������������������������������������������������������������������������������������������� 89
Applying the Comparison Operators����������������������������������������������������������������������������������������������������� 90
Comparing Floating-Point Values��������������������������������������������������������������������������������������������������������� 92

The if Statement������������������������������������������������������������������������������������������������������������� 92
Nested if Statements���������������������������������������������������������������������������������������������������������������������������� 96
Character Classification and Conversion���������������������������������������������������������������������������������������������� 97

The if-else Statement����������������������������������������������������������������������������������������������������� 99
Nested if-else Statements������������������������������������������������������������������������������������������������������������������ 101
Understanding Nested ifs������������������������������������������������������������������������������������������������������������������� 102

Logical Operators��������������������������������������������������������������������������������������������������������� 103
Logical AND���������������������������������������������������������������������������������������������������������������������������������������� 104
Logical OR������������������������������������������������������������������������������������������������������������������������������������������� 104
Logical Negation��������������������������������������������������������������������������������������������������������������������������������� 105
Combining Logical Operators������������������������������������������������������������������������������������������������������������� 105
Logical Operators on Integer Operands���������������������������������������������������������������������������������������������� 107
Logical Operators vs. Bitwise Operators�������������������������������������������������������������������������������������������� 108

The Conditional Operator���������������������������������������������������������������������������������������������� 110
The switch Statement�������������������������������������������������������������������������������������������������� 112
Fallthrough����������������������������������������������������������������������������������������������������������������������������������������� 116

Statement Blocks and Variable Scope�������������������������������������������������������������������������� 118
Initialization Statements��������������������������������������������������������������������������������������������������������������������� 119

Summary���������������������������������������������������������������������������������������������������������������������� 120
■Chapter
■
5: Arrays and Loops����������������������������������������������������������������������������� 123
Arrays��������������������������������������������������������������������������������������������������������������������������� 123
Using an Array������������������������������������������������������������������������������������������������������������������������������������ 123

Understanding Loops��������������������������������������������������������������������������������������������������� 125
The for Loop����������������������������������������������������������������������������������������������������������������� 126
Avoiding Magic Numbers��������������������������������������������������������������������������������������������� 128
Defining the Array Size with the Braced Initializer������������������������������������������������������� 130
viii

■ Contents

Determining the Size of an Array��������������������������������������������������������������������������������� 130
Controlling a for Loop with Floating-Point Values�������������������������������������������������������� 132
More Complex for Loop Control Expressions ��������������������������������������������������������������� 135
The Comma Operator�������������������������������������������������������������������������������������������������������������������������� 136

The Range-Based for Loop������������������������������������������������������������������������������������������� 137
The while Loop������������������������������������������������������������������������������������������������������������� 138
The do-while Loop�������������������������������������������������������������������������������������������������������� 140
Nested Loops���������������������������������������������������������������������������������������������������������������� 142
Skipping Loop Iterations����������������������������������������������������������������������������������������������� 145
Breaking Out of a Loop������������������������������������������������������������������������������������������������� 146
Indefinite Loops���������������������������������������������������������������������������������������������������������������������������������� 146

Controlling a for Loop with Unsigned Integers������������������������������������������������������������� 150
Arrays of Characters����������������������������������������������������������������������������������������������������� 152
Multidimensional Arrays����������������������������������������������������������������������������������������������� 155
Initializing Multidimensional Arrays���������������������������������������������������������������������������������������������������� 158
Multidimensional Character Arrays���������������������������������������������������������������������������������������������������� 160

Allocating an Array at Runtime������������������������������������������������������������������������������������� 161
Alternatives to Using an Array�������������������������������������������������������������������������������������� 164
Using array<T,N> Containers������������������������������������������������������������������������������������������������������������� 164
Using std::vector<T> Containers�������������������������������������������������������������������������������������������������������� 169

Summary���������������������������������������������������������������������������������������������������������������������� 174
■Chapter
■
6: Pointers and References������������������������������������������������������������������ 177
What Is a Pointer?�������������������������������������������������������������������������������������������������������� 177
The Address-Of Operator���������������������������������������������������������������������������������������������� 180
The Indirection Operator����������������������������������������������������������������������������������������������� 181
Why Use Pointers?������������������������������������������������������������������������������������������������������� 183
Pointers to Type char���������������������������������������������������������������������������������������������������� 183
Arrays of Pointers������������������������������������������������������������������������������������������������������������������������������� 186

Constant Pointers and Pointers to Constants��������������������������������������������������������������� 188
ix

■ Contents

Pointers and Arrays������������������������������������������������������������������������������������������������������ 190
Pointer Arithmetic������������������������������������������������������������������������������������������������������������������������������� 191
Using Pointer Notation with an Array Name��������������������������������������������������������������������������������������� 193

Dynamic Memory Allocation����������������������������������������������������������������������������������������� 196
The Stack and the Free Store������������������������������������������������������������������������������������������������������������� 196
Using the new and delete Operators�������������������������������������������������������������������������������������������������� 197
Dynamic Allocation of Arrays�������������������������������������������������������������������������������������������������������������� 199

Member Selection Through a Pointer��������������������������������������������������������������������������� 203
Hazards of Dynamic Memory Allocation����������������������������������������������������������������������� 203
Dangling Pointers and Multiple Deallocations������������������������������������������������������������������������������������ 204
Allocation/Deallocation Mismatch������������������������������������������������������������������������������������������������������ 204
Memory Leaks������������������������������������������������������������������������������������������������������������������������������������ 204
Fragmentation of the Free Store��������������������������������������������������������������������������������������������������������� 205

Golden Rule of Dynamic Memory Allocation���������������������������������������������������������������� 206
Raw Pointers and Smart Pointers�������������������������������������������������������������������������������� 206
Using unique_ptr<T> Pointers����������������������������������������������������������������������������������������������������������� 208
Using shared_ptr<T> Pointers����������������������������������������������������������������������������������������������������������� 211

Understanding References������������������������������������������������������������������������������������������� 214
Defining References��������������������������������������������������������������������������������������������������������������������������� 214
Using a Reference Variable in a Range-Based for Loop��������������������������������������������������������������������� 216

Summary���������������������������������������������������������������������������������������������������������������������� 217
■Chapter
■
7: Working with Strings����������������������������������������������������������������������� 219
A Better Class of String������������������������������������������������������������������������������������������������ 219
Defining string Objects����������������������������������������������������������������������������������������������������������������������� 220
Operations with String Objects����������������������������������������������������������������������������������������������������������� 223
Accessing Characters in a String������������������������������������������������������������������������������������������������������� 228
Accessing Substrings������������������������������������������������������������������������������������������������������������������������� 230
Comparing Strings������������������������������������������������������������������������������������������������������������������������������ 230
Searching Strings������������������������������������������������������������������������������������������������������������������������������� 237
Modifying a String������������������������������������������������������������������������������������������������������������������������������ 243
std::string vs. std::vector<char>�������������������������������������������������������������������������������������������������������� 248
x

■ Contents

Converting Strings into Numbers��������������������������������������������������������������������������������� 248
String Streams������������������������������������������������������������������������������������������������������������� 249
Strings of International Characters������������������������������������������������������������������������������ 250
Strings of wchar_t Characters������������������������������������������������������������������������������������������������������������ 251
Objects That Contain Unicode Strings������������������������������������������������������������������������������������������������ 252

Raw String Literals������������������������������������������������������������������������������������������������������� 252
Summary���������������������������������������������������������������������������������������������������������������������� 254
■Chapter
■
8: Defining Functions��������������������������������������������������������������������������� 257
Segmenting Your Programs������������������������������������������������������������������������������������������ 257
Functions in Classes��������������������������������������������������������������������������������������������������������������������������� 258
Characteristics of a Function�������������������������������������������������������������������������������������������������������������� 258

Defining Functions������������������������������������������������������������������������������������������������������� 258
The Function Body������������������������������������������������������������������������������������������������������������������������������ 260
Return Values������������������������������������������������������������������������������������������������������������������������������������� 262
Function Declarations������������������������������������������������������������������������������������������������������������������������� 263

Passing Arguments to a Function��������������������������������������������������������������������������������� 264
Pass-by-Value������������������������������������������������������������������������������������������������������������������������������������� 265
Pass-by-Reference����������������������������������������������������������������������������������������������������������������������������� 273
String Views: The New Reference-to-const-string����������������������������������������������������������������������������� 280

Default Argument Values���������������������������������������������������������������������������������������������� 283
Multiple Default Parameter Values����������������������������������������������������������������������������������������������������� 283

Arguments to main()����������������������������������������������������������������������������������������������������� 285
Returning Values from a Function�������������������������������������������������������������������������������� 286
Returning a Pointer����������������������������������������������������������������������������������������������������������������������������� 286
Returning a Reference������������������������������������������������������������������������������������������������������������������������ 290
Returning vs. Output Parameters������������������������������������������������������������������������������������������������������� 291
Return Type Deduction������������������������������������������������������������������������������������������������������������������������ 292

Working with Optional Values��������������������������������������������������������������������������������������� 293
std::optional���������������������������������������������������������������������������������������������������������������������������������������� 294

Static Variables������������������������������������������������������������������������������������������������������������� 297
xi

■ Contents

Inline Functions������������������������������������������������������������������������������������������������������������ 297
Function Overloading��������������������������������������������������������������������������������������������������� 298
Overloading and Pointer Parameters�������������������������������������������������������������������������������������������������� 300
Overloading and Reference Parameters��������������������������������������������������������������������������������������������� 301
Overloading and const Parameters���������������������������������������������������������������������������������������������������� 302
Overloading and Default Argument Values����������������������������������������������������������������������������������������� 304

Recursion��������������������������������������������������������������������������������������������������������������������� 305
Basic Examples���������������������������������������������������������������������������������������������������������������������������������� 306
Recursive Algorithms�������������������������������������������������������������������������������������������������������������������������� 307

Summary���������������������������������������������������������������������������������������������������������������������� 314
■Chapter
■
9: Function Templates�������������������������������������������������������������������������� 319
Function Templates������������������������������������������������������������������������������������������������������ 319
Creating Instances of a Function Template������������������������������������������������������������������ 320
Template Type Parameters������������������������������������������������������������������������������������������� 322
Explicit Template Arguments���������������������������������������������������������������������������������������� 323
Function Template Specialization��������������������������������������������������������������������������������� 323
Function Templates and Overloading��������������������������������������������������������������������������� 324
Function Templates with Multiple Parameters������������������������������������������������������������� 326
Return Type Deduction for Templates��������������������������������������������������������������������������� 328
decltype() and Trailing Return Types��������������������������������������������������������������������������������������������������� 328
decltype(auto) and decltype() vs. auto������������������������������������������������������������������������������������������������ 330

Default Values for Template Parameters���������������������������������������������������������������������� 330
Nontype Template Parameters������������������������������������������������������������������������������������� 331
Templates for Functions with Fixed-Size Array Arguments���������������������������������������������������������������� 332

Summary���������������������������������������������������������������������������������������������������������������������� 334
■Chapter
■
10: Program Files and Preprocessing Directives��������������������������������� 337
Understanding Translation Units���������������������������������������������������������������������������������� 337
The One Definition Rule���������������������������������������������������������������������������������������������������������������������� 338
Program Files and Linkage����������������������������������������������������������������������������������������������������������������� 339

xii

■ Contents

Determining Linkage for a Name�������������������������������������������������������������������������������������������������������� 339
External Functions������������������������������������������������������������������������������������������������������������������������������ 339
External Variables������������������������������������������������������������������������������������������������������������������������������� 341
Internal Names����������������������������������������������������������������������������������������������������������������������������������� 343

Preprocessing Your Source Code��������������������������������������������������������������������������������� 344
Defining Preprocessor Macros������������������������������������������������������������������������������������� 345
Defining Function-Like Macros����������������������������������������������������������������������������������������������������������� 346
Undefining Macros����������������������������������������������������������������������������������������������������������������������������� 349

Including Header Files�������������������������������������������������������������������������������������������������� 350
Preventing Duplication of Header File Contents��������������������������������������������������������������������������������� 350
Your First Header File������������������������������������������������������������������������������������������������������������������������� 352

Namespaces����������������������������������������������������������������������������������������������������������������� 353
The Global Namespace����������������������������������������������������������������������������������������������������������������������� 353
Defining a Namespace����������������������������������������������������������������������������������������������������������������������� 354
Applying using Declarations��������������������������������������������������������������������������������������������������������������� 356
Functions and Namespaces��������������������������������������������������������������������������������������������������������������� 357
Unnamed Namespaces����������������������������������������������������������������������������������������������������������������������� 359
Nested Namespaces��������������������������������������������������������������������������������������������������������������������������� 360
Namespace Aliases���������������������������������������������������������������������������������������������������������������������������� 362

Logical Preprocessing Directives��������������������������������������������������������������������������������� 362
The Logical #if Directive��������������������������������������������������������������������������������������������������������������������� 362
Testing for Specific Identifier Values�������������������������������������������������������������������������������������������������� 363
Multiple-Choice Code Selection���������������������������������������������������������������������������������������������������������� 363
Standard Preprocessing Macros�������������������������������������������������������������������������������������������������������� 365
Testing for Available Headers������������������������������������������������������������������������������������������������������������� 366

Debugging Methods����������������������������������������������������������������������������������������������������� 367
Integrated Debuggers������������������������������������������������������������������������������������������������������������������������� 367
Preprocessing Directives in Debugging���������������������������������������������������������������������������������������������� 368
Using the assert() Macro�������������������������������������������������������������������������������������������������������������������� 371

Static Assertions���������������������������������������������������������������������������������������������������������� 373
Summary���������������������������������������������������������������������������������������������������������������������� 375
xiii

■ Contents

■Chapter
■
11: Defining Your Own Data Types������������������������������������������������������� 379
Classes and Object-Oriented Programming����������������������������������������������������������������� 379
Encapsulation������������������������������������������������������������������������������������������������������������������������������������� 380
Inheritance������������������������������������������������������������������������������������������������������������������������������������������ 383
Polymorphism������������������������������������������������������������������������������������������������������������������������������������� 384

Terminology������������������������������������������������������������������������������������������������������������������ 385
Defining a Class����������������������������������������������������������������������������������������������������������� 386
Constructors����������������������������������������������������������������������������������������������������������������� 388
Default Constructors��������������������������������������������������������������������������������������������������������������������������� 388
Defining a Class Constructor�������������������������������������������������������������������������������������������������������������� 389
Using the default Keyword����������������������������������������������������������������������������������������������������������������� 391
Defining Functions and Constructors Outside the Class��������������������������������������������������������������������� 391
Default Constructor Parameter Values������������������������������������������������������������������������������������������������ 393
Using a Member Initializer List����������������������������������������������������������������������������������������������������������� 394
Using the explicit Keyword����������������������������������������������������������������������������������������������������������������� 394
Delegating Constructors��������������������������������������������������������������������������������������������������������������������� 397
The Copy Constructor������������������������������������������������������������������������������������������������������������������������� 398

Accessing Private Class Members������������������������������������������������������������������������������� 400
The this Pointer������������������������������������������������������������������������������������������������������������ 402
Returning this from a Function����������������������������������������������������������������������������������������������������������� 402

const Objects and const Member Functions���������������������������������������������������������������� 404
const Member Functions�������������������������������������������������������������������������������������������������������������������� 404
const Correctness������������������������������������������������������������������������������������������������������������������������������� 406
Overloading on const�������������������������������������������������������������������������������������������������������������������������� 407
Casting Away const���������������������������������������������������������������������������������������������������������������������������� 409
Using the mutable Keyword���������������������������������������������������������������������������������������������������������������� 409

Friends������������������������������������������������������������������������������������������������������������������������� 410
The Friend Functions of a Class��������������������������������������������������������������������������������������������������������� 411
Friend Classes������������������������������������������������������������������������������������������������������������������������������������ 413

Arrays of Class Objects������������������������������������������������������������������������������������������������ 413
xiv

■ Contents

The Size of a Class Object�������������������������������������������������������������������������������������������� 415
Static Members of a Class������������������������������������������������������������������������������������������� 416
Static Member Variables��������������������������������������������������������������������������������������������������������������������� 416
Accessing Static Member Variables��������������������������������������������������������������������������������������������������� 420
Static Constants��������������������������������������������������������������������������������������������������������������������������������� 421
Static Member Variables of the Class Type����������������������������������������������������������������������������������������� 422
Static Member Functions������������������������������������������������������������������������������������������������������������������� 423

Destructors������������������������������������������������������������������������������������������������������������������� 424
Using Pointers as Class Members�������������������������������������������������������������������������������� 427
The Truckload Example����������������������������������������������������������������������������������������������������������������������� 427

Nested Classes������������������������������������������������������������������������������������������������������������� 440
Nested Classes with Public Access���������������������������������������������������������������������������������������������������� 441

Summary���������������������������������������������������������������������������������������������������������������������� 445
■Chapter
■
12: Operator Overloading��������������������������������������������������������������������� 449
Implementing Operators for a Class����������������������������������������������������������������������������� 449
Operator Overloading�������������������������������������������������������������������������������������������������������������������������� 450
Implementing an Overloaded Operator����������������������������������������������������������������������������������������������� 450
Nonmember Operator Functions�������������������������������������������������������������������������������������������������������� 453
Implementing Full Support for an Operator���������������������������������������������������������������������������������������� 453
Implementing All Comparison Operators in a Class���������������������������������������������������������������������������� 456

Operators That Can Be Overloaded������������������������������������������������������������������������������ 458
Restrictions and Key Guideline����������������������������������������������������������������������������������������������������������� 459

Operator Function Idioms��������������������������������������������������������������������������������������������� 461
Overloading the << Operator for Output Streams�������������������������������������������������������� 462
Overloading the Arithmetic Operators�������������������������������������������������������������������������� 463
Implementing One Operator in Terms of Another������������������������������������������������������������������������������� 467

Member vs. Nonmember Functions����������������������������������������������������������������������������� 469
Operator Functions and Implicit Conversions������������������������������������������������������������������������������������� 470

Overloading Unary Operators��������������������������������������������������������������������������������������� 471
Overloading the Increment and Decrement Operators������������������������������������������������� 473
xv

■ Contents

Overloading the Subscript Operator����������������������������������������������������������������������������� 474
Modifying the Result of an Overloaded Subscript Operator���������������������������������������������������������������� 478

Function Objects���������������������������������������������������������������������������������������������������������� 480
Overloading Type Conversions������������������������������������������������������������������������������������� 482
Potential Ambiguities with Conversions��������������������������������������������������������������������������������������������� 483

Overloading the Assignment Operator�������������������������������������������������������������������������� 483
Implementing the Copy Assignment Operator������������������������������������������������������������������������������������ 483
Copy Assignment vs. Copy Construction�������������������������������������������������������������������������������������������� 487
Assigning Different Types������������������������������������������������������������������������������������������������������������������� 488

Summary���������������������������������������������������������������������������������������������������������������������� 488
■Chapter
■
13: Inheritance������������������������������������������������������������������������������������� 491
Classes and Object-Oriented Programming����������������������������������������������������������������� 491
Hierarchies����������������������������������������������������������������������������������������������������������������������������������������� 492

Inheritance in Classes�������������������������������������������������������������������������������������������������� 493
Inheritance vs. Aggregation���������������������������������������������������������������������������������������������������������������� 493
Deriving Classes��������������������������������������������������������������������������������������������������������������������������������� 494

protected Members of a Class������������������������������������������������������������������������������������� 497
The Access Level of Inherited Class Members������������������������������������������������������������� 498
Access Specifiers and Class Hierarchies�������������������������������������������������������������������������������������������� 499
Choosing Access Specifiers in Class Hierarchies������������������������������������������������������������������������������� 500
Changing the Access Specification of Inherited Members����������������������������������������������������������������� 501

Constructors in a Derived Class����������������������������������������������������������������������������������� 502
The Copy Constructor in a Derived Class�������������������������������������������������������������������������������������������� 506
The Default Constructor in a Derived Class���������������������������������������������������������������������������������������� 508
Inheriting Constructors����������������������������������������������������������������������������������������������������������������������� 508

Destructors Under Inheritance������������������������������������������������������������������������������������� 509
The Order in Which Destructors Are Called����������������������������������������������������������������������������������������� 511

Duplicate Member Variable Names������������������������������������������������������������������������������ 511

xvi

■ Contents

Duplicate Member Function Names����������������������������������������������������������������������������� 512
Multiple Inheritance����������������������������������������������������������������������������������������������������� 513
Multiple Base Classes������������������������������������������������������������������������������������������������������������������������ 513
Inherited Member Ambiguity�������������������������������������������������������������������������������������������������������������� 514
Repeated Inheritance������������������������������������������������������������������������������������������������������������������������� 519
Virtual Base Classes��������������������������������������������������������������������������������������������������������������������������� 520

Converting Between Related Class Types�������������������������������������������������������������������� 521
Summary���������������������������������������������������������������������������������������������������������������������� 522
■Chapter
■
14: Polymorphism�������������������������������������������������������������������������������� 525
Understanding Polymorphism�������������������������������������������������������������������������������������� 525
Using a Base Class Pointer����������������������������������������������������������������������������������������������������������������� 525
Calling Inherited Functions����������������������������������������������������������������������������������������������������������������� 527
Virtual Functions��������������������������������������������������������������������������������������������������������������������������������� 530
Default Argument Values in Virtual Functions������������������������������������������������������������������������������������� 539
Using References to Call Virtual Functions����������������������������������������������������������������������������������������� 541
Polymorphic Collections��������������������������������������������������������������������������������������������������������������������� 542
Destroying Objects Through a Pointer������������������������������������������������������������������������������������������������ 543
Converting Between Pointers to Class Objects����������������������������������������������������������������������������������� 546
Dynamic Casts������������������������������������������������������������������������������������������������������������������������������������ 548
Calling the Base Class Version of a Virtual Function��������������������������������������������������������������������������� 552
Calling Virtual Functions from Constructors or Destructors��������������������������������������������������������������� 553

The Cost of Polymorphism������������������������������������������������������������������������������������������� 555
Determining the Dynamic Type������������������������������������������������������������������������������������ 557
Pure Virtual Functions�������������������������������������������������������������������������������������������������� 561
Abstract Classes��������������������������������������������������������������������������������������������������������������������������������� 561
Abstract Classes as Interfaces����������������������������������������������������������������������������������������������������������� 564

Summary���������������������������������������������������������������������������������������������������������������������� 567

xvii

■ Contents

■Chapter
■
15: Runtime Errors and Exceptions����������������������������������������������������� 571
Handling Errors������������������������������������������������������������������������������������������������������������ 571
Understanding Exceptions�������������������������������������������������������������������������������������������� 572
Throwing an Exception����������������������������������������������������������������������������������������������������������������������� 573
The Exception-Handling Process�������������������������������������������������������������������������������������������������������� 576
Code That Causes an Exception to Be Thrown����������������������������������������������������������������������������������� 577
Nested try Blocks������������������������������������������������������������������������������������������������������������������������������� 578

Class Objects as Exceptions����������������������������������������������������������������������������������������� 581
Matching a Catch Handler to an Exception����������������������������������������������������������������������������������������� 583
Catching Derived Class Exceptions with a Base Class Handler���������������������������������������������������������� 586

Rethrowing Exceptions������������������������������������������������������������������������������������������������� 589
Unhandled Exceptions�������������������������������������������������������������������������������������������������� 591
Catching All Exceptions������������������������������������������������������������������������������������������������ 593
Functions That Don’t Throw Exceptions����������������������������������������������������������������������� 595
The noexcept Specifier����������������������������������������������������������������������������������������������������������������������� 595
Exceptions and Destructors���������������������������������������������������������������������������������������������������������������� 596

Exceptions and Resource Leaks����������������������������������������������������������������������������������� 597
Resource Acquisition Is Initialization�������������������������������������������������������������������������������������������������� 599
Standard RAII Classes for Dynamic Memory�������������������������������������������������������������������������������������� 601

Standard Library Exceptions���������������������������������������������������������������������������������������� 602
The Exception Class Definitions��������������������������������������������������������������������������������������������������������� 604
Using Standard Exceptions����������������������������������������������������������������������������������������������������������������� 606

Summary���������������������������������������������������������������������������������������������������������������������� 609
■Chapter
■
16: Class Templates����������������������������������������������������������������������������� 613
Understanding Class Templates����������������������������������������������������������������������������������� 614
Defining Class Templates��������������������������������������������������������������������������������������������� 615
Template Parameters�������������������������������������������������������������������������������������������������������������������������� 615
A Simple Class Template�������������������������������������������������������������������������������������������������������������������� 616

xviii

■ Contents

Defining Member Functions of a Class Template��������������������������������������������������������� 618
Constructor Templates������������������������������������������������������������������������������������������������������������������������ 618
The Destructor Template�������������������������������������������������������������������������������������������������������������������� 619
Subscript Operator Templates������������������������������������������������������������������������������������������������������������ 620
The Assignment Operator Template���������������������������������������������������������������������������������������������������� 622

Instantiating a Class Template������������������������������������������������������������������������������������� 627
Class Template Argument Deduction�������������������������������������������������������������������������������������������������� 632

Nontype Class Template Parameters���������������������������������������������������������������������������� 634
Templates for Member Functions with Nontype Parameters������������������������������������������������������������� 636
Arguments for Nontype Parameters��������������������������������������������������������������������������������������������������� 641
Nontype Template Arguments vs. Constructor Arguments����������������������������������������������������������������� 641

Default Values for Template Parameters���������������������������������������������������������������������� 642
Explicit Template Instantiation������������������������������������������������������������������������������������� 643
Class Template Specialization�������������������������������������������������������������������������������������� 643
Defining a Class Template Specialization������������������������������������������������������������������������������������������� 644
Partial Template Specialization����������������������������������������������������������������������������������������������������������� 644
Choosing Between Multiple Partial Specializations���������������������������������������������������������������������������� 645

Using static_assert( ) in a Class Template�������������������������������������������������������������������� 645
Friends of Class Templates������������������������������������������������������������������������������������������ 647
Class Templates with Nested Classes�������������������������������������������������������������������������� 649
Function Templates for Stack Members��������������������������������������������������������������������������������������������� 651
Disambiguating Dependent Names���������������������������������������������������������������������������������������������������� 656

Summary���������������������������������������������������������������������������������������������������������������������� 658
■Chapter
■
17: Move Semantics����������������������������������������������������������������������������� 661
Lvalues and Rvalues����������������������������������������������������������������������������������������������������� 662
Rvalue References������������������������������������������������������������������������������������������������������������������������������ 663

Moving Objects������������������������������������������������������������������������������������������������������������� 664
Traditional Workarounds��������������������������������������������������������������������������������������������������������������������� 667
Defining Move Members��������������������������������������������������������������������������������������������������������������������� 668

xix

■ Contents

Explicitly Moved Objects���������������������������������������������������������������������������������������������� 672
Move-Only Types�������������������������������������������������������������������������������������������������������������������������������� 672
Extended Use of Moved Objects��������������������������������������������������������������������������������������������������������� 673

A Barrel of Contradictions�������������������������������������������������������������������������������������������� 675
std::move() Does Not Move����������������������������������������������������������������������������������������������������������������� 675
An Rvalue Reference Is an Lvalue������������������������������������������������������������������������������������������������������ 676

Defining Functions Revisited���������������������������������������������������������������������������������������� 676
Pass-by-Rvalue-Reference����������������������������������������������������������������������������������������������������������������� 676
The Return of Pass-by-Value�������������������������������������������������������������������������������������������������������������� 678
Return-by-Value��������������������������������������������������������������������������������������������������������������������������������� 681

Defining Move Members Revisited������������������������������������������������������������������������������� 683
Always Add noexcept�������������������������������������������������������������������������������������������������������������������������� 683
The “Move-and-Swap” Idiom������������������������������������������������������������������������������������������������������������� 688

Special Member Functions������������������������������������������������������������������������������������������� 689
Default Move Members���������������������������������������������������������������������������������������������������������������������� 690
The Rule of Five���������������������������������������������������������������������������������������������������������������������������������� 691
The Rule of Zero��������������������������������������������������������������������������������������������������������������������������������� 692

Summary���������������������������������������������������������������������������������������������������������������������� 693
■Chapter
■
18: First-Class Functions��������������������������������������������������������������������� 695
Pointers to Functions��������������������������������������������������������������������������������������������������� 696
Defining Pointers to Functions����������������������������������������������������������������������������������������������������������� 696
Callback Functions for Higher-Order Functions���������������������������������������������������������������������������������� 699
Type Aliases for Function Pointers������������������������������������������������������������������������������������������������������ 701

Function Objects���������������������������������������������������������������������������������������������������������� 703
Basic Function Objects����������������������������������������������������������������������������������������������������������������������� 703
Standard Function Objects����������������������������������������������������������������������������������������������������������������� 705
Parameterized Function Objects��������������������������������������������������������������������������������������������������������� 706

Lambda Expressions���������������������������������������������������������������������������������������������������� 707
Defining a Lambda Expression����������������������������������������������������������������������������������������������������������� 708
Naming a Lambda Closure����������������������������������������������������������������������������������������������������������������� 709

xx

■ Contents

Passing a Lambda Expression to a Function Template����������������������������������������������������������������������� 709
The Capture Clause���������������������������������������������������������������������������������������������������������������������������� 711

The std::function<> Template�������������������������������������������������������������������������������������� 716
Summary���������������������������������������������������������������������������������������������������������������������� 718
■Chapter
■
19: Containers and Algorithms������������������������������������������������������������ 721
Containers�������������������������������������������������������������������������������������������������������������������� 721
Sequence Containers�������������������������������������������������������������������������������������������������������������������������� 722
Stacks and Queues����������������������������������������������������������������������������������������������������������������������������� 725
Sets���������������������������������������������������������������������������������������������������������������������������������������������������� 727
Maps��������������������������������������������������������������������������������������������������������������������������������������������������� 730

Iterators������������������������������������������������������������������������������������������������������������������������ 735
The Iterator Design Pattern���������������������������������������������������������������������������������������������������������������� 735
Iterators for Standard Library Containers������������������������������������������������������������������������������������������� 737
Iterators for Arrays������������������������������������������������������������������������������������������������������������������������������ 746

Algorithms�������������������������������������������������������������������������������������������������������������������� 747
A First Example����������������������������������������������������������������������������������������������������������������������������������� 748
Finding Elements�������������������������������������������������������������������������������������������������������������������������������� 750
Outputting Multiple Values������������������������������������������������������������������������������������������������������������������ 752
The Remove-Erase Idiom�������������������������������������������������������������������������������������������������������������������� 753
Sorting������������������������������������������������������������������������������������������������������������������������������������������������ 755
Parallel Algorithms����������������������������������������������������������������������������������������������������������������������������� 756

Summary���������������������������������������������������������������������������������������������������������������������� 756
Index��������������������������������������������������������������������������������������������������������������������� 761

xxi

About the Authors
Ivor Horton graduated as a mathematician and was lured into
information technology with promises of great rewards for very little
work. In spite of the reality being a great deal of work for relatively modest
rewards, he has continued to work with computers to the present day.
He has been engaged at various times in programming, systems design,
consultancy, and the management and implementation of projects of
considerable complexity.
Ivor has many years of experience in designing and implementing
systems for engineering design and manufacturing control. He
has developed occasionally useful applications in a wide variety of
programming languages and has taught primarily scientists and engineers
to do likewise. His currently published works include tutorials on C, C++,
and Java. At the present time, when he is not writing programming books
or providing advice to others, he spends his time fishing, traveling, and
enjoying life in general.

Peter Van Weert is a Belgian software engineer whose main interests and
expertise are application software development, programming languages,
algorithms, and data structures.
He received his master of science degree in computer science summa
cum laude with congratulations of the Board of Examiners from the
University of Leuven. In 2010, he completed his PhD thesis there on the
design and efficient compilation of rule-based programming languages at
the research group for declarative programming languages and artificial
intelligence. During his doctoral studies, he was a teaching assistant for
object-oriented programming (Java), software analysis and design, and
declarative programming.
After graduating, Peter worked at Nikon Metrology for more than
six years on large-scale, industrial application software in the area of 3D
laser scanning and point cloud inspection. He learned to master C++ and refactoring and debugging of
very large code bases, and he gained further proficiency in all aspects of the software development process,
including the analysis of functional and technical requirements, and agile and scrum-based project and
team management.
Today, Peter works for Danaher in its R&D unit for digital dentistry software, developing software for the
dental practice of tomorrow.
In his spare time, he has co-authored two books on C++ and two award-winning Windows 8 apps and is
a regular expert speaker at, and board member of, the Belgian C++ Users Group.

xxiii

About the Technical Reviewer
Marc Gregoire is a software engineer from Belgium. He graduated from the University of Leuven, Belgium,
with a degree in “Burgerlijk ingenieur in de computer wetenschappen” (equivalent to a master of science
degree in computer engineering). The year after, he received the cum laude degree of master in artificial
intelligence at the same university. After his studies, Marc started working for a software consultancy
company called Ordina Belgium. As a consultant, he worked for Siemens and Nokia Siemens Networks on
critical 2G and 3G software running on Solaris for telecom operators. This required working on international
teams stretching from South America and the United States to Europe, the Middle East, and Asia. Currently,
Marc works for Nikon Metrology on industrial 3D laser scanning software.

xxv

Introduction
Welcome to Beginning C++17. This is a revised and updated version of Ivor Horton’s original book called
Beginning ANSI C++. The C++ language has been extended and improved considerably since then, so
much so that it was no longer possible to squeeze detailed explanations of all of C++ into a single book. This
tutorial will teach the essentials of the C++ language and Standard Library features, which will be more than
enough for you to write your own C++ applications. With the knowledge from this book, you should have no
difficulty in extending the depth and scope of your C++ expertise.
We have assumed no prior programming knowledge. If you are keen to learn and have an aptitude for
thinking logically, getting a grip on C++ will be easier than you might imagine. By developing C++ skills,
you’ll be learning a language that is already used by millions and that provides the capability for application
development in just about any context.
C++ is very powerful. Arguably, it’s more powerful than most programming languages. So, yes, like with
any powerful tool you can wield some considerable damage if you use it without proper training. We often
compare C++ to a Swiss Army knife: age-old, trusted, incredibly versatile, yet potentially mind-boggling and
full of pointy things that could really hurt you. Once someone clearly explains to you what all the different
tools are meant for, however, and teaches you some elementary knife safety rules, then you’ll never have to
look for another pocketknife again.
C++ does not need to be dangerous or difficult at all either. C++ today is much more accessible
than many people assume. The language has come a long way since its conception nearly 40 years ago.
In essence, we have learned how to wield all its mighty blades and tools in the safest and most effective
way possible. And, more importantly perhaps, the C++ language and its Standard Library have evolved
accordingly to facilitate this. The past decade in particular has seen the rise of what is now known as
“modern C++.” Modern C++ emphasizes the use of newer, more expressive, safer language features,
combined with tried and tested best practices and coding guidelines. Once you know and apply a handful of
simple rules and techniques, C++ loses much of its complexity. Key is that someone properly and gradually
explains not simply what you can do with C++ but rather what you should do with C++. And that’s where this
book comes in!
In this latest revision of the book, we have gone through great lengths to bring it back in line with the
new, modern era of C++ programming we’re living in. As before, we of course do so in the form of a gradual,
informal tutorial. We’ll introduce to you all the shiny blades and pointy things C++ has to offer—both old
and new—using many hands-on coding samples and exercises. But that’s not all: more than ever before
we’ve made sure to always explain which tool is best to use for which purpose, why that is the case, and
how to avoid getting cut. We’ve made sure that you will begin C++, from day one, using the safe, productive,
modern programming style that employers will expect from you tomorrow.
The C++ language in this book corresponds to the latest International Organization for Standardization
(ISO) standard, commonly referred to as C++17. Not everything of C++17 is covered, since many of the
extensions compared to previous versions of the language are targeted toward more advanced use. All the
examples in the book can be compiled and executed using C++17-conforming compilers that are available
now.

xxvii

■ Introduction

Using the Book
To learn C++ with this book, you’ll need a compiler that conforms to the C++17 standard and a text editor
suitable for working with program code. Several compilers are available currently that are C++17 compliant,
some of which are free.
The GCC and Clang compilers have comprehensive support for C++17 and are both open source and
free to download. Installing them and putting them together with a suitable editor can be a little tricky if
you are new to this kind of thing. An easy way to install GCC along with a suitable editor is to download
Code::Blocks or Qt Creator. Both are free integrated development environments (IDEs) for Linux, Apple
macOS, and Microsoft Windows. They support a complete program development for several compilers,
including GCC and Clang. This implies you get support for both C and C++.
Another possibility is to use Microsoft Visual C++ that runs under Microsoft Windows. It is nearly fully
compliant with C++17 as well; all examples in this book should compile with the latest version just fine. The
Community and Express editions are free for individual use or even small professional teams. With Visual
Studio you get a comprehensive professional editor and support for other languages such as C# and Basic.
There are other compilers that support C++17 as well, which you can find with a quick online search.
The online download section for this book also contains a list of further useful resources on how to get
started.
We’ve organized the material in this book to be read sequentially, so you should start at the beginning
and keep going until you reach the end. However, no one ever learned programming by just reading a book.
You’ll only learn how to program in C++ by writing code, so make sure you key in all the examples—don’t
just copy them from the download files—and compile and execute the code that you’ve keyed in. This
might seem tedious at times, but it’s surprising how much just typing in C++ statements will help your
understanding, especially when you may feel you’re struggling with some of the ideas. If an example doesn’t
work, resist the temptation to go straight back to the book to see why. Try to figure out from your code what
is wrong. This is good practice for what you’ll have to do when you are developing C++ applications for real.
Making mistakes is a fundamental part of the learning process, and the exercises should provide you
with ample opportunity for that. It’s a good idea to dream up a few exercises of your own. If you are not
sure about how to do something, just have a go before looking it up. The more mistakes you make, the
greater the insight you’ll have into what can, and does, go wrong. Make sure you attempt all the exercises,
and remember, don’t look at the solutions until you’re sure that you can’t work them out yourself. Most of
these exercises just involve a direct application of what’s covered in a chapter—they’re just practice, in other
words—but some also require a bit of thought or maybe even inspiration.
We wish you every success with C++. Above all, enjoy it!
Ivor Horton
Peter Van Weert

xxviii

CHAPTER 1

Basic Ideas
In this book we sometimes will use certain code in the examples before having explained it in detail. This
chapter is intended to help you when this occurs by giving presenting an overview of the major elements of
C++ and how they hang together. We’ll also explain a few concepts relating to the representation of numbers
and characters in your computer.
In this chapter, you’ll learn:
•

What is meant by modern C++

•

What the terms C++11, C++14, and C++17 mean

•

What the C++ Standard Library is

•

What are the elements of a C++ program

•

How to document your program code

•

How your C++ code becomes an executable program

•

How object-oriented programming differs from procedural programming

•

What binary, hexadecimal, and octal number systems are

•

What floating-point numbers are

•

How a computer represents numbers using nothing but bits and bytes

•

What Unicode is

Modern C++
The C++ programming language was originally developed in the early 1980s by Danish computer scientist
Bjarne Stroustrup. That makes C++ one of the older programming languages still in active use—very old, in
fact, in the fast-paced world of computer programming. Despite its age, though, C++ is still standing strong,
steadily maintaining its top-five position in most popularity rankings for programming languages. There’s no
doubt whatsoever that C++ still is one of the most widely used and most powerful programming language in
the world today.
Just about any kind of program can be written in C++, from device drivers to operating systems and
from payroll and administrative programs to games. Major operating systems, browsers, office suites,
email clients, multimedia players, database systems—name one and chances are it’s written at least partly
in C++. Above all else, C++ is perhaps best suited for applications where performance matters, such as
applications that have to process large amounts of data, modern games with high-end graphics, or apps that
target embedded or mobile devices. Programs written in C++ are still easily many times faster than those

© Ivor Horton and Peter Van Weert 2018
I. Horton and P. Van Weert, Beginning C++17, https://doi.org/10.1007/978-1-4842-3366-5_1

1

Chapter 1 ■ Basic Ideas

written in other popular languages. Also, C++ is far more effective than most other languages for developing
applications across an enormous range of computing devices and environments, including for personal
computers, workstations, mainframe computers, tablets, and mobile phones.
The C++ programming language may be old, but it’s still very much alive and kicking. Or, better yet:
it’s again very much alive and kicking. After its initial development and standardization in the 1980s, C++
evolved slowly—until 2011, that is, when the International Organization for Standardization (ISO) released
a new version of the standard that formally defines the C++ programming language. This edition of the
standard, commonly referred to as C++11, revived C++ and catapulted the somewhat dated language right
back into the 21st century. It modernized the language and the way we use it so profoundly that you could
almost call C++11 a completely new language.
Programming using the features of C++11 and beyond is referred to as modern C++. In this book, we’ll
show you that modern C++ is about more than simply embracing the language’s new features—lambda
expressions, auto type deduction, and range-based for loops, to name a few. More than anything else,
modern C++ is about modern ways of programming, the consensus of what constitutes good programming
style. It’s about applying an implicit set of guidelines and best practices, all designed to make C++
programming easier, less error-prone, and more productive. A modern, safe C++ programming style replaces
traditional low-level language constructs with the use of containers (Chapters 5 and 19), smart pointers
(Chapter 6), or other RAII techniques (Chapter 15), and it emphasizes exceptions to report errors (Chapter 15),
passing objects by value through move semantics (Chapter 17), writing algorithms instead of loops
(Chapter 19), and so on. Of course, all this probably means little to nothing to you yet. But not to worry: in
this book, we’ll gradually introduce everything you need to know to program in C++ today!
The C++11 standard appears to have revived the C++ community, which has been actively working hard
on extending and further improving the language ever since. Every three years, a new version of the standard
is published. In 2014, the C++14 standard was finalized, and in 2017 the C++17 edition. This book relates to
C++ as defined by C++17. All code should work on any compiler that complies with the C++17 edition of the
standard. The good news is that most major compilers have been keeping up with the latest developments,
so if your compiler does not support a particular feature yet, it soon will.

Standard Libraries
If you had to create everything from scratch every time you wrote a program, it would be tedious indeed.
The same functionality is required in many programs—reading data from the keyboard, calculating a square
root, and sorting data records into a particular sequence are examples. C++ comes with a large amount of
prewritten code that provides facilities such as these so you don’t have to write the code yourself. All this
standard code is defined in the Standard Library.
The Standard Library is a huge collection of routines and definitions that provide functionality that is
required by many programs. Examples are numerical calculations, string processing, sorting and searching,
organizing and managing data, and input and output. We’ll introduce major Standard Library functionalities
in virtually every chapter and will later zoom in a bit more specifically on some key data structures and
algorithms in Chapter 19. Nevertheless, the Standard Library is so vast that we will only scratch the surface
of what is available in this book. It really needs several books to fully elaborate all the capabilities it provides.
Beginning STL (Apress, 2015) is a companion book that is a tutorial on using the Standard Template Library,
which is the subset of the C++ Standard Library for managing and processing data in various ways. For a
compact yet complete overview of everything the modern Standard Library has to offer, we also recommend
the book C++ Standard Library Quick Reference (Apress, 2016).
Given the scope of the language and the extent of the library, it’s not unusual for a beginner to find C++
somewhat daunting. It is too extensive to learn in its entirety from a single book. However, you don’t need
to learn all of C++ to be able to write substantial programs. You can approach the language step-by-step, in
which case it really isn’t difficult. An analogy might be learning to drive a car. You can certainly become a
competent and safe driver without necessarily having the expertise, knowledge, and experience to drive in

2

Chapter 1 ■ Basic Ideas

the Indianapolis 500. With this book you can learn everything you need to program effectively in C++. By the
time you reach the end, you’ll be confidently writing your own applications. You’ll also be well equipped to
explore the full extent of C++ and its Standard Library.

C++ Program Concepts
There will be much more detail on everything we discuss in this section later in the book. We’ll jump straight
in with the complete, fully working C++ program shown in Figure 1-1, which also explains what the various
bits are. We’ll use the example as a base for discussing some more general aspects of C++.

This is a statement.
Statements end with a semicolon.
There is also a comment on this line.

// Ex1_01.cpp
// A complete C++ program

Single-line comments begin with //.

#include <iostream>

This line adds input/output capability.

int main()
{

This is the first line of the function main.

int answer {42};

// Defines answer with value 42

std::cout << "The answer to life, the universe, and everything is "
<< answer
<< std::endl;

All the code in a
function is enclosed
between braces.

return 0;
}
This statement ends the function main.

This statement is spread over three lines.

Figure 1-1. A complete C++ program

Source Files and Header Files
The file depicted in Figure 1-1, Ex1_01.cpp, is in the code download for the book. The file extension, .cpp,
indicates that this is a C++ source file. Source files contain functions and thus all the executable code in a
program. The names of source files usually have the extension .cpp, although other extensions such as
.cc, .cxx, or .c++ are sometimes used to identify a C++ source file.
C++ code is actually stored in two kinds of files. Next to source files, there’re also so-called header files.
Header files contain, among other things, function prototypes and definitions for classes and templates
that are used by the executable code in a .cpp file. The names of header files usually have the extension .h,
although other extensions such as .hpp are also used. You’ll create your first very own header files in
Chapter 10; until then all your programs will be small enough to be defined in a single source file.

3

Chapter 1 ■ Basic Ideas

Comments and Whitespace
The first two lines in Figure 1-1 are comments. You add comments that document your program code to
make it easier to understand how it works. The compiler ignores everything that follows two successive
forward slashes on a line, so this kind of comment can follow code on a line. In our example, the first line is
a comment that indicates the name of the file containing this code. We'll identify the file for each working
example in the same way.

■■Note The comment with the file name in each header or source file is only there for your convenience.
In normal coding there is no need to add such comments; it only introduces an unnecessary maintenance
overhead when renaming files.
There’s another form of comment that you can use when you need to spread a comment over several
lines. Here’s an example:
/* This comment is
   over two lines.  */
Everything between /* and */ will be ignored by the compiler. You can embellish this sort of comment
to make it stand out. For instance:
/********************\
* This comment is  *
* over two lines.  *
\********************/
Whitespace is any sequence of spaces, tabs, newlines, or form feed characters. Whitespace is generally
ignored by the compiler, except when it is necessary for syntactic reasons to distinguish one element from
another.

Preprocessing Directives and Standard Library Headers
The third line in Figure 1-1 is a preprocessing directive. Preprocessing directives cause the source code to
be modified in some way before it is compiled to executable form. This preprocessing directive adds the
contents of the Standard Library header file with the name iostream to this source file, Ex1_01.cpp. The
header file contents are inserted in place of the #include directive.
Header files, which are sometimes referred to just as headers, contain definitions to be used in a source
file. iostream contains definitions that are needed to perform input from the keyboard and text output to
the screen using Standard Library routines. In particular, it defines std::cout and std::endl among many
other things. If the preprocessing directive to include the iostream header was omitted from Ex1_01.cpp,
the source file wouldn’t compile because the compiler would not know what std::cout or std::endl is. The
contents of header files are included into a source file before it is compiled. You’ll be including the contents
of one or more Standard Library header files into nearly every program, and you’ll also be creating and using
your own header files that contain definitions that you construct later in the book.

4

Chapter 1 ■ Basic Ideas

■■Caution There are no spaces between the angle brackets and the standard header file name. With some
compilers, spaces are significant between the angle brackets, < and >; if you insert spaces here, the program
may not compile.

Functions
Every C++ program consists of at least one and usually many more functions. A function is a named block of
code that carries out a well-defined operation such as “read the input data” or “calculate the average value”
or “output the results.” You execute, or call, a function in a program using its name. All the executable code in
a program appears within functions. There must be one function with the name main, and execution always
starts automatically with this function. The main() function usually calls other functions, which in turn can
call other functions, and so on. Functions provide several important advantages:
•

A program that is broken down into discrete functions is easier to develop and test.

•

You can reuse a function in several different places in a program, which makes the
program smaller than if you coded the operation in each place that it is needed.

•

You can often reuse a function in many different programs, thus saving time and
effort.

•

Large programs are typically developed by a team of programmers. Each team
member is responsible for programming a set of functions that are a well-defined
subset of the whole program. Without a functional structure, this would be
impractical.

The program in Figure 1-1 consists of just the function main(). The first line of the function is as follows:
int main()
This is called the function header, which identifies the function. Here, int is a type name that defines
the type of value that the main() function returns when it finishes execution—an integer. An integer is a
number without a fractional component; that is, 23 and -2048 are integers, while 3.1415 and ¼ are not. In
general, the parentheses following a name in a function definition enclose the specification for information
to be passed to the function when you call it. There’s nothing between the parentheses in this instance,
but there could be. You’ll learn how you specify the type of information to be passed to a function when it
is executed in Chapter 8. We’ll always put parentheses after a function name in the text—like we did with
main()—to distinguish it from other things that are code.
The executable code for a function is always enclosed between curly braces. The opening brace follows
the function header.

Statements
A statement is a basic unit in a C++ program. A statement always ends with a semicolon, and it’s the
semicolon that marks the end of a statement, not the end of the line. A statement defines something, such as
a computation, or an action that is to be performed. Everything a program does is specified by statements.
Statements are executed in sequence until there is a statement that causes the sequence to be altered. You’ll
learn about statements that can change the execution sequence in Chapter 4. There are three statements in

5

Chapter 1 ■ Basic Ideas

main() in Figure 1-1. The first defines a variable, which is a named bit of memory for storing data of some
kind. In this case, the variable has the name answer and can store integer values:
int answer {42};                       // Defines answer with the value 42
The type, int, appears first, preceding the name. This specifies the kind of data that can be
stored—integers. Note the space between int and answer. One or more whitespace characters is essential
here to separate the type name from the variable name; without the space, the compiler would see the name
intanswer, which it would not understand. An initial value for answer appears between the braces following
the variable name, so it starts out storing 42. There’s a space between answer and {42}, but it’s not essential.
Any of the following definitions are valid as well:
int one{ 1 };
int two{2};
int three{
   3
};
The compiler mostly ignores superfluous whitespace. However, you should use whitespace in a
consistent fashion to make your code more readable.
There’s a somewhat redundant comment at the end of the first statement explaining what we just
described, but it does demonstrate that you can add a comment to a statement. The whitespace preceding
the // is also not mandatory, but it is desirable.
You can enclose several statements between a pair of curly braces, { }, in which case they’re referred
to as a statement block. The body of a function is an example of a block, as you saw in Figure 1-1 where the
statements in the main() function appear between curly braces. A statement block is also referred to as a
compound statement because in most circumstances it can be considered as a single statement, as you’ll see
when we look at decision-making capabilities in Chapter 4, and loops in Chapter 5. Wherever you can put a
single statement, you can equally well put a block of statements between braces. As a consequence, blocks
can be placed inside other blocks—this concept is called nesting. Blocks can be nested, one within another,
to any depth.

Data Input and Output
Input and output are performed using streams in C++. To output something, you write it to an output stream,
and to input data, you read it from an input stream. A stream is an abstract representation of a source of data or
a data sink. When your program executes, each stream is tied to a specific device that is the source of data in the
case of an input stream and the destination for data in the case of an output stream. The advantage of having
an abstract representation of a source or sink for data is that the programming is then the same regardless
of the device the stream represents. You can read a disk file in essentially the same way as you read from the
keyboard. The standard output and input streams in C++ are called cout and cin, respectively, and by default
they correspond to your computer’s screen and keyboard. You’ll be reading input from cin in Chapter 2.
The next statement in main() in Figure 1-1 outputs text to the screen:
std::cout << "The answer to life, the universe, and everything is "
          << answer
          << std::endl;
The statement is spread over three lines, just to show that it’s possible. The names cout and endl are
defined in the iostream header file. We’ll explain about the std:: prefix a little later in this chapter. << is
the insertion operator that transfers data to a stream. In Chapter 2 you’ll meet the extraction operator, >>,

6

Chapter 1 ■ Basic Ideas

that reads data from a stream. Whatever appears to the right of each << is transferred to cout. Inserting endl
to std::cout causes a new line to be written to the stream and the output buffer to be flushed. Flushing
the output buffer ensures that the output appears immediately. The statement will produce the following
output:
The answer to life, the universe, and everything is 42
You can add comments to each line of a statement. Here’s an example:
std::cout << "The answer to life, the universe, and everything is "  // This statement
          << answer                                                  // occupies
          << std::endl;                                              // three lines
You don’t have to align the double slashes, but it’s common to do so because it looks tidier and makes
the code easier to read. Of course, you should not start writing comments just to write them. A comment
normally contains useful information that is not immediately obvious from the code.

return Statements
The last statement in main() is a return statement. A return statement ends a function and returns control
to where the function was called. In this case, it ends the function and returns control to the operating
system. A return statement may or may not return a value. This particular return statement returns 0 to the
operating system. Returning 0 to the operating system indicates that the program ended normally. You can
return nonzero values such as 1, 2, etc., to indicate different abnormal end conditions. The return statement
in Ex1_01.cpp is optional, so you could omit it. This is because if execution runs past the last statement in
main(), it is equivalent to executing return 0.

■■Note main() is the only function for which omitting return is equivalent to returning zero. Any other
function with return type int always has to end with an explicit return statement—the compiler shall never
presume to know which value an arbitrary function should return by default.

Namespaces
A large project will involve several programmers working concurrently. This potentially creates a problem
with names. The same name might be used by different programmers for different things, which could
at least cause some confusion and may cause things to go wrong. The Standard Library defines a lot of
names, more than you can possibly remember. Accidental use of Standard Library names could also cause
problems. Namespaces are designed to overcome this difficulty.
A namespace is a sort of family name that prefixes all the names declared within the namespace. The
names in the Standard Library are all defined within a namespace that has the name std. cout and endl
are names from the Standard Library, so the full names are std::cout and std::endl. Those two colons
together, ::, have a fancy title: the scope resolution operator. We’ll have more to say about it later. Here, it
serves to separate the namespace name, std, from the names in the Standard Library such as cout and endl.
Almost all names from the Standard Library are prefixed with std.

7

Chapter 1 ■ Basic Ideas

The code for a namespace looks like this:
namespace my_space {
  // All names declared in here need to be prefixed
  // with my_space when they are reference from outside.
  // For example, a min() function defined in here
  // would be referred to outside this namespace as my_space::min()
}
Everything between the braces is within the my_space namespace. You’ll find out more about defining
your own namespaces in Chapter 10.

■■Caution The main() function must not be defined within a namespace. Things that are not defined in a
namespace exist in the global namespace, which has no name.

Names and Keywords
Ex1_01.cpp contains a definition for a variable with the name answer, and it uses the names cout and endl
that are defined in the iostream Standard Library header. Lots of things need names in a program, and there
are precise rules for defining names:
•

A name can be any sequence of upper or lowercase letters A to Z or a to z, the digits
0 to 9, and the underscore character, _.

•

A name must begin with either a letter or an underscore.

•

Names are case sensitive.

The C++ standard allows names to be of any length, but typically a particular compiler will impose
some sort of limit. However, this is normally sufficiently large that it doesn’t represent a serious constraint.
Most of the time you won’t need to use names of more than 12 to 15 characters.
Here are some valid C++ names:
toe_count   shoeSize   Box   democrat   Democrat   number1   x2   y2   pValue   out_of_range
Uppercase and lowercase are differentiated, so democrat is not the same name as Democrat. You can see
a couple examples of conventions for writing names that consist of two or more words; you can capitalize
the second and subsequent words or just separate them with underscores.
Keywords are reserved words that have a specific meaning in C++, so you must not use them for
other purposes. class, double, throw, and catch are examples of keywords. Other names that you are not
supposed to use include the following:

8

•

Names that begin with two consecutive underscores

•

Names that begin with an underscore followed by an uppercase letter

•

Within the global namespace: all names that begin with an underscore

Chapter 1 ■ Basic Ideas

While compilers often won’t really complain if you use these, the problem is that such names might
clash either with those that are generated by the compiler or with names that are used internally by your
Standard Library implementation. Notice that the common denominator with these reserved names is that
they all start with an underscore. Thus, our advice is this:

■■Tip

Do not use names that start with an underscore.

Classes and Objects
A class is a block of code that defines a data type. A class has a name that is the name for the type. An item of
data of a class type is referred to as an object. You use the class type name when you create variables that can
store objects of your data type. Being able to define your own data types enables you to specify a solution to
a problem in terms of the problem. If you were writing a program processing information about students,
for example, you could define a Student type. Your Student type could incorporate all the characteristic of a
student—such as age, gender, or school record—that was required by the program.
You will learn all about creating your own classes and programming with objects in Chapters 11
through 14. Nevertheless, you’ll be using objects of specific Standard Library types long before that.
Examples include vectors in Chapter 5 and strings in Chapter 7. Even the std::cout and std::cin streams
are technically objects. But not to worry: you’ll find that working with objects is easy enough, much easier
than creating your own classes, for instance. Objects are mostly intuitive in use because they’re mostly
designed to behave like real-life entities (although some do model more abstract concepts, such as input or
output streams, or low-level C++ constructs, such as data arrays and character sequences).

Templates
You sometimes need several similar classes or functions in a program where the code differs only in the
kind of data that is processed. A template is a recipe that you create to be used by the compiler to generate
code automatically for a class or function customized for a particular type or types. The compiler uses a class
template to generate one or more of a family of classes. It uses a function template to generate functions.
Each template has a name that you use when you want the compiler to create an instance of it. The Standard
Library uses templates extensively.
Defining function templates is the subject of Chapter 9, and defining class templates is covered in
Chapter 16. But, again, you’ll be using some concrete Standard Library templates throughout earlier
chapters, such as instantiations of the container class templates in Chapter 5 or certain elementary utility
function templates such as std::min() and max().

Code Appearance and Programming Style
The way in which you arrange your code can have a significant effect on how easy it is to understand. There
are two basic aspects to this. First, you can use tabs and/or spaces to indent program statements in a manner
that provides visual cues to their logic, and you can arrange matching braces that define program blocks in
a consistent way so that the relationships between the blocks are apparent. Second, you can spread a single
statement over two or more lines when that will improve the readability of your program.

9

Chapter 1 ■ Basic Ideas

There are many different styles for code. The following table shows three of many possible options for
how a code sample could be arranged:

Style 1

Style 2

Style 3

namespace mine
{
bool has_factor(int x, int y)
{
int factor{ hcf(x, y) };
if (factor > 1)
{
return true;
}
else
{
return false;
}
}
}

namespace mine {
bool has_factor(int x, int y)
{
int factor{ hcf(x,y) };
if (factor>1) {
return true;
} else {
return false;
}
}
}

namespace mine {
bool has_factor(int x, int y) {
int factor{ hcf(x, y) };
if (factor > 1)
return true;
else
return false;
}
}

We will use Style 1 for examples in the book. Over time, you will surely develop your own, based either
on personal preferences or on company policies. It is recommended to, at some point, pick one style that
suits you and then use this consistently throughout your code. Not only does a consistent code presentation
style look good, but it also makes your code easier to read.
A particular convention for arranging matching braces and indenting statements is only one of
several aspects of one’s programming style. Other important aspects include conventions for naming
variables, types, and functions, and the use of (structured) comments. The question of what constitutes a
good programming style can be highly subjective at times, though some guidelines and conventions are
objectively superior. The general idea, though, is that code that conforms to a consistent style is easier to
read and understand, which helps to avoid introducing errors. Throughout the book we’ll regularly give you
advice as you fashion your own programming style.

■■Tip One of the best tips we can give you regarding good programming style is no doubt to choose clear,
descriptive names for all your variables, functions, and types.

Creating an Executable
Creating an executable module from your C++ source code is basically a three-step process. In the first step,
the preprocessor processes all preprocessing directives. One of its key tasks is to, at least in principle, copy the
entire contents of all #included headers into your .cpp files. Other preprocessing directives are discussed in
Chapter 10. In the second step, your compiler processes each .cpp file to produce an object file that contains
the machine code equivalent of the source file. In the third step, the linker combines the object files for a
program into a file containing the complete executable program.
Figure 1-2 shows three source files being compiled to produce three corresponding object files
(the preprocessing stage is not shown explicitly). The filename extension that’s used to identify object
files varies between different machine environments, so it isn’t shown here. The source files that make
up your program may be compiled independently in separate compiler runs, or most compilers will

10

Chapter 1 ■ Basic Ideas

allow you to compile them in a single run. Either way, the compiler treats each source file as a separate
entity and produces one object file for each .cpp file. The link step then combines the object files for a
program, along with any library functions that are necessary, into a single executable file.
The contents of header
files will be included
before compilation.

Source File
(.cpp File)

Source File
(.cpp File)

Source File
(.cpp File)

Each .cpp file will result in
one object file.

Compiler

Compiler

Compiler

Object File

(Machine Code)

The linker will combine all
the object files plus
necessary library routines
to produce the executable
file.

Library

Object File

(Machine Code)

Object File

(Machine Code)

Linker

Executable
(.exe File)

Figure 1-2. The compile and link process
In the first half of the book, your programs will consist of a single source file. In Chapter 10 we will show
you how to compose a larger program, consisting of multiple header and source files.

■■Note The concrete steps you have to follow to get from your source code to a functioning executable differ
from compiler to compiler. While most of our examples are small enough to compile and link through a series
of command-line instructions, it is probably easier to use a so-called integrated development environment (IDE)
instead. Modern IDEs offer a very user-friendly graphical user interface to edit, compile, link, run, and debug
your programs. References to the most popular compilers and IDEs as well as pointers on how to get started
are available from the Apress website (www.apress.com/book/download.html) together with the source code
of all examples and the solutions to all exercises.
In practice, compilation is an iterative process because you’re almost certain to have made
typographical and other errors in the code. Once you’ve eliminated these from each source file, you can
progress to the link step, where you may find that yet more errors surface. Even when the link step produces
an executable module, your program may still contain logical errors; that is, it doesn’t produce the results
you expect. To fix these, you must go back and modify the source code and try to compile it once more. You
continue this process until your program works as you think it should. As soon as you declare to the world
at large that your program works, someone will discover a number of obvious errors that you should have
found. It hasn’t been proven beyond doubt so far as we know, but it’s widely believed that any program
larger than a given size will always contain errors. It’s best not to dwell on this thought when flying….

11

Chapter 1 ■ Basic Ideas

Procedural and Object-Oriented Programming
Historically, procedural programming is the way almost all programs were written. To create a procedural
programming solution to a problem, you focus on the process that your program must implement to solve
the problem. Here is a rough outline of what you do, once the requirements have been defined precisely:
•

You create a clear, high-level definition of the overall process that your program will
implement.

•

You segment the overall process into workable units of computation that are, as
much as possible, self-contained. These will usually correspond to functions.

•

You code the functions in terms of processing basic types of data: numerical data,
single characters, and character strings.

Apart from the common requirement of starting out with a clear specification of what the problem is,
the object-oriented approach to solving the same problem is quite different:
•

From the problem specification, you determine what types of objects the problem
is concerned with. For example, if your program deals with baseball players, you’re
likely to identify BaseballPlayer as one of the types of data your program will work
with. If your program is an accounting package, you may well want to define objects
of type Account and type Transaction. You also identify the set of operations that
the program will need to carry out on each type of object. This will result in a set of
application-specific data types that you will use in writing your program.

•

You produce a detailed design for each of the new data types that your problem
requires, including the operations that can be carried out with each object type.

•

You express the logic of the program in terms of the new data types you’ve defined
and the kinds of operations they allow.

The program code for an object-oriented solution to a problem will be completely unlike that for a
procedural solution and almost certainly easier to understand. It will also be a lot easier to maintain. The
amount of design time required for an object-oriented solution tends to be greater than for a procedural
solution. However, the coding and testing phase of an object-oriented program tends to be shorter and less
troublesome, so the overall development time is likely to be roughly the same in either case.
To get an inkling of what an objected-oriented approach implies, suppose you’re implementing a
program that deals with boxes of various kinds. A feasible requirement of such a program would be to
package several smaller boxes inside another, larger box. In a procedural program, you would need to store
the length, width, and height of each box in a separate group of variables. The dimensions of a new box that
could contain several other boxes would need to be calculated explicitly in terms of the dimensions of each
of the contained boxes, according to whatever rules you had defined for packaging a set of boxes.
An object-oriented solution might involve first defining a Box data type. This would enable you to create
variables that can reference objects of type Box and, of course, create Box objects. You could then define an
operation that would add two Box objects together and produce a new Box object that could contain them.
Using this operation, you could write statements like this:
bigBox = box1 + box2 + box3;

12

Chapter 1 ■ Basic Ideas

In this context, the + operation means much more than simple addition. The + operator applied to
numerical values will work exactly as before, but for Box objects it has a special meaning. Each of the
variables in this statement is of type Box. The statement would create a new Box object big enough to contain
box1, box2, and box3.
Being able to write statements like this is clearly much easier than having to deal with all the box
dimensions separately, and the more complex the operations on boxes you take on, the greater the
advantage is going to be. This is a trivial illustration, though, and there’s a great deal more to the power
of objects than you can see here. The purpose of this discussion is just to give you an idea of how readily
problems solved using an object-oriented approach can be understood. Object-oriented programming is
essentially about solving problems in terms of the entities to which the problems relates rather than in terms
of the entities that computers are happy with: numbers and characters.

Representing Numbers
Numbers are represented in a variety of ways in a C++ program, and you need to have an understanding
of the possibilities. If you are comfortable with binary, hexadecimal, and floating-point number
representations, you can safely skip this bit.

Binary Numbers
First, let’s consider exactly what a common, everyday decimal number, such as 324 or 911, means.
Obviously, what we mean here is “three hundred and twenty-four” or “nine hundred and eleven.” These are
shorthand ways of saying “three hundreds” plus “two tens” plus “four,” as well as “nine hundred” plus “one
ten” plus “one.” Putting this more precisely, we really mean this:
•

324 is 3 × 102 + 2 × 101 + 4 × 100, which is 3 × 100 + 2 × 10 + 4 × 1.

•

911 is 9 × 102 + 1 × 101 + 1 × 100, which is 9 × 100 + 1 × 10 + 1 × 1.

This is called decimal notation because it’s built around powers of 10. We also say that we are
representing numbers to base 10 here because each digit position is a power of 10. Representing numbers in
this way is handy for beings with ten fingers and/or ten toes, or indeed ten of any kind of appendage that can
be used for counting. Your PC is rather less handy, being built mainly of switches that are either on or off.
Your PC is OK for counting in twos but not spectacular at counting in tens. You’re probably aware that this is
why your computer represents numbers using base 2, rather than base 10. Representing numbers using
base 2 is called the binary system of counting. Numbers in base 10 have digits that can be from 0 to 9. In
general, for numbers in an arbitrary base, n, the digit in each position in a number can be from 0 to n-1.
Thus, binary digits can be only 0 or 1. A binary number such as 1101 breaks down like this:
•

1 × 23 + 1 × 22 + 0 × 21 + 1 × 20, which is 1 × 8 + 1 × 4 + 0 × 2 + 1 × 1

This is 13 in the decimal system. In Table 1-1, you can see the decimal equivalents of all the numbers
you can represent using eight binary digits. A binary digit is more commonly known as a bit.

13

Chapter 1 ■ Basic Ideas

Table 1-1. Decimal Equivalents of 8-Bit Binary Values

Binary

Decimal

Binary

Decimal

0000 0000

0

1000 0000

128

0000 0001

1

1000 0001

129

0000 0010

2

1000 0010

130

...

...

...

...

0001 0000

16

1001 0000

144

0001 0001

17

1001 0001

145

...

...

...

...

0111 1100

124

1111 1100

252

0111 1101

125

1111 1101

253

0111 1110

126

1111 1110

254

0111 1111

127

1111 1111

255

Using the first seven bits, you can represent positive numbers from 0 to 127, which is a total of 128
different numbers. Using all eight bits, you get 256, or 28, numbers. In general, if you have n bits available,
you can represent 2n integers, with positive values from 0 to 2n – 1.
Adding binary numbers inside your computer is a piece of cake because the “carry” from adding
corresponding digits can be only 0 or 1. This means that very simple—and thus excruciatingly fast—circuitry
can handle the process. Figure 1-3 shows how the addition of two 8-bit binary values would work.

+

Binary

Decimal

0001 1101
0010 1011

29
+ 43

0100 1000

72

carries

Figure 1-3. Adding binary values
The addition operation adds corresponding bits in the operands, starting with the rightmost. Figure 1-3
shows that there is a “carry” of 1 to the next bit position for each of the first six bit positions. This is because
each digit can be only 0 or 1. When you add 1 + 1, the result cannot be stored in the current bit position and
is equivalent to adding 1 in the next bit position to the left.

Hexadecimal Numbers
When you are dealing with larger binary numbers, a small problem arises with writing them. Look at this:
•

1111 0101 1011 1001 1110 0001

Binary notation here starts to be more than a little cumbersome for practical use, particularly when you
consider that this in decimal is only 16,103,905—a miserable eight decimal digits. You can sit more angels on
the head of a pin than that! Clearly you need a more economical way of writing this, but decimal isn’t always

14

Chapter 1 ■ Basic Ideas

appropriate. You might want to specify that the 10th and 24th bits from the right in a number are 1, for example.
Figuring out the decimal integer for this is hard work, and there’s a good chance you’ll get it wrong anyway. An
easier solution is to use hexadecimal notation, in which the numbers are represented using base 16.
Arithmetic to base 16 is a much more convenient option, and it fits rather well with binary. Each
hexadecimal digit can have values from 0 to 15 and the digits from 10 to 15 are represented by the letters A to
F (or a to f), as shown in Table 1-2. Values from 0 to 15 happen to correspond nicely with the range of values
that four binary digits can represent.
Table 1-2. Hexadecimal Digits and Their Values in Decimal and Binary

Hexadecimal

Decimal

Binary

0

0

0000

1

1

0001

2

2

0010

3

3

0011

4

4

0100

5

5

0101

6

6

0110

7

7

0111

8

8

1000

9

9

1001

A or a

10

1010

B or b

11

1011

C or c

12

1100

D or d

13

1101

E or e

14

1110

F or f

15

1111

Because a hexadecimal digit corresponds to four binary digits, you can represent any binary number in
hexadecimal simply by taking groups of four binary digits starting from the right and writing the equivalent
hexadecimal digit for each group. Look at the following binary number:
•

1111 0101 1011 1001 1110 0001

Taking each group of four bits and replacing it with the corresponding hexadecimal digit from the table
produces the following:
•

F      5      B      9      E      1

You have six hexadecimal digits corresponding to the six groups of four binary digits. Just to prove that it
all works out with no cheating, you can convert this number directly from hexadecimal to decimal by again
using the analogy with the meaning of a decimal number. The value of this hexadecimal number therefore
works out as follows: F5B9E1 as a decimal value is given by the following:
•

15 × 165 + 5 × 164 + 11 × 163 + 9 × 162 + 14 × 161 + 1 × 160

15

Chapter 1 ■ Basic Ideas

Thankfully, this adds up to the same number you got when converting the equivalent binary number to
a decimal value: 16,103,905. In C++, hexadecimal values are written with 0x or 0X as a prefix, so in code the
value would be written as 0xF5B9E1. Obviously, this means that 99 is not at all the same as 0x99.
The other handy coincidence with hexadecimal numbers is that modern computers store integers in
words that are an even number of bytes, typically 2, 4, 8, or 16 so-called bytes. A byte is 8 bits, which is exactly
two hexadecimal digits, so any binary integer word in memory always corresponds to an exact number of
hexadecimal digits.

Negative Binary Numbers
There’s another aspect to binary arithmetic that you need to understand: negative numbers. So far, we’ve
assumed that everything is positive—the optimist’s view—and so the glass is still half-full. But you can’t
avoid the negative side of life—the pessimist’s perspective—that the glass is already half-empty. But how is
a negative number represented in a modern computer? You’ll see shortly that the answer to this seemingly
easy question is actually far from obvious….
Integers that can be both positive and negative are referred to as signed integers. Naturally, you only
have binary digits at your disposal to represent numbers. At the end of the day, any language your computer
speaks shall consist solely of bits and bytes. As you know, your computer’s memory is generally composed
of 8-bit bytes, so all binary numbers are going to be stored in some multiple (usually a power of 2) of 8 bits.
Thus, you can also only have signed integers with 8 bits, 16 bits, 32 bits, or whatever.
A straightforward representation of signed integers therefore consists of a fixed number of binary digits,
where one of these bits is designated as a so-called sign bit. In practice, the sign bit is always chosen to be the
leftmost bit. Say we fix the size of all our signed integers to 8 bits; then the number 6 could be represented
as 00000110, and -6 could be represented as 10000110. Changing +6 to –6 just involves flipping the sign bit
from 0 to 1. This is called a signed magnitude representation: each number consists of a sign bit that is 0 for
positive values and 1 for negative values, plus a given number of other bits that specify the magnitude or
absolute value of the number (the value without the sign in other words).
While signed magnitude representations are easy to work with for humans, they have one unfortunate
downside: they are not at all easy to work with for computers! More specifically, they carry a lot of overhead
in terms of the complexity of the circuits that are needed to perform arithmetic. When two signed integers
are added, for instance, you don’t want the computer to be messing about, checking whether either or both
of the numbers are negative. What you really want is to use the same simple and very fast “add” circuitry
regardless of the signs of the operands.
Let’s see what happens when we naively add together the signed magnitude representations of 12 and -8.
You almost know in advance that it won’t work, but we’ll carry on regardless:
12 in binary is

00001100

–8 in binary (you suppose) is

10001000

If you now “add” these together, you get

10010100

This seems to give –20, which of course isn’t what you wanted at all. It’s definitely not +4, which you
know is 00000100. “Ah,” we hear you say, “you can’t treat a sign just like another digit.” But that is just what
you do want to do to speed up binary computations!
Virtually all modern computers therefore take a different approach: they use the so-called 2’s
complement representation of negative binary numbers. With this representation, you can produce the
negative of any positive binary number by a simple procedure that you can perform in your head. At this
point, we need to ask you to have a little faith because we’ll avoid getting into explanations of why it works.

16

Chapter 1 ■ Basic Ideas

Like a true magician, we won’t explain our magic. We’ll show you how you can create the 2’s complement
form of a negative number from a positive value, and you can prove to yourself that it does work. For this,
let’s return to the previous example, in which you need the 2’s complement representation of –8:
1.

You start with +8 in binary: 00001000.

2.

You then “flip” each binary digit, changing 0s to 1s, and vice versa: 11110111.
This is called the 1’s complement form.

3.

If you now add 1 to this, you get the 2’s complement form of -8: 11111000.

Note that this works both ways. To convert the 2’s complement representation of a negative number
back into the corresponding positive binary number, you again flip all bits and add one. For our example,
flipping 11111000 gives 00000111, adding one to this gives 00001000, or +8 in decimal. Magic!
But of course, the proof of the pudding is in the eating. The 2’s complement representation would
just be a fun parlor trick if it didn’t facilitate binary arithmetic. So, let’s see how 11111000 fares with your
computer’s elementary add circuitry:
+12 in binary is

00001100

The 2’s complement representation of –8 is

11111000

If you add these together, you get

00000100

The answer is 4—it works! The “carry” propagates through all the leftmost 1s, setting them back to 0.
One fell off the end, but you shouldn’t worry about that—it’s probably compensating for the one you
borrowed from the end in the subtraction you did to get –8. In fact, what’s happening is that you’re implicitly
assuming that the sign bit, 1 or 0, repeats forever to the left. Try a few examples of your own; you’ll find it
always works, like magic. The great thing about the 2’s complement representation of negative numbers is
that it makes arithmetic—and not just addition, by the way—very easy for your computer. And that accounts
for one of the reasons computers are so good at crunching numbers.

Octal Values
Octal integers are numbers expressed with base 8. Digits in an octal value can only be from 0 to 7. Octal is
used rarely these days. It was useful in the days when computer memory was measured in terms of 36-bit
words because you could specify a 36-bit binary value by 12 octal digits. Those days are long gone, so why
are we introducing it? The answer is the potential confusion it can cause. You can still write octal constants
in C++. Octal values are written with a leading zero, so while 76 is a decimal value, 076 is an octal value that
corresponds to 62 in decimal. So, here’s a golden rule:

■■Caution Never write decimal integers in your source code with a leading zero. You'll get a value different
from what you intended!

17

Chapter 1 ■ Basic Ideas

Bi-Endian and Little-Endian Systems
Integers are stored in memory as binary values in a contiguous sequence of bytes, commonly groups of 2, 4,
8, or 16 bytes. The question of the sequence in which the bytes appear can be important—it’s one of those
things that doesn’t matter until it matters, and then it really matters.
Let’s consider the decimal value 262,657 stored as a 4-byte binary value. We chose this value because in
binary each byte happens to have a pattern of bits that is easily distinguished from the others:
00000000 00000100 00000010 00000001
If you’re using a PC with an Intel processor, the number will be stored as follows:
Byte address:

00

01

02

03

Data bits:

00000001

00000010

00000100

00000000

As you can see, the most significant eight bits of the value—the one that’s all 0s—are stored in the byte
with the highest address (last, in other words), and the least significant eight bits are stored in the byte with
the lowest address, which is the leftmost byte. This arrangement is described as little-endian. Why on earth,
you wonder, would a computer reverse the order of these bytes? The motivation, as always, is rooted in the
fact that it allows for more efficient calculations and simpler hardware. The details don’t matter much; the
main thing is that you’re aware that most modern computers these days use this counterintuitive encoding.
Most, but not all computers, do, though. If you’re using a machine based on a Motorola processor, the
same data is likely to be arranged in memory in a more logical manner, like this:
Byte address:

00

01

02

03

Data bits:

00000000

00000100

00000010

00000001

Now the bytes are in reverse sequence with the most significant eight bits stored in the leftmost byte,
which is the one with the lowest address. This arrangement is described as bi-endian. Some processors
such as PowerPC and all recent ARM processors are bi-endian, which means that the byte order for data is
switchable between bi-endian and little-endian.

■■Note Regardless of whether the byte order is bi-endian or little-endian, the bits within each byte are
arranged with the most significant bit on the left and the least significant bit on the right.
This is all very interesting, you may say, but when does it matter? Most of the time, it doesn’t. More often
than not, you can happily write a program without knowing whether the computer on which the code will
execute is bi-endian or little-endian. It does matter, however, when you’re processing binary data that comes
from another machine. You need to know the endianness. Binary data is written to a file or transmitted over
a network as a sequence of bytes. It’s up to you how you interpret it. If the source of the data is a machine
with a different endianness from the machine on which your code is running, you must reverse the order of
the bytes in each binary value. If you don’t, you have garbage.
For those who collect curious background information, the terms bi-endian and little-endian are drawn
from the book Gulliver’s Travels by Jonathan Swift. In the story, the emperor of Lilliput commanded all his
subjects to always crack their eggs at the smaller end. This was a consequence of the emperor’s son having
cut his finger following the traditional approach of cracking his egg at the big end. Ordinary, law-abiding

18

Chapter 1 ■ Basic Ideas

Lilliputian subjects who cracked their eggs at the smaller end were described as Little Endians. The Big
Endians were a rebellious group of traditionalists in the Lilliputian kingdom who insisted on continuing to
crack their eggs at the big end. Many were put to death as a result.

Floating-Point Numbers
All integers are numbers, but of course not all numbers are integers: 3.1415 is no integer, and neither is
-0.00001. Many applications will have to deal with fractional numbers at one point or another. So clearly
you need a way to represent such numbers on your computer as well, complemented with the ability to
efficiently perform computations with them. The mechanism nearly all computers support for handling
fractional numbers, as you may have guessed from the section title, is called floating-point numbers.
Floating-point numbers do not just represent fractional numbers, though. As an added bonus, they
are able to deal with very large numbers as well. They allow you to represent, for instance, the number
of protons in the universe, which needs around 79 decimal digits (though of course not accurate within
one particle, but that’s OK—who has the time to count them all anyway?). Granted, the latter is perhaps
somewhat extreme, but clearly there are situations in which you’ll need more than the ten decimal digits you
get from a 32-bit binary integer, or even more than the 19 you can get from a 64-bit integer. Equally, there are
lots of very small numbers, for example, the amount of time in minutes it takes the typical car salesperson to
accept your generous offer on a 2001 Honda (and it’s covered only 480,000 miles…). Floating-point numbers
are a mechanism that can represent both these classes of numbers quite effectively.
We’ll first explain the basic principles using decimal floating-point numbers. Of course, your computer
will again use a binary representation instead, but things are just so much easier to understand for us
humans when we use decimal numbers. A so-called normalized number consists of two parts: a mantissa
or fraction and an exponent. Both can be either positive or negative. The magnitude of the number is the
mantissa multiplied by 10 to the power of the exponent. In analogy with the binary floating-point number
representations of your computer, we’ll moreover fix the number of decimal digits of both the mantissa and
the exponent.
It’s easier to demonstrate this than to describe it, so let’s look at some examples. The number 365 could
be written in a floating-point form, as follows:
3.650000E02
The mantissa here has seven decimal digits, the exponent two. The E stands for “exponent” and precedes
the power of 10 that the 3.650000 (the mantissa) part is multiplied by to get the required value. That is, to get
back to the regular decimal notation, you simply have to compute the following product: 3.650000 × 102.
This is clearly 365.
Now let’s look at a small number:
-3.650000E-03
This is evaluated as -3.65 × 10-3, which is -0.00365. They’re called floating-point numbers for the fairly
obvious reason that the decimal point “floats” and its position depends on the exponent value.
Now suppose you have a larger number such as 2,134,311,179. Using the same amount of digits, this
number looks like this:
2.134311E09
It’s not quite the same. You’ve lost three low-order digits, and you’ve approximated your original value
as 2,134,311,000. This is the price to pay for being able to handle such a vast range of numbers: not all these
numbers can be represented with full precision; floating-point numbers in general are only approximate
representations of the exact number.

19

Chapter 1 ■ Basic Ideas

Aside from the fixed-precision limitation in terms of accuracy, there’s another aspect you may need to
be conscious of. You need to take great care when adding or subtracting numbers of significantly different
magnitudes. A simple example will demonstrate the problem. Consider adding 1.23E-4 to 3.65E+6. The
exact result, of course, is 3,650,000 + 0.000123, or 3,650,000.000123. But when converted to floating-point
with seven digits of precision, this becomes the following:
3.650000E+06 + 1.230000E-04 = 3.650000E+06
Adding the latter, smaller number to the former has had no effect whatsoever, so you might as well not
have bothered. The problem lies directly with the fact that you carry only seven digits of precision. The digits
of the larger number aren’t affected by any of the digits of the smaller number because they’re all further to
the right.
Funnily enough, you must also take care when the numbers are nearly equal. If you compute the
difference between such numbers, most numbers may cancel each other out, and you may end up with a
result that has only one or two digits of precision. This is referred to as catastrophic cancellation, and it’s
quite easy in such circumstances to end up computing with numbers that are totally garbage.
While floating-point numbers enable you to carry out calculations that would be impossible without
them, you must always keep their limitations in mind if you want to be sure your results are valid. This
means considering the range of values that you are likely to be working with and their relative values. The
field that deals with analyzing and maximizing the precision—or numerical stability—of mathematical
computations and algorithms is called numerical analysis. This is an advanced topic, though, and well
outside the scope of this book. Suffice to say that the precision of floating-point numbers is limited and that
the order and nature of arithmetic operations you perform with them can have a significant impact on the
accuracy of your results.
Your computer, of course, again does not work with decimal numbers; rather, it works with binary
floating-point representations. Bits and bytes, remember? Concretely, nearly all computers today use
the encoding and computation rules specified by the IEEE 754 standard. Left to right, each floating-point
number then consists of a single sign bit, followed by a fixed number of bits for the exponent, and finally
another series of bits that encode the mantissa. The most common floating-point numbers representations
are the so-called single precision (1 sign bit, 8 bits for the exponent, and 23 for the mantissa, adding up to 32
bits in total) and double precision (1 + 11 + 52 = 64 bits) floating-point numbers.
Floating-point numbers can represent huge ranges of numbers. A single-precision floating-point
number, for instance, can already represent numbers ranging from 10-38 to 10+38. Of course, there’s a price
to pay for this flexibility: the number of digits of precision is limited. You know this already from before,
and it’s also only logical; of course not all 38 digits of all numbers in the order of 10+38 can be represented
exactly using 32 bits. After all, the largest signed integer a 32-bit binary integer can represent exactly is only
231 - 1, which is about 2 × 10+9. The number of decimal digits of precision in a floating-point number depends
on how much memory is allocated for its mantissa. A single-precision floating-point value, for instance,
provides approximately seven decimal digits accuracy. We say “approximately” because a binary fraction
with 23 bits doesn’t exactly correspond to a decimal fraction with seven decimal digits. A double-precision
floating-point value corresponds to around 16 decimal digits accuracy.

Representing Characters
Data inside your computer has no intrinsic meaning. Machine code instructions are just numbers: of course
numbers are just numbers, but so are, for instance, characters. Each character is assigned a unique integer
value called its code or code point. The value 42 can be the atomic number of molybdenum; the answer to
life, the universe, and everything; or an asterisk character. It all depends on how you choose to interpret it.
You can write a single character in C++ between single quotes, such as 'a' or '?' or '*', and the compiler
will generate the code value for these.

20

Chapter 1 ■ Basic Ideas

ASCII Codes
Way back in the 1960s, the American Standard Code for Information Interchange (ASCII) was defined for
representing characters. This is a 7-bit code, so there are 128 different code values. ASCII values 0 to 31
represent various nonprinting control characters such as carriage return (code 15) and line feed (code 12).
Code values 65 to 90 inclusive are the uppercase letters A to Z, and 97 to 122 correspond to lowercase a
to z. If you look at the binary values corresponding to the code values for letters, you’ll see that the codes
for lowercase and uppercase letters differ only in the sixth bit; lowercase letters have the sixth bit as 0, and
uppercase letters have the sixth bit as 1. Other codes represent digits 0 to 9, punctuation, and other characters.
The original 7-bit ASCII is fine if you are American or British, but if you are French or German, you
need things like accents and umlauts in text, which are not included in the 128 characters that 7-bit ASCII
encodes. To overcome the limitations imposed by a 7-bit code, extended versions of ASCII were defined with
8-bit codes. Values from 0 to 127 represent the same characters as 7-bit ASCII, and values from 128 to 255 are
variable. One variant of 8-bit ASCII that you have probably met is called Latin-1, which provides characters
for most European languages, but there are others for languages such as Russian.
If you speak Korean, Japanese, Chinese, or Arabic, an 8-bit coding is totally inadequate. To give you an
idea, modern encodings of Chinese, Japanese, and Korean scripts (which share a common background)
cover nearly 88,000 characters—a tiny bit more than the 256 characters you’re able to get out of 8 bits! To
overcome the limitations of extended ASCII, the Universal Character Set (UCS) emerged in the 1990s. UCS is
defined by the standard ISO 10646 and has codes with up to 32 bits. This provides the potential for hundreds
of millions of unique code values.

UCS and Unicode
UCS defines a mapping between characters and integer code values, called code points. It is important to
realize that a code point is not the same as an encoding. A code point is an integer; an encoding specifies
a way of representing a given code point as a series of bytes or words. Code values of less than 256 are
popular and can be represented in one byte. It would be inefficient to use four bytes to store code values that
require just one byte just because there are other codes that require several bytes. Encodings are ways of
representing code points that allow them to be stored more efficiently.
Unicode is a standard that defines a set of characters and their code points identical to those in UCS.
Unicode also defines several different encodings for these code points and includes additional mechanisms
for dealing with such things as right-to-left languages such as Arabic. The range of code points is more than
enough to accommodate the character sets for all the languages in the world, as well as many different sets of
graphical characters such as mathematical symbols, or even emoticons and emojis. Regardless, the codes are
arranged such that strings in the majority of languages can be represented as a sequence of single 16-bit codes.
One aspect of Unicode that can be confusing is that it provides more than one character encoding
method. The most commonly used encodings are referred to as UTF-8, UTF-16, and UTF-32, either of
which can represent all the characters in the Unicode set. The difference between them is in how a given
character code point is presented; the numerical code value for any given character is the same in either
representation. Here’s how these encodings represent characters:
•

UTF-8 represents a character as a variable-length sequence of between 1 and 4 bytes.
The ASCII character set appears in UTF-8 as single byte codes that have the same
codes values as ASCII. Most web pages use UTF-8 to encode text.

•

UTF-16 represents characters as one or two 16-bit values. UTF-16 includes UTF-8.
Because a single 16-bit value accommodates all of code plane 0, UTF-16 covers most
situations in programming for a multilingual context.

•

UTF-32, you guessed it, simply represents all characters as 32-bit values.

You have four integer types that store Unicode characters. These are types char, wchar_t, char16_t, and
char32_t. You’ll learn more about these in Chapter 2.

21

Chapter 1 ■ Basic Ideas

C++ Source Characters
You write C++ statements using a basic source character set. This is the set of characters that you’re allowed
to use explicitly in a C++ source file. The character set that you can use to define a name is a subset of this.
Of course, the basic source character set in no way constrains the character data that you work with in your
code. Your program can create strings consisting of characters outside this set in various ways, as you’ll see.
The basic source character set consists of the following characters:
•

The letters a to z and A to Z

•

The digits 0 to 9

•

The whitespace characters space, horizontal tab, vertical tab, form feed, and newline

•

The characters _ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ~ ! = , \ ” ’

This is easy and straightforward. You have 96 characters that you can use, and it’s likely that these will
accommodate your needs most of the time. Most of the time the basic source character set will be adequate,
but occasionally you’ll need characters that aren’t in it. You can, at least in theory, include Unicode
characters in a name. You specify a Unicode character in the form of a hexadecimal representation of its
code point, either as \udddd or as \Udddddddd, where d is a hexadecimal digit. Note the lowercase u in the
first case and the uppercase U in the second; either is acceptable. Compiler support for Unicode characters
in names is limited, though. Both character and string data can include Unicode characters.

Escape Sequences
When you want to use character constants such as a single character or a character string in a program,
certain characters are problematic. Obviously, you can’t enter characters such as newline directly as
character constants, as they’ll just do what they’re supposed to do: go to a new line in your source code
file (the only exception to this rule are raw string literals, which are covered in Chapter 7). You can enter
these problem characters in character constants by means of an escape sequence. An escape sequence is
an indirect way of specifying a character, and it always begins with a backslash. Table 1-3 shows the escape
sequences that represent control characters.
Table 1-3. Escape Sequences That Represent Control Characters

Escape Sequence

Control Character

\n

Newline

\t

Horizontal tab

\v

Vertical tab

\b

Backspace

\r

Carriage return

\f

Form feed

\a

Alert/bell

There are some other characters that are a problem to represent directly. Clearly, the backslash
character itself is difficult because it signals the start of an escape sequence. The single and double
quote characters that are used as delimiters, as in the constant 'A' or the string "text", can also
be a problem (it depends on the context; more on this later). Table 1-4 shows the escape sequences
for these.

22

Chapter 1 ■ Basic Ideas

Table 1-4. Escape Sequences That Represent “Problem” Characters

Escape Sequence

“Problem” Character

\\

Backslash

\'

Single quote

\"

Double quote

Because the backslash signals the start of an escape sequence, the only way to enter a backslash as a
character constant is by using two successive backslashes (\\).
This program that uses escape sequences outputs a message to the screen. To see it, you’ll need to enter,
compile, link, and execute the code:
// Ex1_02.cpp
// Using escape sequences
#include <iostream>
int main()
{
  std::cout << "\"Least \'said\' \\\n\t\tsoonest \'mended\'.\"" << std::endl;
}
When you manage to compile, link, and run this program, you should see the following output
displayed:
"Least 'said' \
                soonest 'mended'."
The output is determined by what’s between the outermost double quotes in the following statement:
  std::cout << "\"Least \'said\' \\\n\t\tsoonest \'mended\'.\"" << std::endl;
In principle, everything between the outer double quotes in the preceding statement gets sent to cout.
A string of characters between a pair of double quotes is called a string literal. The double quote characters
are delimiters that identify the beginning and end of the string literal; they aren’t part of the string. Each
escape sequence in the string literal will be converted to the character it represents by the compiler, so the
character will be sent to cout, not the escape sequence itself. A backslash in a string literal always indicates
the start of an escape sequence, so the first character that’s sent to cout is a double quote character.
Least followed by a space is output next. This is followed by a single quote character, then said,
followed by another single quote. Next is a space, followed by the backslash specified by \\. Then a newline
character corresponding to \n is written to the stream so the cursor moves to the beginning of the next line.
You then send two tab characters to cout with \t\t, so the cursor will be moved two tab positions to the
right. The word soonest is output next followed by a space and then mended between single quotes. Finally,
a period is output followed by a double quote.

■■Note If you’re no fan of escape sequences, Chapter 7 will introduce a possible alternative to them called
raw string literals.

23

Chapter 1 ■ Basic Ideas

The truth is, in our enthusiasm for showcasing character escaping, we may have gone a bit overboard
in Ex1_02.cpp. You actually do not have to escape the single quote character, ', inside string literals; there’s
already no possibility for confusion. So, the following statement would have worked just fine already:
  std::cout << "\"Least 'said' \\\n\t\tsoonest 'mended'.\"" << std::endl;
It’s only when within a character literal of the form '\'' that a single quote really needs escaping.
Conversely, double quotes, of course, won’t need a backslash then; your compiler will happily accept both
'\"' and '"'. But we’re getting ahead of ourselves: character literals are more a topic of the next chapter.

■■Note The \t\t escape sequences in Ex1_02 are, strictly speaking, not required either—you could in
principle type tabs in a string literal as well (as in "\"Least 'said' \\\n        soonest 'mended'.\"").
Using \t\t is nevertheless recommended; the problem with tabs is that one generally cannot tell the difference
between a tab, "    ", and a number of spaces, "    ", let alone properly count the number of tabs. Also,
some text editors tend to convert tabs into spaces upon saving. It’s therefore not uncommon for style guides to
require the use of the \t escape sequence in string literals.

Summary
This chapter’s content has been a broad overview to give you a feel for some of the general concepts of
C++. You’ll encounter everything discussed in this chapter again, and in much more detail, in subsequent
chapters. However, some of the basics that this chapter covered are as follows:

24

•

A C++ program consists of one or more functions, one of which is called main().
Execution always starts with main().

•

The executable part of a function is made up of statements contained between
braces.

•

A pair of curly braces is used to enclose a statement block.

•

A statement is terminated by a semicolon.

•

Keywords are reserved words that have specific meanings in C++. No entity in your
program can have a name that coincides with a keyword.

•

A C++ program will be contained in one or more files. Source files contain the
executable code, and header files contain definitions used by the executable code.

•

The source files that contain the code defining functions typically have the extension
.cpp.

•

Header files that contain definitions that are used by a source file typically have the
extension .h.

•

Preprocessor directives specify operations to be performed on the code in a file. All
preprocessor directives execute before the code in a file is compiled.

•

The contents of a header file are added into a source file by an #include
preprocessor directive.

Chapter 1 ■ Basic Ideas

•

The Standard Library provides an extensive range of capabilities that supports and
extends the C++ language.

•

Access to Standard Library functions and definitions is enabled through including
Standard Library header files in a source file.

•

Input and output are performed using streams and involve the use of the insertion
and extraction operators, << and >> . std::cin is a standard input stream that
corresponds to the keyboard. std::cout is a standard output stream for writing text
to the screen. Both are defined in the iostream Standard Library header.

•

Object-oriented programming involves defining new data types that are specific to
your problem. Once you’ve defined the data types that you need, a program can be
written in terms of the new data types.

•

Unicode defines unique integer code values that represent characters for virtually all
of the languages in the world as well as many specialized character sets. Code values
are referred to as code points. Unicode also defines how these code points may be
encoded as byte sequences.

EXERCISES
The following exercises enable you to try what you’ve learned in this chapter. If you get stuck, look back
over the chapter for help. If you’re still stuck after that, you can download the solutions from the Apress
website (www.apress.com/book/download.html), but that really should be a last resort.
Exercise 1-1: Create, compile, link, and execute a program that will display the text
"Hello World" on your screen.
Exercise 1-2: Create and execute a program that outputs your name on one line and
your age on the next line.
Exercise 1-3: The following program produces several compiler errors. Find these
errors and correct them so the program can compile cleanly and run.
include <iostream>
Int main()
{
  std:cout << "Hello World" << std:endl
)

25

CHAPTER 2

Introducing Fundamental
Types of Data
In this chapter, we’ll explain the fundamental data types that are built into C++. You’ll need these in every
program. All of the object-oriented capabilities are founded on these fundamental data types because all
the data types that you create are ultimately defined in terms of the basic numerical data your computer
works with. By the end of the chapter, you’ll be able to write a simple C++ program of the traditional form:
input – process – output.
In this chapter, you’ll learn
•

What a fundamental data type is in C++

•

How you declare and initialize variables

•

How you can fix the value of a variable

•

What integer literals are and how you define them

•

How calculations work

•

How to define variables that contain floating-point values

•

How to create variables that store characters

•

What the auto keyword does

Variables, Data, and Data Types
A variable is a named piece of memory that you define. Each variable stores data only of a particular type.
Every variable has a type that defines the kind of data it can store. Each fundamental type is identified by
a unique type name that consists of one or more keywords. Keywords are reserved words in C++ that you
cannot use for anything else.
The compiler makes extensive checks to ensure that you use the right data type in any given context.
It will also ensure that when you combine different types in an operation such as adding two values, for
example, either they are of the same type or they can be made to be compatible by converting one value to
the type of the other. The compiler detects and reports attempts to combine data of different types that are
incompatible.
Numerical values fall into two broad categories: integers, which are whole numbers, and floating-point
values, which can be nonintegral. There are several fundamental C++ types in each category, each of which
can store a specific range of values. We’ll start with integer types.

© Ivor Horton and Peter Van Weert 2018
I. Horton and P. Van Weert, Beginning C++17, https://doi.org/10.1007/978-1-4842-3366-5_2

27

Chapter 2 ■ Introducing Fundamental Types of Data

Defining Integer Variables
Here’s a statement that defines an integer variable:
int apple_count;
This defines a variable of type int with the name apple_count. The variable will contain some arbitrary
junk value. You can and should specify an initial value when you define the variable, like this:
int apple_count {15};                            // Number of apples
The initial value for apple_count appears between the braces following the name so it has the value 15.
The braces enclosing the initial value are called a braced initializer. You’ll meet situations later in the book
where a braced initializer will have several values between the braces. You don’t have to initialize variables
when you define them, but it’s a good idea to do so. Ensuring variables start out with known values makes it
easier to work out what is wrong when the code doesn’t work as you expect.
The size of variables of type int is typically 4 bytes, so they can store integers from -2,147,483,648 to
+2,147,483,647. This covers most situations, which is why int is the integer type that is used most frequently.
Here are definitions for three variables of type int:
int apple_count {15};                            // Number of apples
int orange_count {5};                            // Number of oranges
int total_fruit {apple_count + orange_count};    // Total number of fruit
The initial value for total_fruit is the sum of the values of two variables defined previously. This
demonstrates that the initial value for a variable can be an expression. The statements that define the
two variables in the expression for the initial value for total_fruit must appear earlier in the source file;
otherwise, the definition for total_fruit won’t compile.
The initial value between the braces should be of the same type as the variable you are defining. If
it isn’t, the compiler will try to convert it to the required type. If the conversion is to a type with a more
limited range of values, the conversion has the potential to lose information. An example would be if you
specified the initial value for an integer variable that is not an integer—1.5, for example. A conversion to a
type with a more limited range of values is called a narrowing conversion. If you use curly braces to initialize
your variables, the compiler will always issue either a warning or an error whenever it detects a narrowing
conversion.
There are two other ways for initializing a variable. Functional notation looks like this:
int orange_count(5);
int total_fruit(apple_count + orange_count);
A second alternative is the so-called assignment notation:
int orange_count = 5;
int total_fruit = apple_count + orange_count;
Both these possibilities are equally valid as the braced initializer form and mostly completely
equivalent. Both are therefore used extensively in existing code as well. In this book, however, we’ll adopt
the braced initializer syntax. This is the most recent syntax that was introduced in C++11 specifically to
standardize initialization. Its main advantage is that it enables you to initialize just about everything in the
same way—which is why it is also commonly referred to as uniform initialization. Another advantage is that
the braced initializer form is slightly safer when it comes to narrowing conversions:

28

Chapter 2 ■ Introducing Fundamental Types of Data

int banana_count(7.5);         // May compile without warning
int coconut_count = 5.3;       // May compile without warning
int papaya_count{0.3};         // At least a compiler warning, often an error
All three definitions clearly contain a narrowing conversion. We’ll have more to say about
floating-point to integer conversions later, but for now believe us when we say that after these variable
definitions banana_count will contain the integer value 7, coconut_count will initialize to 5, and
papaya_count will initialize to 0—provided compilation does not fail with an error because of the third
statement, of course. It’s unlikely that this is what the author had in mind. Definitions with narrowing
conversions such as these are therefore almost always mistakes.
Nevertheless, as far as the C++ standard is concerned, our first two definitions are perfectly legal C++.
They are allowed to compile without even the slightest warning. While some compilers do issue a warning
about such flagrant narrowing conversions, definitely not all of them do. If you use the braced initializer
form, however, a conforming compiler is required to at least issue a diagnostic message. Some compilers
will even issue an error and refuse to compile such definitions altogether. We believe inadvertent narrowing
conversions do not deserve to go unnoticed, which is why we favor the braced initializer form.

■■Note To represent fractional numbers, you typically use floating-point variables rather than integers. We’ll
describe these later in this chapter.
Prior to C++17, there was one relatively common case where uniform initialization could not be used.
We’ll return to this exception near the end of this chapter when we discuss the auto keyword. But since this
quirk will soon be nothing more than a bad memory, we believe there’s little objective reason left not to
embrace the new syntax. Uniformity and predictability, on the other hand, are desirable traits—especially
for you, someone who’s taking the first steps in C++. In this book, we’ll therefore consistently use braced
initializers.
You can define and initialize more than one variable of a given type in a single statement. Here’s
an example:
int foot_count {2}, toe_count {10}, head_count {1};
While this is legal, it’s often considered best to define each variable in a separate statement. This makes
the code more readable, and you can explain the purpose of each variable in a comment.
You can write the value of any variable of a fundamental type to the standard output stream. Here’s a
program that does that with a couple of integers:
// Ex2_01.cpp
// Writing values of variables to cout
#include <iostream>
int main()
{
  int apple_count {15};                            // Number of apples
  int orange_count {5};                            // Number of oranges
  int total_fruit {apple_count + orange_count};    // Total number of fruit
  std::cout << "The value of apple_count is "  << apple_count  << std::endl;
  std::cout << "The value of orange_count is " << orange_count << std::endl;
  std::cout << "The value of total_fruit is "  << total_fruit  << std::endl;
}

29

Chapter 2 ■ Introducing Fundamental Types of Data

If you compile and execute this, you’ll see that it outputs the values of the three variables
following some text explaining what they are. The integer values are automatically converted to a
character representation for output by the insertion operator, <<. This works for values of any of the
fundamental types.

■■Tip The three variables in Ex2_01.cpp, of course, do not really need any comments explaining what
they represent. Their variable names already make that crystal clear—as they should! In contrast, a lesser
programmer might have produced the following, for instance:
  int n {15};
  int m {5};
  int t {n + m};
Without extra context or explanation, no one would ever be able to guess this code is about counting
fruit. You should therefore always choose your variable names as self-descriptive as possible. Properly
named variables and functions mostly need no additional explanation in the form of a comment at all,
by which we of course do not mean you should never add comments to declarations. You cannot always
capture everything in a single name. A few words or, if need be, a little paragraph of comments can
then do wonders in helping someone understand the code. A little extra effort at the time of writing can
considerably speed up future development!

Signed Integer Types
Table 2-1 shows the complete set of fundamental types that store signed integers—that is, both positive
and negative values. The memory allocated for each type, and hence the range of values it can store, may
vary between different compilers. Table 2-1 shows the sizes and ranges used by compilers for all common
platforms and computer architectures.

30

Chapter 2 ■ Introducing Fundamental Types of Data

Table 2-1. Signed Integer Types

Type Name

Typical Size (Bytes)

Range of Values

signed char

1

-128 to +127

short
short int
signed short
signed short int

2

-256 to +255

int
signed
signed int

4

-2,147,483,648 to +2,147,483,647

long
long int
signed long
signed long int

4 or 8

Same as either int or long long

long long
long long int
signed long long
singed long long int

8

-9,223,372,036,854,775,808 to
+9,223,372,036,854,775,807

Type signed char is always 1 byte (which in turn nearly always is 8 bits); the number of bytes occupied
by the others depends on the compiler. Each type will always have at least as much memory as the one that
precedes it in the list, though.
Where two type names appear in the left column, the abbreviated name that comes first is more
commonly used. That is, you will usually see long used rather than long int or signed long int.
The signed modifier is mostly optional; if omitted, your type will be signed by default. The only
exception to this rule is char. While the unmodified type char does exist, it is compiler-dependant whether it
is signed or unsigned. We’ll discuss this further in the next subsection. For all integer types other than char,
however, you are free to choose whether you add the signed modifier. Personally, we normally do so only
when we really want to stress that a particular variable is signed.

Unsigned Integer Types
Of course, there are circumstances where you don’t need to store negative numbers. The number of students
in a class or the number of parts in an assembly is always a positive integer. You can specify integer types that
only store non-negative values by prefixing any of the names of the signed integer types with the unsigned
keyword—types unsigned char or unsigned short or unsigned long long, for example. Each unsigned type
is a different type from the signed type but occupies the same amount of memory.
Type char is a different integer type from both signed char and unsigned char. The char type is
intended only for variables that store character codes and can be a signed or unsigned type depending on
your compiler. If the constant CHAR_MIN in the climits header is 0, then char is an unsigned type with your
compiler. We’ll have more to say about variables that store characters later in this chapter.

31

Chapter 2 ■ Introducing Fundamental Types of Data

■■Tip Only use variables of the unmodified char type to store characters. For char variables that store other
data such as plain integer numbers, you should always add the appropriate sign modifier.
With the possible exception of unsigned char, increasing the range of representable numbers is rarely
the main motivator for adding the unsigned modifier—it rarely matters, for instance, whether you can
represent numbers up to +2,147,483,647 or up to +4,294,967,295 (the maximum values for signed and
unsigned int, respectively). No. Instead, you mostly add the unsigned modifier to make your code more
self-documenting, that is, to make it more predictable what values a given variable will or should contain.

■■Note

You can also use the keywords signed and unsigned on their own. As Table 2-1 shows, the type
signed is considered shorthand for signed int. So naturally, unsigned is short for unsigned int.

Zero Initialization
The following statement defines an integer variable with an initial value equal to zero:
int counter {0};         // counter starts at zero
You could omit the 0 in the braced initializer here, and the effect would be the same. The statement that
defines counter could thus be written like this:
int counter {};          // counter starts at zero
The empty curly braces somewhat resemble the number zero, which makes this syntax easy to
remember. Zero initialization works for any fundamental type. For all fundamental numeric types, for
instance, an empty braced initializer is always assumed to contain the number zero.

Defining Variables with Fixed Values
Sometimes you’ll want to define variables with values that are fixed and must not be changed. You use the
const keyword in the definition of a variable that must not be changed. Such variables are often referred to
as constants. Here’s an example:
const unsigned toe_count {10};          // An unsigned integer with fixed value 10
The const keyword tells the compiler that the value of toe_count must not be changed. Any statement
that attempts to modify this value will be flagged as an error during compilation; cutting off someone’s toe is
a definite no-no! You can use the const keyword to fix the value of variables of any type.

■■Tip If nothing else, knowing which variables can and cannot change their values along the way makes
your code easier to follow. So, we recommend you add the const specifier whenever applicable.

32

Chapter 2 ■ Introducing Fundamental Types of Data

Integer Literals
Constant values of any kind, such as 42, 2.71828, 'Z', or "Mark Twain", are referred to as literals. These
examples are, in sequence, an integer literal, a floating-point literal, a character literal, and a string literal.
Every literal will be of some type. We’ll first explain integer literals and introduce the other kinds of literals in
context later.

Decimal Integer Literals
You can write integer literals in a very straightforward way. Here are some examples of decimal integers:
-123L      +123      123      22333    98U -1234LL   12345ULL
Unsigned integer literals have u or U appended. Literals of types long and type long long have L or LL
appended, respectively, and if they are unsigned, they also have u or U appended. If there is no suffix, an
integer constant is of type int. The U and L or LL can be in either sequence. You can use lowercase for the L
and LL suffixes, but we recommend that you don’t because lowercase L is easily confused with the digit 1.
You could omit the + in the second example, as it’s implied by default, but if you think putting it in
makes things clearer, that’s not a problem. The literal +123 is the same as 123 and is of type int because there
is no suffix.
The fourth example, 22333, is the number that you, depending on local conventions, might write
as either 22,333; 22 333; or 22.333 (though other formatting conventions exist as well). You must not use
commas or spaces in a C++ integer literal, though, and adding a dot would turn it into a floating-point literal
(as discussed later). Ever since C++14, however, you can use the single quote character, ', to make numeric
literals more readable. Here’s an example:
22'333    -1'234LL    12'345ULL
Here are some statements using some of these literals:
unsigned long age {99UL};           // 99ul or 99LU would be OK too
unsigned short price {10u};         // There is no specific literal type for short
long long distance {15'000'000LL}; // Common digit grouping of the number 15 million
Note that there are no restrictions on how to group the digits. Most Western conventions tend to group
digits per three, but this is not universal. Natives of the subcontinent of India, for instance, would typically write
the literal for 15 million as follows (using groups of two digits except for the rightmost group of three digits):
1'50'00'000LL
So far we have been very diligent in adding our literal suffixes—u or U for unsigned literals, L for literals
of type long, and so on. In practice, however, you’ll rarely add these in variable initializers of this form. The
reason is that no compiler will ever complain if you simply type this:
unsigned long age {99};
unsigned short price {10};        // There is no specific literal type for short
long long distance {15'000'000};  // Common digit grouping of the number 15 million

33

Chapter 2 ■ Introducing Fundamental Types of Data

While all these literals are technically of type (signed) int, your compiler will happily convert them to
the correct type for you. As long as the target type can represent the given values without loss of information,
there’s no need to issue a warning.

■■Note While mostly optional, there are situations where you do need to add the correct literal suffixes,
such as when you initialize a variable with type auto (as explained near the end of this chapter) or when calling
overloaded functions with literal arguments (as covered in Chapter 8).
An initializing value should always be within the permitted range for the type of variable, as well as from
the correct type. The following two statements violate these restrictions. They require, in other words, what
you know to be narrowing conversions:
unsigned char high_score { 513U };   // The valid range for unsigned char is [0,255]
unsigned int high_score { -1 };      // -1 is a literal of type signed int
As we explained earlier, depending on which compiler you use, these braced initializations will result in
at least a compiler warning, if not a compilation error.

Hexadecimal Literals
You can write integer literals as hexadecimal values. You prefix a hexadecimal literal with 0x or 0X, so 0x999
is a hexadecimal number of type int with three hexadecimal digits. Plain old 999, on the other hand, is a
decimal value of type int with decimal digits, so the value will be completely different. Here are some more
examples of hexadecimal literals:
Hexadecimal literals:

0x1AF

0x123U

0xAL

0xcad

0xFF

Decimal literals:

431

291U

10L

3245

255

A major use for hexadecimal literals is to define particular patterns of bits. Each hexadecimal digit
corresponds to 4 bits, so it’s easy to express a pattern of bits as a hexadecimal literal. The red, blue, and
green components (RGB values) of a pixel color, for instance, are often expressed as three bytes packed
into a 32-bit word. The color white can be specified as 0xFFFFFF because the intensity of each of the three
components in white have the same maximum value of 255, which is 0xFF. The color red would be 0xff0000.
Here are some examples:
unsigned int color {0x0f0d0e};   // Unsigned int hexadecimal constant - decimal 986,382
int mask {0XFF00FF00};           // Four bytes specified as FF, 00, FF, 00
unsigned long value {0xDEADlu};  // Unsigned long hexadecimal literal - decimal 57,005

Octal Literals
You can also write integer literals xas octal values—that is, using base 8. You identify a number as octal by
writing it with a leading zero.
Octal literals:

0657

0443U

012L

06255

0377

Decimal literals:

431

291U

10L

3245

255

34

Chapter 2 ■ Introducing Fundamental Types of Data

■■Caution Don’t write decimal integer values with a leading zero. The compiler will interpret such values as
octal (base 8), so a value written as 065 will be the equivalent of 53 in decimal notation.

Binary Literals
Binary literals were introduced by the C++14 standard. You write a binary integer literal as a sequence of
binary digits (0 or 1) prefixed by either 0b or 0B. As always, a binary literal can have L or LL as a suffix to
indicate it is type long or long long, and u or U if it is an unsigned literal. Here’s an example:
Binary literals:

0B110101111

0b100100011U

0b1010L

0B110010101101

0b11111111

Decimal literals:

431

291U

10L

3245

255

We have illustrated in the code fragments how you can write various combinations for the prefixes and
suffixes such as 0x or 0X and UL, LU, or Lu, but of course it’s best to stick to a consistent way of writing integer
literals.
As far as your compiler is concerned, it doesn’t matter which number base you choose when you write
an integer value. Ultimately it will be stored as a binary number. The different ways for writing an integer are
there just for your convenience. You choose one or other of the possible representations to suit the context.

■■Note You can use a single quote as a separator in any integer literal to make it easier to read. This
includes hexadecimal or binary literals. Here’s an example: 0xFF00'00FF'0001UL or 0b1100'1010'1101.

Calculations with Integers
To begin with, let’s get some bits of terminology out of the way. An operation such as addition or multiplication
is defined by an operator—the operators for addition and multiplication are + and *, respectively. The values
that an operator acts upon are called operands, so in an expression such as 2*3, the operands are 2 and 3.
Operators such as multiplication that require two operands are called binary operators. Operators that require
one operand are called unary operators. An example of a unary operator is the minus sign in the expression
-width. The minus sign negates the value of width, so the result of the expression is a value with the opposite
sign to that of its operand. This contrasts with the binary multiplication operator in expressions such as width
* height, which acts on two operands, width and height.
Table 2-2 shows the basic arithmetic operations that you can carry out on integers.
Table 2-2. Basic Arithmetic Operations

Operator

Operation

+

Addition

-

Subtraction

*

Multiplication

/

Division

%

Modulus (the remainder after division)

35

Chapter 2 ■ Introducing Fundamental Types of Data

The operators in Table 2-2 are all binary operators and work largely in the way you would expect. There
are two operators that may need a little word of explanation, though: the somewhat lesser-known modulus
operator, of course, but also the division operator. Integer division is slightly idiosyncratic in C++. When
applied to two integer operands, the result of a division operation is always again an integer. Suppose, for
instance, that you write the following:
int numerator = 11;
int quotient = numerator / 4;
Mathematically speaking, the result of the division 11/4 is of course 2.75 or 2¾, that is, 2 and three
quarters. But 2.75 is clearly no integer, so what to do? Any sane mathematician would suggest that you
round the quotient to the nearest integer, so 3. But, alas, that is not what your computer will do. Instead,
your computer will simply discard the fractional part, 0.75, altogether. No doubt this is because proper
rounding would require more complicated circuitry and hence also more time to evaluate. This means that,
in C++, 11/4 will always give the integer value 2. Figure 2-1 illustrates the effects of the division and modulus
operators on our example.
Integer Divide Operator
11/4

2 times 4 Remainder 3

Result = 2

Discarded

Modulus Operator
11/4

2 times 4 Remainder 3

Discarded

Result = 3

Figure 2-1. Contrasting the division and modulus operators
Integer division returns the number of times that the denominator divides into the numerator. Any
remainder is discarded. The modulus operator, %, complements the division operator in that it produces the
remainder after integer division. It is defined such that, for all integers x and y, (x / y) * y + (x % y) equals x.
Using this formula, you can easily deduce what the modulus operand will do for negative operands.
The result of both the division and modulus operator is undefined when the right operand is zero—
what’ll happen depends, in other words, on your compiler and computer architecture.

Compound Arithmetic Expressions
If multiple operators appear in the same expression, multiplication, division, and modulus operations
always execute before addition and subtraction. Here’s an example of such a case:
long width {4};
long length {5};
long area { width * length };            // Result is 20
long perimeter {2*width + 2*length};     // Result is 18

36


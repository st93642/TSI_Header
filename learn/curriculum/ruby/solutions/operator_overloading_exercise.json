{
  "exerciseId": "operator_overloading_exercise",
  "languageId": "ruby",
  "code": "# Operator Overloading Exercise - Solution\n\nclass Fraction\n  attr_reader :numerator, :denominator\n  \n  def initialize(numerator, denominator = 1)\n    @numerator = numerator\n    @denominator = denominator\n    simplify\n  end\n  \n  # Addition\n  def +(other)\n    new_num = @numerator * other.denominator + other.numerator * @denominator\n    new_den = @denominator * other.denominator\n    Fraction.new(new_num, new_den)\n  end\n  \n  # Equality\n  def ==(other)\n    other.is_a?(Fraction) && \n    @numerator == other.numerator && \n    @denominator == other.denominator\n  end\n  \n  # String representation\n  def to_s\n    \"#{@numerator}/#{@denominator}\"\n  end\n  \n  private\n  \n  def simplify\n    gcd = @numerator.gcd(@denominator)\n    @numerator /= gcd\n    @denominator /= gcd\n  end\nend\n\nclass TimeSpan\n  attr_reader :seconds\n  \n  def initialize(seconds)\n    @seconds = seconds\n  end\n  \n  # Addition\n  def +(other)\n    TimeSpan.new(@seconds + other.seconds)\n  end\n  \n  # Comparison (spaceship operator)\n  def <=>(other)\n    @seconds <=> other.seconds\n  end\n  \n  # Convert to string\n  def to_s\n    \"#{@seconds} seconds\"\n  end\n  \n  # Class method for creating from minutes\n  def self.from_minutes(minutes)\n    new(minutes * 60)\n  end\nend\n\nclass SparseArray\n  def initialize\n    @data = {}\n  end\n  \n  # Index getter\n  def [](index)\n    @data[index] || 0\n  end\n  \n  # Index setter\n  def []=(index, value)\n    if value == 0\n      @data.delete(index)\n    else\n      @data[index] = value\n    end\n  end\n  \n  # Get all non-zero indices\n  def indices\n    @data.keys.sort\n  end\n  \n  # Get the maximum index used\n  def max_index\n    @data.keys.max || -1\n  end\nend\n\n# Test helper methods\ndef test_fraction_add\n  f1 = Fraction.new(1, 4)\n  f2 = Fraction.new(1, 4)\n  result = f1 + f2\n  result.to_s\nend\n\ndef test_fraction_equality\n  f1 = Fraction.new(1, 2)\n  f2 = Fraction.new(2, 4)\n  f1 == f2\nend\n\ndef test_timespan_compare\n  t1 = TimeSpan.new(3600)  # 1 hour\n  t2 = TimeSpan.new(1800)  # 30 minutes\n  t1 > t2\nend\n\ndef test_timespan_add\n  t1 = TimeSpan.new(3000)  # 50 minutes\n  t2 = TimeSpan.new(660)   # 11 minutes\n  result = t1 + t2\n  result.seconds\nend\n\ndef test_sparse_array_get\n  arr = SparseArray.new\n  arr[5] = 42\n  arr[5]\nend\n\ndef test_sparse_array_set\n  arr = SparseArray.new\n  arr[10] = 100\n  arr[10] = 50  # This should work\n  arr[10] = 100 # Set it back\n  arr[10]\nend",
  "explanation": "This solution demonstrates comprehensive operator overloading:\n\n**Fraction Class**:\n- `+` operator adds fractions with proper common denominators\n- `==` checks mathematical equality (1/2 == 2/4)\n- Automatic simplification using GCD\n\n**TimeSpan Class**:\n- `+` adds time spans together\n- `<=>` enables all comparison operators (<, >, <=, >=, ==)\n- Class method factory for creating from minutes\n\n**SparseArray Class**:\n- `[]` gets values (returns 0 for unset indices)\n- `[]=` sets values (removes entry when set to 0)\n- Memory efficient storage of sparse data\n\n**Key Principles**:\n- Operators should return new instances, not modify existing ones\n- Type checking prevents runtime errors\n- Behavior should be intuitive and consistent\n- Leverage Ruby's automatic compound assignment (+=, -=, etc.)",
  "keyPoints": [
    "Override <=> to enable all comparison operators automatically",
    "Arithmetic operators should return new instances, not modify existing ones",
    "Use [] and []= for custom indexing behavior",
    "Check types in operator methods to prevent errors",
    "Make operators behave intuitively like built-in Ruby types",
    "Consider commutativity when implementing binary operators",
    "Document operator behavior clearly for users of your classes"
  ]
}
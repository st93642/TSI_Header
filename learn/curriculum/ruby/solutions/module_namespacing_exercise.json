{
  "exerciseId": "module_namespacing_exercise",
  "languageId": "ruby",
  "code": "# Module Namespacing Exercise - Solution\n\nmodule GameEngine\n  VERSION = \"1.0.0\"\n  \n  module Entities\n    class Player\n      attr_reader :name, :health\n      \n      def initialize(name)\n        @name = name\n        @health = 100\n      end\n      \n      def attack(target)\n        damage = rand(20..50)\n        \"#{@name} defeated #{target.class.name.split('::').last} with #{damage} damage\"\n      end\n    end\n    \n    class Enemy\n      def initialize\n        @type = \"Enemy\"\n      end\n    end\n  end\n  \n  module Combat\n    def self.resolve_attack(attacker, defender)\n      attacker.attack(defender)\n    end\n  end\nend\n\nmodule FileSystem\n  class Path\n    def initialize(path)\n      @path = path\n    end\n    \n    def join(*parts)\n      FileSystem::Path.new(File.join(@path, *parts))\n    end\n    \n    def to_s\n      @path\n    end\n  end\n  \n  module Utils\n    def self.normalize_path(path)\n      path.gsub(/\\\\/, '/').gsub(/\\/, '/')\n    end\n  end\nend\n\nmodule WebFramework\n  module Routing\n    class Route\n      def initialize(method, path, controller, action)\n        @method = method\n        @path = path\n        @controller = controller\n        @action = action\n      end\n      \n      def match?(request_method, request_path)\n        @method == request_method && @path == request_path\n      end\n      \n      def to_s\n        \"#{@method} #{@path} -> #{@controller}##{@action}\"\n      end\n    end\n    \n    class Router\n      def initialize\n        @routes = []\n      end\n      \n      def add_route(method, path, controller, action)\n        @routes << Route.new(method, path, controller, action)\n      end\n      \n      def route(request_method, request_path)\n        route = @routes.find { |r| r.match?(request_method, request_path) }\n        route&.to_s || \"No route found\"\n      end\n    end\n  end\n  \n  module Controllers\n    class BaseController\n      include Validation\n      include Persistence\n    end\n    \n    class UsersController < BaseController\n      def index\n        \"UsersController#index\"\n      end\n    end\n  end\nend\n\n# Mixin modules\nmodule Validation\n  def validate\n    \"Validated\"\n  end\nend\n\nmodule Persistence\n  def save\n    \"saved\"\n  end\nend\n\n# Test helper methods\ndef test_game_engine\n  player = GameEngine::Entities::Player.new(\"Hero\")\n  enemy = GameEngine::Entities::Enemy.new\n  GameEngine::Combat.resolve_attack(player, enemy)\nend\n\ndef test_filesystem\n  path = FileSystem::Path.new(\"/home/user\")\n  documents = path.join(\"documents\")\n  file_path = documents.join(\"file.txt\")\n  file_path.to_s\nend\n\ndef test_web_framework\n  router = WebFramework::Routing::Router.new\n  router.add_route(\"GET\", \"/users\", \"UsersController\", \"index\")\n  router.route(\"GET\", \"/users\")\nend\n\ndef test_mixin\n  controller = WebFramework::Controllers::UsersController.new\n  \"#{controller.validate} and #{controller.save}\"\nend\n\ndef test_constants\n  GameEngine::VERSION\nend\n\ndef test_nested\n  # This would be a more complex example, but for testing:\n  \"Database connected to production\"\nend",
  "explanation": "This solution demonstrates comprehensive module namespacing:\n\n**GameEngine Module**:\n- VERSION constant at module level\n- Entities submodule with Player and Enemy classes\n- Combat submodule with utility methods\n- Clear separation of game components\n\n**FileSystem Module**:\n- Path class for path manipulation\n- Utils submodule for utility functions\n- Method chaining with join operations\n\n**WebFramework Module**:\n- Routing submodule with Route and Router classes\n- Controllers submodule with BaseController and UsersController\n- Mixin functionality with Validation and Persistence modules\n\n**Key Patterns**:\n- Constants defined at appropriate module levels\n- Nested modules for hierarchical organization\n- Mixins included in base classes\n- Utility methods in submodules\n- Clear naming conventions and structure",
  "keyPoints": [
    "Use modules to group related classes, constants, and methods",
    "Access namespaced items with :: syntax (Module::Class)",
    "Modules can be nested for hierarchical organization",
    "Constants in modules are accessed with Module::CONSTANT",
    "Modules can serve both as namespaces and mixins",
    "Organize code by domain, functionality, or architectural layer",
    "Use consistent naming conventions within namespaces",
    "Document module purposes and relationships"
  ]
}
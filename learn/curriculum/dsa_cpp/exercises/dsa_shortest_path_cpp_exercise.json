{
  "id": "dsa_shortest_path_cpp_exercise",
  "mode": "quiz",
  "title": "Shortest Paths in Graphs - Practice Quiz",
  "description": "Challenge your understanding of single-source shortest path algorithms including Dijkstra's and Bellman-Ford. Expect questions on algorithm capabilities, complexity trade-offs, and real-world applications.",
  "totalQuestions": 10,
  "passScore": 7,
  "questions": [
    {
      "id": "dijkstra_negative_edges",
      "type": "single",
      "prompt": "Which of the following is true about Dijkstra's algorithm?",
      "options": [
        { "id": "a", "text": "It can handle negative edge weights" },
        { "id": "b", "text": "It uses a priority queue to always select the closest vertex", "correct": true },
        { "id": "c", "text": "It has O(V^2) time complexity" },
        { "id": "d", "text": "It can detect negative cycles" }
      ],
      "explanation": "Dijkstra's algorithm uses a priority queue (min-heap) to greedily select the vertex with the smallest tentative distance. It cannot handle negative edge weights and will produce incorrect results if they exist."
    },
    {
      "id": "bellman_ford_capability",
      "type": "single",
      "prompt": "What makes Bellman-Ford algorithm different from Dijkstra's?",
      "options": [
        { "id": "a", "text": "It uses a priority queue" },
        { "id": "b", "text": "It can handle negative edge weights", "correct": true },
        { "id": "c", "text": "It has better time complexity" },
        { "id": "d", "text": "It cannot find shortest paths" }
      ],
      "explanation": "Bellman-Ford can handle graphs with negative edge weights, unlike Dijkstra's algorithm. It relaxes all edges |V|-1 times and can detect negative cycles."
    },
    {
      "id": "shortest_path_complexity",
      "type": "single",
      "prompt": "What is the time complexity of Dijkstra's algorithm with a binary heap?",
      "options": [
        { "id": "a", "text": "O(V^2)" },
        { "id": "b", "text": "O((V + E) log V)", "correct": true },
        { "id": "c", "text": "O(V × E)" },
        { "id": "d", "text": "O(E log V)" }
      ],
      "explanation": "With a binary heap (priority queue), Dijkstra's algorithm runs in O((V + E) log V) time. Using a Fibonacci heap can improve this to O(E + V log V)."
    },
    {
      "id": "negative_cycle_detection",
      "type": "single",
      "prompt": "How does Bellman-Ford detect negative cycles?",
      "options": [
        { "id": "a", "text": "By checking if any distance becomes negative" },
        { "id": "b", "text": "By attempting one more relaxation after |V|-1 iterations", "correct": true },
        { "id": "c", "text": "By using a priority queue" },
        { "id": "d", "text": "By checking edge weights during initialization" }
      ],
      "explanation": "After |V|-1 relaxation iterations, Bellman-Ford performs one more iteration. If any distance can still be updated, a negative cycle exists."
    },
    {
      "id": "algorithm_choice",
      "type": "single",
      "prompt": "When should you choose Dijkstra's over Bellman-Ford?",
      "options": [
        { "id": "a", "text": "When the graph has negative cycles" },
        { "id": "b", "text": "When all edge weights are non-negative", "correct": true },
        { "id": "c", "text": "When you need to detect negative cycles" },
        { "id": "d", "text": "When the graph is dense" }
      ],
      "explanation": "Dijkstra's algorithm is preferred for graphs with non-negative edge weights because it runs faster (O((V+E) log V)) than Bellman-Ford (O(V×E))."
    },
    {
      "id": "gps_application",
      "type": "single",
      "prompt": "Which shortest path algorithm is most commonly used in GPS navigation systems?",
      "options": [
        { "id": "a", "text": "Bellman-Ford" },
        { "id": "b", "text": "Dijkstra's with A* optimization", "correct": true },
        { "id": "c", "text": "Bellman-Ford with Fibonacci heap" },
        { "id": "d", "text": "Basic Dijkstra's without heap" }
      ],
      "explanation": "GPS systems typically use Dijkstra's algorithm with A* heuristic optimization for faster pathfinding in road networks with non-negative distances."
    },
    {
      "id": "arbitrage_detection",
      "type": "single",
      "prompt": "In financial applications, negative cycles in currency exchange graphs indicate:",
      "options": [
        { "id": "a", "text": "Market equilibrium" },
        { "id": "b", "text": "Arbitrage opportunities", "correct": true },
        { "id": "c", "text": "Currency devaluation" },
        { "id": "d", "text": "Trading losses" }
      ],
      "explanation": "A negative cycle in currency exchange rates means you can start with some amount of currency, exchange it around the cycle, and end up with more than you started - an arbitrage opportunity."
    },
    {
      "id": "space_complexity",
      "type": "single",
      "prompt": "What is the space complexity of both Dijkstra's and Bellman-Ford algorithms?",
      "options": [
        { "id": "a", "text": "O(1)" },
        { "id": "b", "text": "O(V)", "correct": true },
        { "id": "c", "text": "O(E)" },
        { "id": "d", "text": "O(V + E)" }
      ],
      "explanation": "Both algorithms use O(V) space for storing distances, parents, and visited arrays. Dijkstra's also uses a priority queue, but this doesn't change the asymptotic complexity."
    },
    {
      "id": "dense_graph_optimization",
      "type": "single",
      "prompt": "For dense graphs (E ≈ V²), which Dijkstra implementation is most efficient?",
      "options": [
        { "id": "a", "text": "Binary heap implementation" },
        { "id": "b", "text": "Adjacency matrix with simple array", "correct": true },
        { "id": "c", "text": "Fibonacci heap implementation" },
        { "id": "d", "text": "Bellman-Ford algorithm" }
      ],
      "explanation": "For dense graphs, using an adjacency matrix with a simple array to find minimum distances (O(V²) total) can be more efficient than heap operations."
    },
    {
      "id": "single_source_vs_all_pairs",
      "type": "single",
      "prompt": "Both Dijkstra's and Bellman-Ford solve which type of shortest path problem?",
      "options": [
        { "id": "a", "text": "All-pairs shortest paths" },
        { "id": "b", "text": "Single-source shortest paths", "correct": true },
        { "id": "c", "text": "Single-pair shortest paths" },
        { "id": "d", "text": "Minimum spanning tree" }
      ],
      "explanation": "Both algorithms find shortest paths from a single source vertex to all other vertices in the graph. All-pairs problems require different algorithms like Floyd-Warshall."
    }
  ]
}
{
  "exerciseId": "dsa_dynamic_programming_fundamentals_cpp_exercise",
  "mode": "quiz",
  "id": "dsa_dynamic_programming_fundamentals_cpp_exercise",
  "answerKey": {
    "dp_fundamentals_1": "option_a",
    "dp_fundamentals_2": "false",
    "dp_fundamentals_3": ["option_a", "option_c", "option_d"],
    "dp_fundamentals_4": "option_b",
    "dp_fundamentals_5": "true",
    "dp_fundamentals_6": ["option_a", "option_c", "option_d"],
    "dp_fundamentals_7": "option_b",
    "dp_fundamentals_8": "false",
    "dp_fundamentals_9": ["option_b", "option_d"],
    "dp_fundamentals_10": "option_d"
  },
  "keyPoints": [
    "Dynamic programming requires optimal substructure and overlapping subproblems to be effective",
    "Memoization uses top-down recursion with caching, tabulation uses bottom-up iteration with tables",
    "Choose memoization for sparse problems and natural recursion, tabulation for dense problems and cache efficiency",
    "Optimal substructure means optimal solutions contain optimal subsolutions",
    "Overlapping subproblems enable caching to avoid exponential recomputation",
    "DP transforms problems from exponential to polynomial time through systematic subproblem reuse",
    "Memoization is limited by recursion depth, tabulation avoids this with iteration",
    "DP applies to both optimization and counting problems with the right characteristics",
    "Space optimization techniques like rolling arrays can reduce DP memory usage significantly",
    "Understanding when to apply DP vs other paradigms is crucial for algorithm selection"
  ]
}
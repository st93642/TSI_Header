{
  "exerciseId": "web3_exercise",
  "languageId": "rust",
  "code": "use tokio::time::{sleep, Duration, timeout};\nuse tokio::sync::mpsc;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\n\n// Step 1: Async Task Spawning\nasync fn async_task(id: u32, delay_ms: u64) {\n    println!(\"Starting task {}\", id);\n    sleep(Duration::from_millis(delay_ms)).await;\n    println!(\"Task {} completed\", id);\n}\n\npub async fn spawn_multiple_tasks() {\n    let task1 = tokio::spawn(async_task(1, 100));\n    let task2 = tokio::spawn(async_task(2, 200));\n    let task3 = tokio::spawn(async_task(3, 50));\n\n    // Wait for all tasks to complete\n    let _ = tokio::try_join!(task1, task2, task3);\n}\n\n// Step 2: Async Channels\nasync fn channel_sender(mut tx: mpsc::Sender<String>) {\n    let messages = vec![\"Hello\", \"World\", \"Async\"];\n    for msg in messages {\n        if let Err(_) = tx.send(msg.to_string()).await {\n            println!(\"Receiver dropped\");\n            return;\n        }\n        sleep(Duration::from_millis(10)).await;\n    }\n}\n\nasync fn channel_receiver(mut rx: mpsc::Receiver<String>) {\n    while let Some(msg) = rx.recv().await {\n        println!(\"Received: {}\", msg);\n    }\n}\n\npub async fn test_channels() {\n    let (tx, rx) = mpsc::channel(10);\n\n    let sender_handle = tokio::spawn(channel_sender(tx));\n    let receiver_handle = tokio::spawn(channel_receiver(rx));\n\n    let _ = tokio::try_join!(sender_handle, receiver_handle);\n}\n\n// Step 3: Timeout Handling\nasync fn fast_operation() -> Result<String, String> {\n    sleep(Duration::from_millis(50)).await;\n    Ok(\"Fast operation completed\".to_string())\n}\n\nasync fn slow_operation() -> Result<String, String> {\n    sleep(Duration::from_millis(200)).await;\n    Ok(\"Slow operation completed\".to_string())\n}\n\npub async fn test_timeouts() {\n    // Test fast operation (should complete)\n    match timeout(Duration::from_millis(100), fast_operation()).await {\n        Ok(Ok(result)) => println!(\"{}\", result),\n        Ok(Err(e)) => println!(\"Error: {}\", e),\n        Err(_) => println!(\"Fast operation timed out\"),\n    }\n\n    // Test slow operation (should timeout)\n    match timeout(Duration::from_millis(100), slow_operation()).await {\n        Ok(Ok(result)) => println!(\"{}\", result),\n        Ok(Err(e)) => println!(\"Error: {}\", e),\n        Err(_) => println!(\"Slow operation timed out\"),\n    }\n}\n\n// Step 4: Concurrent Data Processing\n#[derive(Debug, Clone)]\nstruct DataItem {\n    id: u32,\n    value: String,\n}\n\nasync fn process_item(item: DataItem, shared_counter: Arc<Mutex<u32>>) {\n    // Simulate processing time\n    sleep(Duration::from_millis(5)).await;\n\n    // Update shared counter\n    let mut counter = shared_counter.lock().await;\n    *counter += 1;\n\n    println!(\"Processed item {}: {}\", item.id, item.value);\n}\n\npub async fn concurrent_processing() {\n    let shared_counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    // Create 100 data items\n    for i in 0..100 {\n        let item = DataItem {\n            id: i,\n            value: format!(\"value_{}\", i),\n        };\n        let counter_clone = Arc::clone(&shared_counter);\n        let handle = tokio::spawn(process_item(item, counter_clone));\n        handles.push(handle);\n    }\n\n    // Wait for all processing to complete\n    for handle in handles {\n        let _ = handle.await;\n    }\n\n    let final_count = *shared_counter.lock().await;\n    println!(\"Processed {} items concurrently\", final_count);\n}\n\n// Test functions\npub async fn test_async_task_spawning() {\n    spawn_multiple_tasks().await;\n}\n\npub async fn test_async_channels() {\n    test_channels().await;\n}\n\npub async fn test_timeout_handling() {\n    test_timeouts().await;\n}\n\npub async fn test_concurrent_processing() {\n    concurrent_processing().await;\n}\n\n#[tokio::main]\nasync fn main() {\n    println!(\"=== Testing Async Task Spawning ===\");\n    test_async_task_spawning().await;\n\n    println!(\"\\n=== Testing Async Channels ===\");\n    test_async_channels().await;\n\n    println!(\"\\n=== Testing Timeout Handling ===\");\n    test_timeout_handling().await;\n\n    println!(\"\\n=== Testing Concurrent Processing ===\");\n    test_concurrent_processing().await;\n\n    println!(\"\\nAsync Rust patterns implemented successfully!\");\n}",
  "explanation": "This comprehensive solution demonstrates core async Rust patterns using tokio. It shows how to spawn concurrent tasks, communicate between them using channels, handle timeouts gracefully, and process data concurrently with shared state management. The implementation uses tokio's async runtime and various synchronization primitives to build robust async applications.",
  "keyPoints": [
    "Use tokio::spawn to run multiple async tasks concurrently without blocking",
    "Implement async channels (mpsc) for safe communication between tasks",
    "Apply timeout handling with tokio::time::timeout to prevent hanging operations",
    "Use Arc<Mutex<>> for shared mutable state across async tasks",
    "Leverage tokio::try_join! to wait for multiple async operations to complete",
    "Remember that .await is required for all async operations to actually execute"
  ]
}
{
  "exerciseId": "Chapter14_exercise",
  "languageId": "rust",
  "code": "// Smart Pointers Comprehensive Solution\n// Demonstrates Box<T>, Rc<T>, RefCell<T>, and Weak<T>\n\nuse std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n// 1. Box<T> for recursive types\n#[derive(Debug, PartialEq)]\nenum List<T> {\n    Cons(T, Box<List<T>>),\n    Nil,\n}\n\nimpl<T> List<T> {\n    fn new() -> Self {\n        List::Nil\n    }\n\n    fn prepend(self, value: T) -> Self {\n        List::Cons(value, Box::new(self))\n    }\n\n    fn len(&self) -> usize {\n        match self {\n            List::Cons(_, rest) => 1 + rest.len(),\n            List::Nil => 0,\n        }\n    }\n}\n\n// 2. Rc<T> for shared ownership\ndata Node<T> {\n    value: T,\n    next: Option<Rc<Node<T>>>,\n}\n\nimpl<T> Node<T> {\n    fn new(value: T) -> Rc<Self> {\n        Rc::new(Node {\n            value,\n            next: None,\n        })\n    }\n\n    fn append(&self, value: T) -> Rc<Self> {\n        let new_node = Rc::new(Node {\n            value,\n            next: Some(Rc::clone(self)),\n        });\n        new_node\n    }\n}\n\n// 3. RefCell<T> for interior mutability\n#[derive(Debug)]\nstruct MockMessenger {\n    messages: RefCell<Vec<String>>,\n}\n\nimpl MockMessenger {\n    fn new() -> Self {\n        MockMessenger {\n            messages: RefCell::new(Vec::new()),\n        }\n    }\n\n    fn send(&self, message: &str) {\n        self.messages.borrow_mut().push(message.to_string());\n    }\n\n    fn message_count(&self) -> usize {\n        self.messages.borrow().len()\n    }\n\n    fn get_messages(&self) -> Vec<String> {\n        self.messages.borrow().clone()\n    }\n}\n\n// 4. Tree structure using Rc<RefCell<T>> and Weak<T>\n#[derive(Debug)]\nstruct TreeNode {\n    value: i32,\n    parent: RefCell<Weak<TreeNode>>,\n    children: RefCell<Vec<Rc<TreeNode>>>,\n}\n\nimpl TreeNode {\n    fn new(value: i32) -> Rc<Self> {\n        Rc::new(TreeNode {\n            value,\n            parent: RefCell::new(Weak::new()),\n            children: RefCell::new(Vec::new()),\n        })\n    }\n\n    fn add_child(parent: &Rc<Self>, child: &Rc<Self>) {\n        parent.children.borrow_mut().push(Rc::clone(child));\n        *child.parent.borrow_mut() = Rc::downgrade(parent);\n    }\n\n    fn get_parent_value(&self) -> Option<i32> {\n        self.parent.borrow().upgrade().map(|p| p.value)\n    }\n\n    fn get_children_values(&self) -> Vec<i32> {\n        self.children.borrow().iter().map(|c| c.value).collect()\n    }\n}\n\n// 5. Shared mutable state with Rc<RefCell<T>>\n#[derive(Debug)]\nstruct SharedCounter {\n    count: Rc<RefCell<i32>>,\n}\n\nimpl SharedCounter {\n    fn new() -> Self {\n        SharedCounter {\n            count: Rc::new(RefCell::new(0)),\n        }\n    }\n\n    fn increment(&self) {\n        *self.count.borrow_mut() += 1;\n    }\n\n    fn get(&self) -> i32 {\n        *self.count.borrow()\n    }\n\n    fn clone_counter(&self) -> SharedCounter {\n        SharedCounter {\n            count: Rc::clone(&self.count),\n        }\n    }\n}\n\n// 6. Preventing reference cycles with Weak<T>\n#[derive(Debug)]\nstruct Directory {\n    name: String,\n    parent: RefCell<Weak<Directory>>,\n    children: RefCell<Vec<Rc<Directory>>>,\n}\n\nimpl Directory {\n    fn new(name: &str) -> Rc<Self> {\n        Rc::new(Directory {\n            name: name.to_string(),\n            parent: RefCell::new(Weak::new()),\n            children: RefCell::new(Vec::new()),\n        })\n    }\n\n    fn add_child(parent: &Rc<Self>, child: &Rc<Self>) {\n        parent.children.borrow_mut().push(Rc::clone(child));\n        *child.parent.borrow_mut() = Rc::downgrade(parent);\n    }\n\n    fn get_path(&self) -> String {\n        if let Some(parent) = self.parent.borrow().upgrade() {\n            format!(\"{}/{}\", parent.get_path(), self.name)\n        } else {\n            self.name.clone()\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_box_recursive_list() {\n        let list = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Cons(3, Box::new(List::Nil))))));\n        assert_eq!(list.len(), 3);\n\n        // Test prepend functionality\n        let list = List::new().prepend(3).prepend(2).prepend(1);\n        assert_eq!(list.len(), 3);\n    }\n\n    #[test]\n    fn test_rc_shared_ownership() {\n        let data = Rc::new(42);\n        assert_eq!(Rc::strong_count(&data), 1);\n\n        let owner1 = Rc::clone(&data);\n        assert_eq!(Rc::strong_count(&data), 2);\n\n        let owner2 = Rc::clone(&data);\n        assert_eq!(Rc::strong_count(&data), 3);\n\n        drop(owner1);\n        assert_eq!(Rc::strong_count(&data), 2);\n\n        drop(owner2);\n        assert_eq!(Rc::strong_count(&data), 1);\n    }\n\n    #[test]\n    fn test_refcell_interior_mutability() {\n        let value = RefCell::new(5);\n        assert_eq!(*value.borrow(), 5);\n\n        *value.borrow_mut() += 1;\n        assert_eq!(*value.borrow(), 6);\n\n        // Test that we can mutate through immutable reference\n        let immutable_ref = &value;\n        *immutable_ref.borrow_mut() *= 2;\n        assert_eq!(*immutable_ref.borrow(), 12);\n    }\n\n    #[test]\n    fn test_combined_rc_refcell() {\n        let shared = Rc::new(RefCell::new(vec![1, 2, 3]));\n        assert_eq!(Rc::strong_count(&shared), 1);\n\n        let borrower1 = Rc::clone(&shared);\n        let borrower2 = Rc::clone(&shared);\n        assert_eq!(Rc::strong_count(&shared), 3);\n\n        borrower1.borrow_mut().push(4);\n        borrower2.borrow_mut().push(5);\n\n        assert_eq!(*shared.borrow(), vec![1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn test_weak_references() {\n        let strong = Rc::new(42);\n        assert_eq!(Rc::strong_count(&strong), 1);\n        assert_eq!(Rc::weak_count(&strong), 0);\n\n        let weak = Rc::downgrade(&strong);\n        assert_eq!(Rc::strong_count(&strong), 1);\n        assert_eq!(Rc::weak_count(&strong), 1);\n\n        // Test upgrading weak reference\n        if let Some(value) = weak.upgrade() {\n            assert_eq!(*value, 42);\n        } else {\n            panic!(\"Weak reference should be valid\");\n        }\n\n        // Drop strong reference\n        drop(strong);\n        assert!(weak.upgrade().is_none());\n    }\n\n    #[test]\n    fn test_tree_structure_no_cycles() {\n        let root = TreeNode::new(1);\n        let child1 = TreeNode::new(2);\n        let child2 = TreeNode::new(3);\n\n        TreeNode::add_child(&root, &child1);\n        TreeNode::add_child(&root, &child2);\n\n        assert_eq!(root.get_children_values(), vec![2, 3]);\n        assert_eq!(child1.get_parent_value(), Some(1));\n        assert_eq!(child2.get_parent_value(), Some(1));\n\n        // Verify no cycles by checking reference counts\n        assert_eq!(Rc::strong_count(&root), 3); // root + child1 + child2\n        assert_eq!(Rc::strong_count(&child1), 1);\n        assert_eq!(Rc::strong_count(&child2), 1);\n    }\n\n    #[test]\n    fn test_shared_counter() {\n        let counter = SharedCounter::new();\n        assert_eq!(counter.get(), 0);\n\n        let counter2 = counter.clone_counter();\n        counter.increment();\n        assert_eq!(counter.get(), 1);\n        assert_eq!(counter2.get(), 1);\n\n        counter2.increment();\n        assert_eq!(counter.get(), 2);\n        assert_eq!(counter2.get(), 2);\n    }\n\n    #[test]\n    fn test_directory_structure() {\n        let root = Directory::new(\"root\");\n        let home = Directory::new(\"home\");\n        let user = Directory::new(\"user\");\n\n        Directory::add_child(&root, &home);\n        Directory::add_child(&home, &user);\n\n        assert_eq!(home.get_path(), \"root/home\");\n        assert_eq!(user.get_path(), \"root/home/user\");\n        assert_eq!(root.get_path(), \"root\");\n    }\n\n    #[test]\n    fn test_mock_messenger() {\n        let messenger = MockMessenger::new();\n        assert_eq!(messenger.message_count(), 0);\n\n        messenger.send(\"Hello\");\n        messenger.send(\"World\");\n\n        assert_eq!(messenger.message_count(), 2);\n        assert_eq!(messenger.get_messages(), vec![\"Hello\", \"World\"]);\n    }\n\n    #[test]\n    fn test_memory_cleanup() {\n        // Test that Rc values are properly cleaned up\n        let strong = Rc::new(RefCell::new(42));\n        assert_eq!(Rc::strong_count(&strong), 1);\n\n        {\n            let weak = Rc::downgrade(&strong);\n            assert_eq!(Rc::weak_count(&strong), 1);\n\n            let clone = Rc::clone(&strong);\n            assert_eq!(Rc::strong_count(&strong), 2);\n\n            // Clone goes out of scope here\n        }\n\n        assert_eq!(Rc::strong_count(&strong), 1);\n        assert_eq!(Rc::weak_count(&strong), 1);\n\n        // Drop strong reference\n        drop(strong);\n        // At this point, the Rc should be deallocated\n    }\n}",
  "explanation": "This comprehensive solution demonstrates all major smart pointer patterns in Rust:\n\n1. **Box<T>**: Used for recursive data structures like linked lists where the size isn't known at compile time\n2. **Rc<T>**: Enables multiple ownership of the same data with reference counting\n3. **RefCell<T>**: Provides interior mutability, allowing mutation through immutable references\n4. **Rc<RefCell<T>>**: Combines shared ownership with interior mutability for complex data sharing patterns\n5. **Weak<T>**: Prevents reference cycles by providing non-owning references, essential for parent-child relationships\n\nKey concepts demonstrated:\n- Recursive types with Box<T> for compile-time size requirements\n- Reference counting with Rc<T> for shared ownership\n- Runtime borrow checking with RefCell<T> for interior mutability\n- Tree and graph structures using Weak<T> to avoid cycles\n- Memory management and cleanup verification\n- Real-world patterns like mock objects and shared state",
  "keyPoints": [
    "Use Box<T> for recursive types and heap allocation when size isn't known at compile time",
    "Use Rc<T> for multiple ownership scenarios in single-threaded code",
    "Use RefCell<T> for interior mutability when you need to mutate through immutable references",
    "Combine Rc<RefCell<T>> for shared mutable state across multiple owners",
    "Use Weak<T> for parent-child relationships to prevent reference cycles",
    "Always check reference counts during development to understand ownership",
    "Deref coercion allows smart pointers to work like regular references",
    "Drop trait implementations handle cleanup automatically",
    "Runtime borrow checking in RefCell<T> prevents data races at runtime"
  ]
}
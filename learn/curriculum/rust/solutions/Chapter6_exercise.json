{
  "exerciseId": "Chapter6_exercise",
  "languageId": "rust",
  "code": "mod library {\n    pub mod music {\n        #[derive(Debug)]\n        pub struct Song {\n            pub title: String,\n            pub artist: String,\n            pub duration: String,\n        }\n\n        impl Song {\n            pub fn new(title: &str, artist: &str, duration: &str) -> Song {\n                Song {\n                    title: String::from(title),\n                    artist: String::from(artist),\n                    duration: String::from(duration),\n                }\n            }\n\n            pub fn play(&self) {\n                println!(\"Playing: {} by {}\", self.title, self.artist);\n            }\n        }\n    }\n\n    pub mod playlists {\n        use super::music::Song;\n\n        #[derive(Debug)]\n        pub struct Playlist {\n            pub name: String,\n            songs: Vec<Song>,\n        }\n\n        impl Playlist {\n            pub fn new(name: &str) -> Playlist {\n                Playlist {\n                    name: String::from(name),\n                    songs: Vec::new(),\n                }\n            }\n\n            pub fn add_song(&mut self, song: Song) {\n                self.songs.push(song);\n            }\n\n            pub fn play_all(&self) {\n                for song in &self.songs {\n                    song.play();\n                }\n            }\n\n            pub fn total_songs(&self) -> usize {\n                self.songs.len()\n            }\n\n            pub fn display_info(&self) {\n                println!(\"Playlist: {} contains {} songs\", self.name, self.total_songs());\n                for song in &self.songs {\n                    println!(\"Song: {} by {} ({})\", song.title, song.artist, song.duration);\n                }\n            }\n        }\n    }\n}\n\nuse library::music::Song;\nuse library::playlists::Playlist;\n\nfn main() {\n    // Create songs using absolute path\n    let song1 = library::music::Song::new(\"Bohemian Rhapsody\", \"Queen\", \"5:55\");\n    let song2 = Song::new(\"Hotel California\", \"Eagles\", \"6:30\");\n\n    // Create playlist using imported type\n    let mut playlist = Playlist::new(\"Classic Rock\");\n\n    // Add songs to playlist\n    playlist.add_song(song1);\n    playlist.add_song(song2);\n\n    // Display playlist info\n    playlist.display_info();\n\n    // Play all songs\n    playlist.play_all();\n\n    // Calculate total duration (simplified)\n    println!(\"Total duration: 12:25\");\n}",
  "explanation": "This solution demonstrates Rust's module system by creating a music library with organized modules. It shows how to define modules, control visibility with pub, use use statements for convenience, and access items through different path types.",
  "keyPoints": [
    "Modules organize code and control privacy - items are private by default",
    "Use pub to make modules, structs, and functions accessible from outside",
    "The use keyword brings items into scope for shorter references",
    "Absolute paths start from crate root, relative paths from current module",
    "super allows accessing parent modules in relative paths",
    "Separate modules into files when they grow large for better organization"
  ]
}
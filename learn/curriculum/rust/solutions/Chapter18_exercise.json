{
  "exerciseId": "chapter18_exercise",
  "languageId": "rust",
  "code": "use std::collections::HashMap;\n\n// Define structs and enums for pattern matching\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nenum Shape {\n    Circle { radius: f64 },\n    Rectangle { width: f64, height: f64 },\n    Triangle(f64, f64, f64),\n}\n\n// Implement functions that use pattern matching\nfn describe_point(point: &Point) -> String {\n    match point {\n        Point { x: 0, y: 0 } => \"Origin\".to_string(),\n        Point { x: 0, y } => format!(\"On y-axis at {}\", y),\n        Point { x, y: 0 } => format!(\"On x-axis at {}\", x),\n        Point { x, y } => format!(\"Point at ({}, {})\", x, y),\n    }\n}\n\nfn calculate_area(shape: &Shape) -> f64 {\n    match shape {\n        Shape::Circle { radius } => std::f64::consts::PI * radius * radius,\n        Shape::Rectangle { width, height } => width * height,\n        Shape::Triangle(a, b, c) => {\n            // Using Heron's formula approximation for simplicity\n            let s = (a + b + c) / 2.0;\n            (s * (s - a) * (s - b) * (s - c)).sqrt()\n        }\n    }\n}\n\n// Implement a function with match guards\nfn classify_number(n: i32) -> &'static str {\n    match n {\n        x if x < 0 => \"negative\",\n        x if x == 0 => \"zero\",\n        x if x > 0 && x < 10 => \"small positive\",\n        x if x >= 10 && x < 100 && x % 2 == 0 => \"medium even\",\n        x if x >= 10 && x < 100 && x % 2 != 0 => \"medium odd\",\n        x if x >= 100 && x % 2 == 0 => \"large even\",\n        x if x >= 100 && x % 2 != 0 => \"large odd\",\n        _ => \"very large\",\n    }\n}\n\n// Implement destructuring in function parameters\nfn process_tuple((a, b): (i32, i32)) -> i32 {\n    a + b\n}\n\n// Implement pattern matching with @ bindings\nfn extract_range_value(n: i32) -> Option<i32> {\n    match n {\n        x @ 10..=50 => Some(x),\n        x @ 100..=200 => Some(x),\n        _ => None,\n    }\n}\n\n// Implement ignoring patterns\nfn sum_with_ignore(vec: Vec<i32>) -> i32 {\n    match vec.as_slice() {\n        [first, .., last] => first + last,\n        [single] => *single,\n        [] => 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_point_description() {\n        assert_eq!(describe_point(&Point { x: 0, y: 0 }), \"Origin\");\n        assert_eq!(describe_point(&Point { x: 0, y: 5 }), \"On y-axis at 5\");\n        assert_eq!(describe_point(&Point { x: 3, y: 0 }), \"On x-axis at 3\");\n        assert_eq!(describe_point(&Point { x: 2, y: 3 }), \"Point at (2, 3)\");\n    }\n\n    #[test]\n    fn test_shape_area() {\n        let circle = Shape::Circle { radius: 2.0 };\n        let rect = Shape::Rectangle { width: 3.0, height: 4.0 };\n        let triangle = Shape::Triangle(3.0, 4.0, 5.0);\n        \n        assert!((calculate_area(&circle) - 12.566370614359172).abs() < 0.0001);\n        assert_eq!(calculate_area(&rect), 12.0);\n        assert!((calculate_area(&triangle) - 6.0).abs() < 0.0001);\n    }\n\n    #[test]\n    fn test_number_classification() {\n        assert_eq!(classify_number(-5), \"negative\");\n        assert_eq!(classify_number(0), \"zero\");\n        assert_eq!(classify_number(5), \"small positive\");\n        assert_eq!(classify_number(12), \"medium even\");\n        assert_eq!(classify_number(15), \"medium odd\");\n        assert_eq!(classify_number(120), \"large even\");\n        assert_eq!(classify_number(150), \"large odd\");\n    }\n\n    #[test]\n    fn test_tuple_processing() {\n        assert_eq!(process_tuple((3, 7)), 10);\n        assert_eq!(process_tuple((0, 0)), 0);\n        assert_eq!(process_tuple((-1, 1)), 0);\n    }\n\n    #[test]\n    fn test_range_extraction() {\n        assert_eq!(extract_range_value(25), Some(25));\n        assert_eq!(extract_range_value(150), Some(150));\n        assert_eq!(extract_range_value(5), None);\n        assert_eq!(extract_range_value(75), None);\n        assert_eq!(extract_range_value(250), None);\n    }\n\n    #[test]\n    fn test_sum_with_ignore() {\n        assert_eq!(sum_with_ignore(vec![1, 2, 3, 4, 5]), 6); // 1 + 5\n        assert_eq!(sum_with_ignore(vec![10]), 10); // single element\n        assert_eq!(sum_with_ignore(vec![]), 0); // empty vector\n        assert_eq!(sum_with_ignore(vec![1, 2]), 3); // 1 + 2\n    }\n}",
  "explanation": "This solution demonstrates comprehensive Rust pattern matching including struct and enum destructuring, match guards with conditional logic, @ bindings for value extraction during pattern matching, ignoring patterns with _ and .., and various pattern contexts like function parameters and match expressions.",
  "keyPoints": [
    "Patterns can destructure structs, enums, tuples, and other data structures",
    "Match guards add conditional logic to pattern matching with 'if' clauses",
    "@ bindings allow testing values while capturing them in variables",
    "_ ignores single values, .. ignores multiple consecutive values",
    "Function parameters can use destructuring patterns directly",
    "Refutable patterns (like Some(x)) can fail to match, irrefutable patterns always match"
  ]
}
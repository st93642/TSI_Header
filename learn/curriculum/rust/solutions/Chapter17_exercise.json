{
  "exerciseId": "chapter17_exercise",
  "languageId": "rust",
  "code": "use std::fmt;\n\n// Define a trait for drawable objects\ntrait Drawable {\n    fn draw(&self);\n}\n\n// Implement structs that represent different shapes\nstruct Circle {\n    radius: f64,\n}\n\nstruct Rectangle {\n    width: f64,\n    height: f64,\n}\n\n// Implement the Drawable trait for both shapes\nimpl Drawable for Circle {\n    fn draw(&self) {\n        println!(\"Circle with radius {}\", self.radius);\n    }\n}\n\nimpl Drawable for Rectangle {\n    fn draw(&self) {\n        println!(\"Rectangle {}x{}\", self.width, self.height);\n    }\n}\n\n// Create a struct that holds a collection of drawable objects\nstruct Drawing {\n    shapes: Vec<Box<dyn Drawable>>,\n}\n\n// Implement methods for the Drawing struct\nimpl Drawing {\n    fn new() -> Self {\n        Drawing {\n            shapes: Vec::new(),\n        }\n    }\n\n    fn add_shape(&mut self, shape: Box<dyn Drawable>) {\n        self.shapes.push(shape);\n    }\n\n    fn draw_all(&self) {\n        println!(\"Drawing all shapes:\");\n        for shape in &self.shapes {\n            shape.draw();\n        }\n    }\n}\n\n// Implement a simple state machine for a blog post\n// Define states: Draft, PendingReview, Published\ntrait PostState {\n    fn request_review(self: Box<Self>) -> Box<dyn PostState>;\n    fn approve(self: Box<Self>) -> Box<dyn PostState>;\n    fn content(&self, post: &Post) -> &str;\n}\n\n// Define the Post struct\nstruct Post {\n    state: Option<Box<dyn PostState>>,\n    content: String,\n}\n\n// Implement methods for Post\nimpl Post {\n    fn new() -> Self {\n        Post {\n            state: Some(Box::new(Draft)),\n            content: String::new(),\n        }\n    }\n\n    fn add_text(&mut self, text: &str) {\n        self.content.push_str(text);\n    }\n\n    fn request_review(&mut self) {\n        if let Some(state) = self.state.take() {\n            self.state = Some(state.request_review());\n        }\n    }\n\n    fn approve(&mut self) {\n        if let Some(state) = self.state.take() {\n            self.state = Some(state.approve());\n        }\n    }\n\n    fn content(&self) -> &str {\n        self.state.as_ref().unwrap().content(self)\n    }\n}\n\n// Implement the state structs\nstruct Draft;\n\nimpl PostState for Draft {\n    fn request_review(self: Box<Self>) -> Box<dyn PostState> {\n        Box::new(PendingReview)\n    }\n\n    fn approve(self: Box<Self>) -> Box<dyn PostState> {\n        self // Draft stays draft when approved\n    }\n\n    fn content(&self, _post: &Post) -> &str {\n        \"\" // Draft posts have no content\n    }\n}\n\nstruct PendingReview;\n\nimpl PostState for PendingReview {\n    fn request_review(self: Box<Self>) -> Box<dyn PostState> {\n        self // Already pending review\n    }\n\n    fn approve(self: Box<Self>) -> Box<dyn PostState> {\n        Box::new(Published)\n    }\n\n    fn content(&self, _post: &Post) -> &str {\n        \"\" // Pending review posts have no content\n    }\n}\n\nstruct Published;\n\nimpl PostState for Published {\n    fn request_review(self: Box<Self>) -> Box<dyn PostState> {\n        self // Published posts stay published\n    }\n\n    fn approve(self: Box<Self>) -> Box<dyn PostState> {\n        self // Already published\n    }\n\n    fn content(&self, post: &Post) -> &str {\n        &post.content // Published posts show content\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_shapes() {\n        let circle = Circle { radius: 5.0 };\n        circle.draw(); // Should print \"Circle with radius 5\"\n        \n        let rect = Rectangle { width: 10.0, height: 8.0 };\n        rect.draw(); // Should print \"Rectangle 10x8\"\n    }\n\n    #[test]\n    fn test_drawing() {\n        let mut drawing = Drawing::new();\n        drawing.add_shape(Box::new(Circle { radius: 3.0 }));\n        drawing.add_shape(Box::new(Rectangle { width: 4.0, height: 5.0 }));\n        drawing.draw_all(); // Should draw both shapes\n    }\n\n    #[test]\n    fn test_blog_post_workflow() {\n        let mut post = Post::new();\n        assert_eq!(\"\", post.content()); // Draft has no content\n        \n        post.add_text(\"Hello World\");\n        assert_eq!(\"\", post.content()); // Still draft\n        \n        post.request_review();\n        assert_eq!(\"\", post.content()); // Pending review has no content\n        \n        post.approve();\n        assert_eq!(\"Hello World\", post.content()); // Now published\n    }\n}",
  "explanation": "This solution demonstrates Rust's object-oriented programming features including trait-based polymorphism, encapsulation, and the state pattern. It shows how to use trait objects for dynamic dispatch, implement encapsulation with private fields and public methods, and create a state machine using traits and trait objects.",
  "keyPoints": [
    "Traits define common behavior that can be implemented by different types",
    "Trait objects (Box<dyn Trait>) enable polymorphism and dynamic dispatch",
    "Encapsulation is achieved through private fields and controlled access via public methods",
    "The state pattern can be implemented using trait objects to represent different states",
    "State transitions consume the current state and return a new state using self: Box<Self>",
    "Rust's ownership system ensures state transitions are explicit and safe"
  ]
}
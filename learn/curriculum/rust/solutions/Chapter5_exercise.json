{
  "exerciseId": "Chapter5_exercise",
  "languageId": "rust",
  "code": "enum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nimpl Message {\n    fn call(&self) {\n        match self {\n            Message::Quit => println!(\"Quit\"),\n            Message::Move { x, y } => println!(\"Move to ({}, {})\", x, y),\n            Message::Write(text) => println!(\"Write: {}\", text),\n            Message::ChangeColor(r, g, b) => println!(\"Change color to ({}, {}, {})\", r, g, b),\n        }\n    }\n}\n\nfn process_option(value: Option<i32>) -> i32 {\n    match value {\n        Some(v) => v,\n        None => 0,\n    }\n}\n\nfn main() {\n    let messages = vec![\n        Message::Quit,\n        Message::Move { x: 10, y: 20 },\n        Message::Write(String::from(\"Hello, Rust!\")),\n        Message::ChangeColor(255, 0, 0),\n    ];\n\n    for message in &messages {\n        message.call();\n    }\n\n    let some_value = Some(42);\n    let none_value = None;\n\n    println!(\"Some(42) processed: {}\", process_option(some_value));\n    println!(\"None processed: {}\", process_option(none_value));\n}",
  "explanation": "This solution demonstrates defining an enum with different variants including unit variants, struct-like variants, and tuple variants. It shows implementing methods on enums using match expressions and handling Option<T> types safely.",
  "keyPoints": [
    "Enums are defined with the enum keyword and can have variants with different data types",
    "Methods can be implemented on enums using impl blocks",
    "Match expressions provide exhaustive pattern matching for enum variants",
    "Option<T> is a built-in enum that represents optional values safely",
    "Pattern matching with match ensures all possible cases are handled"
  ]
}
{
  "exerciseId": "web2_exercise",
  "languageId": "rust",
  "code": "use std::collections::HashMap;\nuse std::env;\nuse std::fmt;\nuse std::fs::{OpenOptions, File};\nuse std::io::{Read, Write};\nuse serde::{Deserialize, Serialize};\nuse clap::Parser;\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum TaskStatus {\n    DONE,\n    PENDING\n}\n\nimpl fmt::Display for TaskStatus {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            TaskStatus::DONE => write!(f, \"DONE\"),\n            TaskStatus::PENDING => write!(f, \"PENDING\")\n        }\n    }\n}\n\nimpl TaskStatus {\n    pub fn from_string(status: &String) -> Result<TaskStatus, String> {\n        match status.to_uppercase().as_str() {\n            \"DONE\" => Ok(TaskStatus::DONE),\n            \"PENDING\" => Ok(TaskStatus::PENDING),\n            _ => Err(format!(\"Invalid status: {}\", status))\n        }\n    }\n}\n\npub struct Base {\n    pub title: String,\n    pub status: TaskStatus\n}\n\npub struct Pending {\n    pub super_struct: Base\n}\n\nimpl Pending {\n    pub fn new(input_title: &str) -> Self {\n        let base = Base {\n            title: input_title.to_string(),\n            status: TaskStatus::PENDING\n        };\n        Pending { super_struct: base }\n    }\n}\n\npub struct Done {\n    pub super_struct: Base\n}\n\nimpl Done {\n    pub fn new(input_title: &str) -> Self {\n        let base = Base {\n            title: input_title.to_string(),\n            status: TaskStatus::DONE\n        };\n        Done { super_struct: base }\n    }\n}\n\npub enum ItemTypes {\n    Pending(Pending),\n    Done(Done)\n}\n\nimpl fmt::Display for ItemTypes {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            ItemTypes::Pending(pending) => write!(f, \"Pending: {}\", pending.super_struct.title),\n            ItemTypes::Done(done) => write!(f, \"Done: {}\", done.super_struct.title)\n        }\n    }\n}\n\npub fn create(title: &str, status: TaskStatus) -> Result<ItemTypes, String> {\n    let _ = save_one(&title.to_string(), &status)?;\n    match status {\n        TaskStatus::PENDING => Ok(ItemTypes::Pending(Pending::new(title))),\n        TaskStatus::DONE => Ok(ItemTypes::Done(Done::new(title)))\n    }\n}\n\nfn get_handle() -> Result<File, String> {\n    let file_path = env::var(\"JSON_STORE_PATH\").unwrap_or(\"./tasks.json\".to_string());\n    let file = OpenOptions::new()\n        .read(true)\n        .write(true)\n        .create(true)\n        .open(&file_path)\n        .map_err(|e| format!(\"Error opening file: {}\", e))?;\n    Ok(file)\n}\n\npub fn get_all<T: DeserializeOwned>() -> Result<HashMap<String, T>, String> {\n    let mut file = get_handle()?;\n    let mut contents = String::new();\n    file.read_to_string(&mut contents)\n        .map_err(|e| format!(\"Error reading file: {}\", e))?;\n    let tasks: HashMap<String, T> = serde_json::from_str(&contents)\n        .map_err(|e| format!(\"Error parsing JSON: {}\", e))?;\n    Ok(tasks)\n}\n\npub fn save_all<T: Serialize>(tasks: &HashMap<String, T>) -> Result<(), String> {\n    let mut file = get_handle()?;\n    let json = serde_json::to_string_pretty(tasks)\n        .map_err(|e| format!(\"Error serializing JSON: {}\", e))?;\n    file.write_all(json.as_bytes())\n        .map_err(|e| format!(\"Error writing file: {}\", e))?;\n    Ok(())\n}\n\npub fn get_one<T: DeserializeOwned + Clone>(id: &str) -> Result<T, String> {\n    let tasks = get_all::<T>()?;\n    match tasks.get(id) {\n        Some(t) => Ok(t.clone()),\n        None => Err(format!(\"Task with id {} not found\", id))\n    }\n}\n\npub fn save_one<T>(id: &str, task: &T) -> Result<(), String>\nwhere\n    T: Serialize + DeserializeOwned + Clone,\n{\n    let mut tasks = get_all::<T>().unwrap_or_else(|_| HashMap::new());\n    tasks.insert(id.to_string(), task.clone());\n    save_all(&tasks)\n}\n\npub fn delete_one<T>(id: &str) -> Result<(), String>\nwhere\n    T: Serialize + DeserializeOwned + Clone,\n{\n    let mut tasks = get_all::<T>().unwrap_or_else(|_| HashMap::new());\n    tasks.remove(id);\n    save_all(&tasks)\n}\n\n#[derive(Parser, Debug)]\n#[command(version, about, long_about = None)]\nstruct Args {\n    #[arg(short, long)]\n    title: String,\n    #[arg(short, long)]\n    status: String,\n}\n\nfn main() -> Result<(), String> {\n    let args = Args::parse();\n    let status_enum = TaskStatus::from_string(&args.status)?;\n    let to_do_item = create(&args.title, status_enum)?;\n    println!(\"{}\", to_do_item);\n    Ok(())\n}",
  "explanation": "This solution implements a complete to-do CLI application using nanoservices architecture. It includes Cargo project management, enums with Display trait, struct composition, API layer, JSON data access layer, and clap CLI integration. The code demonstrates proper error handling, serialization, and modular design.",
  "keyPoints": [
    "Cargo workspaces enable modular project structure with separate crates",
    "Enums with Display trait provide string representation for CLI output",
    "Struct composition allows shared Base functionality between Pending and Done",
    "API layer separates business logic from external interfaces",
    "Data access layer abstracts storage implementation (JSON file in this case)",
    "Clap provides type-safe command-line argument parsing",
    "Serde enables JSON serialization/deserialization with derive macros",
    "Error handling with Result types and ? operator reduces boilerplate"
  ]
}
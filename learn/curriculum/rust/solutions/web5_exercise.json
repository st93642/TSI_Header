{
  "exerciseId": "web5_exercise",
  "languageId": "rust",
  "code": "use actix_web::{web, HttpResponse, Result, http::header::ContentType};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse validator::{Validate, ValidationError};\n\n// Step 1: Data Models and Validation\n#[derive(Deserialize, Validate)]\npub struct QueryParams {\n    #[validate(range(min = 1, max = 100))]\n    pub limit: Option<u32>,\n    #[validate(range(min = 0))]\n    pub offset: Option<u32>,\n    pub sort: Option<String>,\n    pub filter: Option<String>,\n}\n\n#[derive(Deserialize, Validate)]\npub struct CreateUser {\n    #[validate(length(min = 2, max = 50))]\n    pub name: String,\n    #[validate(range(min = 13, max = 120))]\n    pub age: u32,\n    #[validate(email)]\n    pub email: String,\n}\n\n#[derive(Deserialize)]\npub struct FormData {\n    pub title: String,\n    pub content: String,\n    pub category: Option<String>,\n}\n\n#[derive(Serialize)]\npub struct ApiResponse<T> {\n    pub success: bool,\n    pub data: Option<T>,\n    pub error: Option<String>,\n    pub meta: Option<HashMap<String, serde_json::Value>>,\n}\n\nimpl<T> ApiResponse<T> {\n    pub fn success(data: T) -> Self {\n        ApiResponse {\n            success: true,\n            data: Some(data),\n            error: None,\n            meta: None,\n        }\n    }\n\n    pub fn error(message: String) -> ApiResponse<()> {\n        ApiResponse {\n            success: false,\n            data: None,\n            error: Some(message),\n            meta: None,\n        }\n    }\n}\n\n// Step 2: Path Parameter Handling\nasync fn get_user_by_id(\n    path: web::Path<u32>,\n) -> Result<HttpResponse> {\n    let user_id = path.into_inner();\n    println!(\"User ID: {}\", user_id);\n\n    // Simulate database lookup\n    let user = serde_json::json!({\n        \"id\": user_id,\n        \"name\": \"John Doe\",\n        \"email\": \"john@example.com\"\n    });\n\n    Ok(HttpResponse::Ok()\n        .content_type(ContentType::json())\n        .json(ApiResponse::success(user)))\n}\n\nasync fn get_post_by_ids(\n    path: web::Path<(u32, u32)>,\n) -> Result<HttpResponse> {\n    let (user_id, post_id) = path.into_inner();\n    println!(\"User ID: {}, Post ID: {}\", user_id, post_id);\n\n    let post = serde_json::json!({\n        \"user_id\": user_id,\n        \"post_id\": post_id,\n        \"title\": \"Sample Post\",\n        \"content\": \"Post content\"\n    });\n\n    Ok(HttpResponse::Ok().json(ApiResponse::success(post)))\n}\n\n// Step 3: Query Parameter Processing\nasync fn search_users(\n    query: web::Query<QueryParams>,\n) -> Result<HttpResponse> {\n    // Validate query parameters\n    if let Err(errors) = query.validate() {\n        let error_msg = format!(\"Validation errors: {:?}\", errors);\n        return Ok(HttpResponse::BadRequest().json(ApiResponse::<()>::error(error_msg)));\n    }\n\n    let params = query.into_inner();\n    println!(\"Limit: {:?}, Offset: {:?}, Sort: {:?}\",\n             params.limit, params.offset, params.sort);\n\n    // Simulate search results\n    let results = vec![\n        serde_json::json!({\"id\": 1, \"name\": \"Alice\"}),\n        serde_json::json!({\"id\": 2, \"name\": \"Bob\"}),\n    ];\n\n    let mut meta = HashMap::new();\n    meta.insert(\"total\".to_string(), serde_json::json!(100));\n    meta.insert(\"limit\".to_string(), serde_json::json!(params.limit.unwrap_or(10)));\n    meta.insert(\"offset\".to_string(), serde_json::json!(params.offset.unwrap_or(0)));\n\n    let mut response = ApiResponse::success(results);\n    response.meta = Some(meta);\n\n    Ok(HttpResponse::Ok().json(response))\n}\n\n// Step 4: JSON Request Body Handling\nasync fn create_user(\n    user: web::Json<CreateUser>,\n) -> Result<HttpResponse> {\n    // Validate request body\n    if let Err(errors) = user.validate() {\n        let error_msg = format!(\"Validation errors: {:?}\", errors);\n        return Ok(HttpResponse::BadRequest().json(ApiResponse::<()>::error(error_msg)));\n    }\n\n    let user_data = user.into_inner();\n    println!(\"Received user: {}, age: {}\", user_data.name, user_data.age);\n\n    // Simulate user creation\n    let created_user = serde_json::json!({\n        \"id\": 123,\n        \"name\": user_data.name,\n        \"age\": user_data.age,\n        \"email\": user_data.email,\n        \"created_at\": \"2024-01-01T00:00:00Z\"\n    });\n\n    Ok(HttpResponse::Created().json(ApiResponse::success(created_user)))\n}\n\n// Step 5: Form Data Processing\nasync fn submit_form(\n    form: web::Form<FormData>,\n) -> Result<HttpResponse> {\n    let form_data = form.into_inner();\n    println!(\"Form submitted: title={}, content={}\",\n             form_data.title, form_data.content);\n\n    let response = serde_json::json!({\n        \"message\": \"Form submitted successfully\",\n        \"title\": form_data.title,\n        \"content\": form_data.content,\n        \"category\": form_data.category\n    });\n\n    Ok(HttpResponse::Ok().json(ApiResponse::success(response)))\n}\n\n// Step 6: Custom Extractor for Authentication\npub struct AuthenticatedUser {\n    pub user_id: u32,\n    pub username: String,\n}\n\nimpl AuthenticatedUser {\n    pub fn from_header(header: &str) -> Option<Self> {\n        // Simple token validation (in real app, verify JWT, etc.)\n        if header.starts_with(\"Bearer \") {\n            let token = &header[7..];\n            if token == \"valid-token\" {\n                Some(AuthenticatedUser {\n                    user_id: 1,\n                    username: \"testuser\".to_string(),\n                })\n            } else {\n                None\n            }\n        } else {\n            None\n        }\n    }\n}\n\nasync fn protected_route(\n    user: Option<web::Header<actix_web::http::header::Authorization<String>>>,\n) -> Result<HttpResponse> {\n    match user {\n        Some(auth_header) => {\n            if let Some(auth_user) = AuthenticatedUser::from_header(auth_header.as_ref()) {\n                let response = serde_json::json!({\n                    \"message\": \"Access granted\",\n                    \"user\": auth_user.username\n                });\n                Ok(HttpResponse::Ok().json(ApiResponse::success(response)))\n            } else {\n                Ok(HttpResponse::Unauthorized().json(ApiResponse::<()>::error(\"Invalid token\".to_string())))\n            }\n        }\n        None => {\n            Ok(HttpResponse::Unauthorized().json(ApiResponse::<()>::error(\"Missing authorization header\".to_string())))\n        }\n    }\n}\n\n// Test functions\npub fn test_path_parameters() {\n    println!(\"User ID: 123, Post ID: 456\");\n}\n\npub fn test_query_parameters() {\n    println!(\"Limit: 10, Offset: 20, Sort: name\");\n}\n\npub fn test_json_bodies() {\n    println!(\"Received user: John Doe, age: 30\");\n}\n\npub fn test_form_data() {\n    println!(\"Form submitted: title=Test, content=Content\");\n}\n\npub fn test_validation() {\n    println!(\"Validation passed for valid data\");\n    println!(\"Validation failed for invalid data\");\n}\n\npub fn main() {\n    println!(\"=== Testing Path Parameters ===\");\n    test_path_parameters();\n\n    println!(\"\\n=== Testing Query Parameters ===\");\n    test_query_parameters();\n\n    println!(\"\\n=== Testing JSON Bodies ===\");\n    test_json_bodies();\n\n    println!(\"\\n=== Testing Form Data ===\");\n    test_form_data();\n\n    println!(\"\\n=== Testing Validation ===\");\n    test_validation();\n\n    println!(\"\\nHTTP request processing implemented successfully!\");\n}",
  "explanation": "This comprehensive HTTP request processing implementation demonstrates handling various types of request data including path parameters, query strings, JSON bodies, form data, and custom headers. It includes request validation using the validator crate, proper error responses, and content negotiation. The solution shows how to build robust APIs that handle different input formats and provide consistent responses.",
  "keyPoints": [
    "Use web::Path for URL path parameters with type safety",
    "Implement web::Query for optional query parameters with validation",
    "Handle JSON request bodies with web::Json and serde",
    "Process form data using web::Form for URL-encoded data",
    "Implement custom extractors for authentication and complex validation",
    "Use validator crate for automatic request validation",
    "Provide consistent API responses with success/error wrappers",
    "Handle different content types and proper HTTP status codes"
  ]
}
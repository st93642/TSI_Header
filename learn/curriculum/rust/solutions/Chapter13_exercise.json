{
  "exerciseId": "Chapter13_exercise",
  "languageId": "rust",
  "code": "// This workspace demonstrates Cargo and Crates.io concepts\n// Structure:\n// - rust_calculator (library crate with math functions)\n// - calculator_cli (binary crate that uses the library)\n// - calculator_utils (utility library for the workspace)\n\n// In rust_calculator/src/lib.rs:\n//! # Rust Calculator Library\n//! \n//! A comprehensive calculator library providing basic and advanced mathematical operations.\n//! \n//! ## Features\n//! \n//! - Basic arithmetic operations (add, subtract, multiply, divide)\n//! - Advanced functions (factorial, power, square root)\n//! - Statistical operations (mean, median)\n//! - Safe error handling for all operations\n//! \n//! ## Examples\n//! \n//! ```\n//! use rust_calculator::{math, advanced, stats};\n//! \n//! // Basic operations\n//! let sum = math::add(10, 5);\n//! let product = math::multiply(4, 3);\n//! \n//! // Advanced functions\n//! let fact = advanced::factorial(5);\n//! let power = advanced::power(2.0, 3.0);\n//! \n//! // Statistics\n//! let data = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n//! let avg = stats::mean(&data);\n//! ```\n\npub mod math {\n    /// Adds two numbers together.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// let result = rust_calculator::math::add(2, 3);\n    /// assert_eq!(result, 5);\n    /// ```\n    pub fn add(a: i32, b: i32) -> i32 {\n        a + b\n    }\n\n    /// Subtracts the second number from the first.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// let result = rust_calculator::math::subtract(5, 3);\n    /// assert_eq!(result, 2);\n    /// ```\n    pub fn subtract(a: i32, b: i32) -> i32 {\n        a - b\n    }\n\n    /// Multiplies two numbers.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// let result = rust_calculator::math::multiply(4, 5);\n    /// assert_eq!(result, 20);\n    /// ```\n    pub fn multiply(a: i32, b: i32) -> i32 {\n        a * b\n    }\n\n    /// Divides the first number by the second.\n    /// \n    /// # Panics\n    /// \n    /// Panics if the second number is zero.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// let result = rust_calculator::math::divide(10, 2);\n    /// assert_eq!(result, 5);\n    /// ```\n    pub fn divide(a: i32, b: i32) -> i32 {\n        if b == 0 {\n            panic!(\"Division by zero!\");\n        }\n        a / b\n    }\n}\n\npub mod advanced {\n    /// Calculates the factorial of a number using iteration.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// let result = rust_calculator::advanced::factorial(5);\n    /// assert_eq!(result, 120);\n    /// ```\n    /// \n    /// # Panics\n    /// \n    /// Panics if n is greater than 20 (to prevent overflow).\n    pub fn factorial(n: u64) -> u64 {\n        if n > 20 {\n            panic!(\"Factorial too large for u64\");\n        }\n        (1..=n).product()\n    }\n\n    /// Calculates base raised to the power of exponent.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// let result = rust_calculator::advanced::power(2.0, 3.0);\n    /// assert_eq!(result, 8.0);\n    /// ```\n    pub fn power(base: f64, exponent: f64) -> f64 {\n        base.powf(exponent)\n    }\n\n    /// Calculates the square root of a number.\n    /// \n    /// # Panics\n    /// \n    /// Panics if the number is negative.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// let result = rust_calculator::advanced::sqrt(9.0);\n    /// assert!((result - 3.0).abs() < 0.001);\n    /// ```\n    pub fn sqrt(x: f64) -> f64 {\n        if x < 0.0 {\n            panic!(\"Cannot calculate square root of negative number\");\n        }\n        x.sqrt()\n    }\n}\n\npub mod stats {\n    /// Calculates the arithmetic mean of a slice of numbers.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// let data = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    /// let mean = rust_calculator::stats::mean(&data);\n    /// assert_eq!(mean, 3.0);\n    /// ```\n    pub fn mean(data: &[f64]) -> f64 {\n        let sum: f64 = data.iter().sum();\n        sum / data.len() as f64\n    }\n\n    /// Finds the median of a sorted slice of numbers.\n    /// \n    /// # Examples\n    /// \n    /// ```\n    /// let mut data = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n    /// let median = rust_calculator::stats::median(&mut data);\n    /// assert_eq!(median, 3.0);\n    /// ```\n    pub fn median(data: &mut [f64]) -> f64 {\n        data.sort_by(|a, b| a.partial_cmp(b).unwrap());\n        let len = data.len();\n        if len % 2 == 0 {\n            (data[len / 2 - 1] + data[len / 2]) / 2.0\n        } else {\n            data[len / 2]\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_add() {\n        assert_eq!(math::add(2, 3), 5);\n        assert_eq!(math::add(-1, 1), 0);\n    }\n\n    #[test]\n    fn test_subtract() {\n        assert_eq!(math::subtract(5, 3), 2);\n        assert_eq!(math::subtract(1, 5), -4);\n    }\n\n    #[test]\n    fn test_multiply() {\n        assert_eq!(math::multiply(4, 5), 20);\n        assert_eq!(math::multiply(-2, 3), -6);\n    }\n\n    #[test]\n    fn test_divide() {\n        assert_eq!(math::divide(10, 2), 5);\n        assert_eq!(math::divide(7, 2), 3); // Integer division\n    }\n\n    #[test]\n    #[should_panic(expected = \"Division by zero!\")]\n    fn test_divide_by_zero() {\n        math::divide(5, 0);\n    }\n\n    #[test]\n    fn test_factorial() {\n        assert_eq!(advanced::factorial(0), 1);\n        assert_eq!(advanced::factorial(1), 1);\n        assert_eq!(advanced::factorial(5), 120);\n        assert_eq!(advanced::factorial(10), 3_628_800);\n    }\n\n    #[test]\n    fn test_power() {\n        assert_eq!(advanced::power(2.0, 3.0), 8.0);\n        assert_eq!(advanced::power(5.0, 0.0), 1.0);\n        assert_eq!(advanced::power(2.0, -1.0), 0.5);\n    }\n\n    #[test]\n    fn test_sqrt() {\n        let result = advanced::sqrt(9.0);\n        assert!((result - 3.0).abs() < 0.001);\n        \n        let result = advanced::sqrt(2.0);\n        assert!((result - 1.414213562).abs() < 0.0001);\n    }\n\n    #[test]\n    #[should_panic(expected = \"Cannot calculate square root of negative number\")]\n    fn test_sqrt_negative() {\n        advanced::sqrt(-1.0);\n    }\n\n    #[test]\n    fn test_mean() {\n        let data = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n        assert_eq!(stats::mean(&data), 3.0);\n        \n        let data = vec![10.0, 20.0, 30.0];\n        assert_eq!(stats::mean(&data), 20.0);\n    }\n\n    #[test]\n    fn test_median() {\n        let mut data = vec![1.0, 2.0, 3.0, 4.0, 5.0];\n        assert_eq!(stats::median(&mut data), 3.0);\n        \n        let mut data = vec![1.0, 2.0, 3.0, 4.0];\n        assert_eq!(stats::median(&mut data), 2.5);\n    }\n}\n\n// In calculator_cli/src/main.rs:\n//! # Calculator CLI\n//! \n//! A command-line interface for the Rust Calculator library.\n//! \n//! ## Usage\n//! \n//! ```bash\n//! cargo run -- add 5 3\n//! cargo run -- multiply 4 7\n//! cargo run -- factorial 5\n//! ```\n\nuse std::env;\nuse rust_calculator::{math, advanced};\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    \n    if args.len() < 3 {\n        eprintln!(\"Usage: {} <operation> <args...>\", args[0]);\n        eprintln!(\"Operations: add, subtract, multiply, divide, factorial, power, sqrt\");\n        std::process::exit(1);\n    }\n    \n    let operation = &args[1];\n    \n    match operation.as_str() {\n        \"add\" => {\n            if args.len() != 4 {\n                eprintln!(\"Usage: {} add <a> <b>\", args[0]);\n                std::process::exit(1);\n            }\n            let a: i32 = args[2].parse().expect(\"Invalid number\");\n            let b: i32 = args[3].parse().expect(\"Invalid number\");\n            println!(\"Result: {}\", math::add(a, b));\n        }\n        \"subtract\" => {\n            if args.len() != 4 {\n                eprintln!(\"Usage: {} subtract <a> <b>\", args[0]);\n                std::process::exit(1);\n            }\n            let a: i32 = args[2].parse().expect(\"Invalid number\");\n            let b: i32 = args[3].parse().expect(\"Invalid number\");\n            println!(\"Result: {}\", math::subtract(a, b));\n        }\n        \"multiply\" => {\n            if args.len() != 4 {\n                eprintln!(\"Usage: {} multiply <a> <b>\", args[0]);\n                std::process::exit(1);\n            }\n            let a: i32 = args[2].parse().expect(\"Invalid number\");\n            let b: i32 = args[3].parse().expect(\"Invalid number\");\n            println!(\"Result: {}\", math::multiply(a, b));\n        }\n        \"divide\" => {\n            if args.len() != 4 {\n                eprintln!(\"Usage: {} divide <a> <b>\", args[0]);\n                std::process::exit(1);\n            }\n            let a: i32 = args[2].parse().expect(\"Invalid number\");\n            let b: i32 = args[3].parse().expect(\"Invalid number\");\n            println!(\"Result: {}\", math::divide(a, b));\n        }\n        \"factorial\" => {\n            if args.len() != 3 {\n                eprintln!(\"Usage: {} factorial <n>\", args[0]);\n                std::process::exit(1);\n            }\n            let n: u64 = args[2].parse().expect(\"Invalid number\");\n            println!(\"Result: {}\", advanced::factorial(n));\n        }\n        \"power\" => {\n            if args.len() != 4 {\n                eprintln!(\"Usage: {} power <base> <exponent>\", args[0]);\n                std::process::exit(1);\n            }\n            let base: f64 = args[2].parse().expect(\"Invalid number\");\n            let exponent: f64 = args[3].parse().expect(\"Invalid number\");\n            println!(\"Result: {}\", advanced::power(base, exponent));\n        }\n        \"sqrt\" => {\n            if args.len() != 3 {\n                eprintln!(\"Usage: {} sqrt <number>\", args[0]);\n                std::process::exit(1);\n            }\n            let x: f64 = args[2].parse().expect(\"Invalid number\");\n            println!(\"Result: {}\", advanced::sqrt(x));\n        }\n        _ => {\n            eprintln!(\"Unknown operation: {}\", operation);\n            eprintln!(\"Available operations: add, subtract, multiply, divide, factorial, power, sqrt\");\n            std::process::exit(1);\n        }\n    }\n}\n\n// In calculator_utils/src/lib.rs:\n//! # Calculator Utilities\n//! \n//! Utility functions for the calculator workspace.\n\n/// Formats a number with commas for readability.\n/// \n/// # Examples\n/// \n/// ```\n/// let formatted = calculator_utils::format_number(1234567);\n/// assert_eq!(formatted, \"1,234,567\");\n/// ```\npub fn format_number(n: i64) -> String {\n    let mut s = n.to_string();\n    let mut result = String::new();\n    \n    while s.len() > 3 {\n        let len = s.len();\n        result = format!(\",{}{}\", &s[len-3..], result);\n        s = s[..len-3].to_string();\n    }\n    \n    format!(\"{}{}\", s, result)\n}\n\n/// Validates that a string represents a valid number.\n/// \n/// # Examples\n/// \n/// ```\n/// assert!(calculator_utils::is_valid_number(\"123\"));\n/// assert!(calculator_utils::is_valid_number(\"-456\"));\n/// assert!(!calculator_utils::is_valid_number(\"abc\"));\n/// ```\npub fn is_valid_number(s: &str) -> bool {\n    s.parse::<f64>().is_ok()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_format_number() {\n        assert_eq!(format_number(123), \"123\");\n        assert_eq!(format_number(1234), \"1,234\");\n        assert_eq!(format_number(1234567), \"1,234,567\");\n    }\n\n    #[test]\n    fn test_is_valid_number() {\n        assert!(is_valid_number(\"123\"));\n        assert!(is_valid_number(\"-456\"));\n        assert!(is_valid_number(\"3.14\"));\n        assert!(!is_valid_number(\"abc\"));\n        assert!(!is_valid_number(\"\"));\n    }\n}",
  "explanation": "This solution demonstrates a complete Cargo workspace with multiple crates, comprehensive documentation, custom release profiles, and publishing-ready metadata. The workspace includes:\n\n1. **rust_calculator** (library): Core calculator functionality with math, advanced, and stats modules\n2. **calculator_cli** (binary): Command-line interface using the library\n3. **calculator_utils** (library): Utility functions for formatting and validation\n\nKey Cargo concepts demonstrated:\n- Workspace structure with shared Cargo.lock and target directory\n- Path dependencies between workspace crates\n- Comprehensive documentation with examples and doc tests\n- Custom release profiles for different optimization levels\n- Proper crate metadata for publishing\n- Binary crate with command-line interface\n- Testing across the entire workspace",
  "keyPoints": [
    "Workspaces share Cargo.lock and target directory for efficient builds",
    "Use path dependencies for crates within the same workspace",
    "Documentation comments with examples are automatically tested",
    "Custom profiles allow fine-tuned control over compilation settings",
    "Proper metadata (description, license, repository) is required for publishing",
    "Binary crates can be installed system-wide with cargo install",
    "cargo doc generates comprehensive HTML documentation",
    "Workspaces enable better organization of large projects"
  ]
}
{
  "exerciseId": "Chapter20_exercise",
  "languageId": "rust",
  "code": "use std::io::{BufReader, prelude::*};\nuse std::net::{TcpListener, TcpStream};\nuse std::sync::{Arc, Mutex, mpsc};\nuse std::thread;\nuse std::time::Duration;\n\n// Step 1: Basic TCP server setup\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    let pool = ThreadPool::new(4);\n    \n    println!(\"Server listening on http://127.0.0.1:7878\");\n    println!(\"Try: http://127.0.0.1:7878/home, /about, /contact, /sleep\");\n    \n    // Handle graceful shutdown with Ctrl+C\n    ctrlc::set_handler(move || {\n        println!(\"\\nShutting down server gracefully...\");\n        std::process::exit(0);\n    }).expect(\"Error setting Ctrl+C handler\");\n    \n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n        pool.execute(|| {\n            handle_connection(stream);\n        });\n    }\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&stream);\n    let request_line = buf_reader.lines().next().unwrap().unwrap();\n    \n    println!(\"Received request: {}\", request_line);\n    \n    // Parse request and route to appropriate handler\n    let (status_line, content) = match &request_line[..] {\n        \"GET / HTTP/1.1\" | \"GET /home HTTP/1.1\" => {\n            (\"HTTP/1.1 200 OK\", \"<h1>Welcome Home!</h1><p>This is the home page.</p>\")\n        },\n        \"GET /about HTTP/1.1\" => {\n            (\"HTTP/1.1 200 OK\", \"<h1>About Us</h1><p>We are learning Rust!</p>\")\n        },\n        \"GET /contact HTTP/1.1\" => {\n            (\"HTTP/1.1 200 OK\", \"<h1>Contact</h1><p>Email: hello@rust-lang.org</p>\")\n        },\n        \"GET /sleep HTTP/1.1\" => {\n            thread::sleep(Duration::from_secs(5));\n            (\"HTTP/1.1 200 OK\", \"<h1>Slow Page</h1><p>This page took 5 seconds to load.</p>\")\n        },\n        _ => {\n            (\"HTTP/1.1 404 NOT FOUND\", \"<h1>404 Not Found</h1><p>Page not found.</p>\")\n        }\n    };\n    \n    let response = format!(\n        \"{}\\r\\nContent-Type: text/html\\r\\nContent-Length: {}\\r\\n\\r\\n{}\",\n        status_line,\n        content.len(),\n        content\n    );\n    \n    stream.write_all(response.as_bytes()).unwrap();\n    stream.flush().unwrap();\n}\n\n// Step 3: ThreadPool implementation\ntype Job = Box<dyn FnOnce() + Send + 'static>;\n\npub struct ThreadPool {\n    workers: Vec<Worker>,\n    sender: Option<mpsc::Sender<Job>>,\n}\n\nimpl ThreadPool {\n    pub fn new(size: usize) -> Self {\n        assert!(size > 0);\n        \n        let (sender, receiver) = mpsc::channel();\n        let receiver = Arc::new(Mutex::new(receiver));\n        \n        let mut workers = Vec::with_capacity(size);\n        \n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&receiver)));\n        }\n        \n        ThreadPool {\n            workers,\n            sender: Some(sender),\n        }\n    }\n    \n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static,\n    {\n        let job = Box::new(f);\n        self.sender.as_ref().unwrap().send(job).unwrap();\n    }\n}\n\nimpl Drop for ThreadPool {\n    fn drop(&mut self) {\n        drop(self.sender.take());\n        \n        for worker in self.workers.drain(..) {\n            println!(\"Shutting down worker {}\", worker.id);\n            worker.thread.join().unwrap();\n        }\n    }\n}\n\nstruct Worker {\n    id: usize,\n    thread: thread::JoinHandle<()>,\n}\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>>) -> Worker {\n        let thread = thread::spawn(move || {\n            loop {\n                let message = receiver.lock().unwrap().recv();\n                \n                match message {\n                    Ok(job) => {\n                        println!(\"Worker {} got a job; executing.\", id);\n                        job();\n                    },\n                    Err(_) => {\n                        println!(\"Worker {} disconnected; shutting down.\", id);\n                        break;\n                    }\n                }\n            }\n        });\n        \n        Worker { id, thread }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_thread_pool_creation() {\n        let pool = ThreadPool::new(4);\n        // Test passes if no panic occurs\n        assert!(true);\n    }\n    \n    #[test]\n    fn test_basic_http_response() {\n        let response = \"HTTP/1.1 200 OK\\r\\nContent-Length: 13\\r\\n\\r\\nHello, World!\";\n        assert!(response.contains(\"HTTP/1.1 200 OK\"));\n        assert!(response.contains(\"Content-Length: 13\"));\n        assert!(response.ends_with(\"Hello, World!\"));\n    }\n    \n    #[test]\n    fn test_request_parsing() {\n        let request = \"GET /home HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\";\n        assert!(request.starts_with(\"GET\"));\n        assert!(request.contains(\"/home\"));\n        assert!(request.contains(\"HTTP/1.1\"));\n    }\n}",
  "explanation": "This solution implements a complete multithreaded web server with TCP connection handling, HTTP request parsing, routing, and a thread pool for concurrent request processing. The server supports multiple routes (/home, /about, /contact, /sleep) and includes graceful shutdown functionality. The ThreadPool uses channels for communication between the main thread and worker threads, with proper synchronization using Arc<Mutex<>>. The server demonstrates real-world web server concepts including connection handling, request parsing, response formatting, and concurrent processing.",
  "keyPoints": [
    "TCP listeners handle incoming connections, while BufReader efficiently reads HTTP requests",
    "HTTP requests are parsed by reading the first line and matching on method and path",
    "Thread pools enable concurrent request processing without creating unlimited threads",
    "Channels provide safe communication between threads for job distribution",
    "Arc<Mutex<>> enables shared mutable state across threads",
    "Graceful shutdown involves dropping the sender to close channels and joining worker threads",
    "HTTP responses must include proper headers (Content-Type, Content-Length) and CRLF formatting"
  ]
}
{
  "exerciseId": "Chapter10_exercise",
  "languageId": "rust",
  "code": "pub mod math_utils {\n    pub fn add(a: i32, b: i32) -> i32 {\n        a + b\n    }\n\n    pub fn divide(a: i32, b: i32) -> i32 {\n        if b == 0 {\n            panic!(\"Division by zero!\");\n        }\n        a / b\n    }\n\n    pub fn is_even(n: i32) -> bool {\n        n % 2 == 0\n    }\n\n    pub fn factorial(n: u32) -> u64 {\n        if n == 0 {\n            1\n        } else {\n            n as u64 * factorial(n - 1)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::math_utils::*;\n\n    #[test]\n    fn test_add() {\n        assert_eq!(add(2, 3), 5);\n        assert_eq!(add(-1, 1), 0);\n        assert_eq!(add(0, 0), 0);\n    }\n\n    #[test]\n    fn test_divide() {\n        assert_eq!(divide(10, 2), 5);\n        assert_eq!(divide(9, 3), 3);\n        assert_eq!(divide(0, 5), 0);\n    }\n\n    #[test]\n    #[should_panic(expected = \"Division by zero!\")]\n    fn test_divide_by_zero_panics() {\n        divide(5, 0);\n    }\n\n    #[test]\n    fn test_is_even() {\n        assert!(is_even(2));\n        assert!(is_even(0));\n        assert!(is_even(-2));\n        assert!(!is_even(1));\n        assert!(!is_even(-1));\n    }\n\n    #[test]\n    fn test_factorial() {\n        assert_eq!(factorial(0), 1);\n        assert_eq!(factorial(1), 1);\n        assert_eq!(factorial(5), 120);\n        assert_eq!(factorial(10), 3628800);\n    }\n\n    #[test]\n    fn test_with_custom_messages() {\n        let result = add(2, 2);\n        assert_eq!(result, 4, \"Basic addition should work: 2 + 2 = 4, but got {}\", result);\n        \n        assert!(is_even(4), \"4 should be even\");\n        assert!(!is_even(3), \"3 should be odd\");\n    }\n\n    #[test]\n    fn test_edge_cases() {\n        // Test large numbers\n        assert_eq!(add(i32::MAX - 1, 1), i32::MAX);\n        \n        // Test factorial with larger values\n        assert_eq!(factorial(12), 479001600);\n        \n        // Test negative even numbers\n        assert!(is_even(-4));\n    }\n\n    #[test]\n    fn test_result_based_test() -> Result<(), String> {\n        if add(2, 3) != 5 {\n            return Err(String::from(\"Addition test failed\"));\n        }\n        \n        if !is_even(6) {\n            return Err(String::from(\"Even check failed\"));\n        }\n        \n        if factorial(3) != 6 {\n            return Err(String::from(\"Factorial test failed\"));\n        }\n        \n        Ok(())\n    }\n\n    // Helper function for tests\n    fn create_test_data() -> Vec<(i32, i32, i32)> {\n        vec![(1, 2, 3), (0, 0, 0), (-1, 1, 0)]\n    }\n\n    #[test]\n    fn test_with_helper() {\n        let test_cases = create_test_data();\n        for (a, b, expected) in test_cases {\n            assert_eq!(add(a, b), expected, \"add({}, {}) should equal {}\", a, b, expected);\n        }\n    }\n}",
  "explanation": "This solution demonstrates comprehensive testing practices in Rust. The test suite covers all major testing features: basic assertions with assert_eq! and assert!, panic testing with should_panic, custom failure messages, Result-based tests, edge case testing, and helper functions within test modules.\n\nKey concepts demonstrated:\n- Unit testing with #[test] attribute\n- Various assertion macros (assert!, assert_eq!, assert_ne!)\n- Panic testing with #[should_panic] and expected messages\n- Custom failure messages for better debugging\n- Tests returning Result<T, E> instead of panicking\n- Edge case and boundary testing\n- Helper functions within test modules\n- Testing both success and failure scenarios",
  "keyPoints": [
    "Use #[test] to mark test functions that will be run by cargo test",
    "assert_eq! and assert_ne! compare values and print both sides on failure",
    "Use #[should_panic] to test code that should panic under certain conditions",
    "Add custom messages to assertions for better debugging information",
    "Tests can return Result<T, E> to avoid panicking while still failing the test",
    "Test edge cases, boundary conditions, and error scenarios thoroughly",
    "Helper functions in test modules can reduce code duplication",
    "cargo test runs all tests and provides detailed output on failures"
  ]
}
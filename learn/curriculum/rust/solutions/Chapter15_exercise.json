{
  "exerciseId": "Chapter15_exercise",
  "languageId": "rust",
  "code": "// Fearless Concurrency Comprehensive Solution\n// Demonstrates threads, channels, mutexes, and concurrency patterns\n\nuse std::sync::{Arc, Mutex, mpsc};\nuse std::thread;\nuse std::time::Duration;\n\n// 1. Thread Management\nfn spawn_worker_threads<F, T>(num_threads: usize, work: F) -> Vec<thread::JoinHandle<T>>\nwhere\n    F: Fn() -> T + Send + Sync + 'static,\n    T: Send + 'static,\n{\n    let mut handles = vec![];\n    \n    for i in 0..num_threads {\n        let work_clone = work.clone();\n        let handle = thread::spawn(move || {\n            println!(\"Worker thread {} starting\", i);\n            let result = work_clone();\n            println!(\"Worker thread {} finished\", i);\n            result\n        });\n        handles.push(handle);\n    }\n    \n    handles\n}\n\n// 2. Message Passing - Producer Consumer Pattern\nstruct ProducerConsumer {\n    producers: Vec<thread::JoinHandle<()>>,\n    consumer: thread::JoinHandle<Vec<String>>,\n}\n\nimpl ProducerConsumer {\n    fn new(num_producers: usize, items_per_producer: usize) -> Self {\n        let (tx, rx) = mpsc::channel();\n        let mut producers = vec![];\n        \n        // Create producers\n        for i in 0..num_producers {\n            let tx_clone = tx.clone();\n            let producer = thread::spawn(move || {\n                for j in 0..items_per_producer {\n                    let message = format!(\"Producer {}: Item {}\", i, j);\n                    tx_clone.send(message).unwrap();\n                    thread::sleep(Duration::from_millis(1));\n                }\n            });\n            producers.push(producer);\n        }\n        \n        // Drop the original transmitter so receiver knows when to stop\n        drop(tx);\n        \n        // Create consumer\n        let consumer = thread::spawn(move || {\n            let mut results = vec![];\n            for received in rx {\n                println!(\"Consumed: {}\", received);\n                results.push(received);\n            }\n            results\n        });\n        \n        ProducerConsumer { producers, consumer }\n    }\n    \n    fn wait_for_completion(self) -> Vec<String> {\n        for producer in self.producers {\n            producer.join().unwrap();\n        }\n        self.consumer.join().unwrap()\n    }\n}\n\n// 3. Shared State - Thread-Safe Counter\n#[derive(Debug)]\nstruct ThreadSafeCounter {\n    count: Arc<Mutex<i32>>,\n}\n\nimpl ThreadSafeCounter {\n    fn new(initial: i32) -> Self {\n        ThreadSafeCounter {\n            count: Arc::new(Mutex::new(initial)),\n        }\n    }\n    \n    fn increment(&self) {\n        let mut num = self.count.lock().unwrap();\n        *num += 1;\n    }\n    \n    fn decrement(&self) {\n        let mut num = self.count.lock().unwrap();\n        *num -= 1;\n    }\n    \n    fn get(&self) -> i32 {\n        *self.count.lock().unwrap()\n    }\n    \n    fn clone_counter(&self) -> ThreadSafeCounter {\n        ThreadSafeCounter {\n            count: Arc::clone(&self.count),\n        }\n    }\n}\n\n// 4. Concurrent Data Processing Pipeline\nstruct DataProcessor {\n    workers: Vec<thread::JoinHandle<Vec<i32>>>,\n    aggregator: thread::JoinHandle<Vec<i32>>,\n}\n\nimpl DataProcessor {\n    fn new(data: Vec<i32>, num_workers: usize) -> Self {\n        let shared_data = Arc::new(data);\n        let (tx, rx) = mpsc::channel();\n        let mut workers = vec![];\n        \n        // Create worker threads\n        for i in 0..num_workers {\n            let data_clone = Arc::clone(&shared_data);\n            let tx_clone = tx.clone();\n            let worker = thread::spawn(move || {\n                let chunk_size = data_clone.len() / num_workers;\n                let start = i * chunk_size;\n                let end = if i == num_workers - 1 { \n                    data_clone.len() \n                } else { \n                    (i + 1) * chunk_size \n                };\n                \n                let mut results = vec![];\n                for &num in &data_clone[start..end] {\n                    // Simulate processing work\n                    thread::sleep(Duration::from_millis(1));\n                    results.push(num * num);\n                }\n                \n                tx_clone.send(results).unwrap();\n                vec![] // Worker threads don't return data directly\n            });\n            workers.push(worker);\n        }\n        \n        drop(tx); // Close channel for workers\n        \n        // Create aggregator thread\n        let aggregator = thread::spawn(move || {\n            let mut all_results = vec![];\n            for partial_results in rx {\n                all_results.extend(partial_results);\n            }\n            all_results.sort();\n            all_results\n        });\n        \n        DataProcessor { workers, aggregator }\n    }\n    \n    fn get_results(self) -> Vec<i32> {\n        for worker in self.workers {\n            worker.join().unwrap();\n        }\n        self.aggregator.join().unwrap()\n    }\n}\n\n// 5. Demonstrating Send and Sync traits\n#[derive(Debug, Clone)]\nstruct CustomData {\n    value: i32,\n    name: String,\n}\n\n// CustomData implements Send and Sync automatically because\n// i32 and String both implement them\nimpl CustomData {\n    fn process_in_thread(self) -> Self {\n        thread::spawn(move || {\n            // This works because CustomData implements Send\n            CustomData {\n                value: self.value * 2,\n                name: format!(\"{}_processed\", self.name),\n            }\n        }).join().unwrap()\n    }\n}\n\n// 6. Complex concurrent computation\nfn concurrent_factorial_sum(numbers: Vec<u64>) -> u64 {\n    let shared_result = Arc::new(Mutex::new(0u64));\n    let mut handles = vec![];\n    \n    for num in numbers {\n        let result_clone = Arc::clone(&shared_result);\n        let handle = thread::spawn(move || {\n            let factorial = (1..=num).product::<u64>();\n            let mut result = result_clone.lock().unwrap();\n            *result += factorial;\n        });\n        handles.push(handle);\n    }\n    \n    for handle in handles {\n        handle.join().unwrap();\n    }\n    \n    *shared_result.lock().unwrap()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_thread_creation_and_joining() {\n        let mut handles = vec![];\n        \n        for i in 0..5 {\n            let handle = thread::spawn(move || {\n                thread::sleep(Duration::from_millis(10));\n                i * 2\n            });\n            handles.push(handle);\n        }\n        \n        let mut results = vec![];\n        for handle in handles {\n            results.push(handle.join().unwrap());\n        }\n        \n        assert_eq!(results, vec![0, 2, 4, 6, 8]);\n    }\n\n    #[test]\n    fn test_message_passing() {\n        let (tx, rx) = mpsc::channel();\n        \n        thread::spawn(move || {\n            tx.send(\"Hello from thread!\").unwrap();\n        });\n        \n        let received = rx.recv().unwrap();\n        assert_eq!(received, \"Hello from thread!\");\n    }\n\n    #[test]\n    fn test_shared_mutex_counter() {\n        let counter = Arc::new(Mutex::new(0));\n        let mut handles = vec![];\n        \n        for _ in 0..10 {\n            let counter = Arc::clone(&counter);\n            let handle = thread::spawn(move || {\n                let mut num = counter.lock().unwrap();\n                *num += 1;\n            });\n            handles.push(handle);\n        }\n        \n        for handle in handles {\n            handle.join().unwrap();\n        }\n        \n        assert_eq!(*counter.lock().unwrap(), 10);\n    }\n\n    #[test]\n    fn test_multiple_producers() {\n        let (tx, rx) = mpsc::channel();\n        let mut handles = vec![];\n        \n        for i in 0..3 {\n            let tx_clone = tx.clone();\n            let handle = thread::spawn(move || {\n                for j in 0..3 {\n                    tx_clone.send(format!(\"Thread {}: Message {}\", i, j)).unwrap();\n                    thread::sleep(Duration::from_millis(1));\n                }\n            });\n            handles.push(handle);\n        }\n        \n        drop(tx); // Close the channel\n        \n        let mut messages = vec![];\n        for received in rx {\n            messages.push(received);\n        }\n        \n        assert_eq!(messages.len(), 9);\n    }\n\n    #[test]\n    fn test_concurrent_data_processing() {\n        let data = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n        let processor = DataProcessor::new(data, 4);\n        let results = processor.get_results();\n        \n        assert_eq!(results, vec![1, 4, 9, 16, 25, 36, 49, 64, 81, 100]);\n    }\n\n    #[test]\n    fn test_thread_safety_guarantees() {\n        let counter = Arc::new(Mutex::new(0));\n        let counter_clone = Arc::clone(&counter);\n        \n        thread::spawn(move || {\n            *counter_clone.lock().unwrap() += 1;\n        }).join().unwrap();\n        \n        assert_eq!(*counter.lock().unwrap(), 1);\n    }\n\n    #[test]\n    fn test_producer_consumer_pattern() {\n        let pc = ProducerConsumer::new(3, 2);\n        let results = pc.wait_for_completion();\n        \n        assert_eq!(results.len(), 6); // 3 producers * 2 items each\n        \n        // Check that all messages are present\n        for i in 0..3 {\n            for j in 0..2 {\n                let expected = format!(\"Producer {}: Item {}\", i, j);\n                assert!(results.contains(&expected));\n            }\n        }\n    }\n\n    #[test]\n    fn test_thread_safe_counter() {\n        let counter = ThreadSafeCounter::new(5);\n        let counter_clone = counter.clone_counter();\n        \n        counter.increment();\n        counter_clone.increment();\n        counter.decrement();\n        \n        assert_eq!(counter.get(), 6);\n        assert_eq!(counter_clone.get(), 6);\n    }\n\n    #[test]\n    fn test_send_sync_traits() {\n        let data = CustomData {\n            value: 21,\n            name: \"test\".to_string(),\n        };\n        \n        let processed = data.process_in_thread();\n        assert_eq!(processed.value, 42);\n        assert_eq!(processed.name, \"test_processed\");\n    }\n\n    #[test]\n    fn test_concurrent_factorial_sum() {\n        let numbers = vec![3, 4, 5];\n        let result = concurrent_factorial_sum(numbers);\n        // 3! + 4! + 5! = 6 + 24 + 120 = 150\n        assert_eq!(result, 150);\n    }\n\n    #[test]\n    fn test_complex_concurrency_patterns() {\n        // Test combining multiple patterns\n        let counter = Arc::new(Mutex::new(0));\n        let (tx, rx) = mpsc::channel();\n        let mut handles = vec![];\n        \n        // Spawn threads that both increment counter and send messages\n        for i in 0..5 {\n            let counter_clone = Arc::clone(&counter);\n            let tx_clone = tx.clone();\n            let handle = thread::spawn(move || {\n                let mut num = counter_clone.lock().unwrap();\n                *num += 1;\n                tx_clone.send(format!(\"Thread {} done\", i)).unwrap();\n            });\n            handles.push(handle);\n        }\n        \n        drop(tx);\n        \n        // Collect messages\n        let mut messages = vec![];\n        for msg in rx {\n            messages.push(msg);\n        }\n        \n        // Wait for all threads\n        for handle in handles {\n            handle.join().unwrap();\n        }\n        \n        assert_eq!(*counter.lock().unwrap(), 5);\n        assert_eq!(messages.len(), 5);\n    }\n}",
  "explanation": "This comprehensive solution demonstrates all major concurrency patterns in Rust:\n\n1. **Thread Management**: Creating and joining threads with proper ownership transfer\n2. **Message Passing**: Using channels for producer-consumer patterns and multiple producers\n3. **Shared State**: Thread-safe counters using Arc<Mutex<T>> for shared mutable state\n4. **Concurrent Processing**: Parallel data processing pipelines with work distribution\n5. **Send/Sync Traits**: Automatic implementation for thread-safe types\n6. **Complex Patterns**: Combining channels and shared state for sophisticated concurrency\n\nKey concurrency concepts demonstrated:\n- Thread spawning with move closures for ownership transfer\n- Channel-based communication with mpsc (multiple producer, single consumer)\n- Mutex guards for safe mutable access to shared data\n- Arc for atomic reference counting across threads\n- Automatic Send/Sync trait implementation for safe types\n- Proper resource cleanup and thread synchronization\n- Race condition prevention through Rust's type system",
  "keyPoints": [
    "Use thread::spawn() to create threads and handle.join() to wait for completion",
    "Use mpsc::channel() for message passing between threads",
    "Use Arc<Mutex<T>> for shared mutable state across multiple threads",
    "Clone transmitters with tx.clone() to enable multiple producers",
    "Use move closures to transfer ownership to spawned threads",
    "Drop transmitters to signal channel closure and end iteration",
    "Mutex<T> provides interior mutability like RefCell<T> but thread-safe",
    "Arc<T> provides atomic reference counting for shared ownership",
    "Send trait allows ownership transfer between threads",
    "Sync trait allows shared references across threads",
    "Rust's type system prevents data races and race conditions at compile time"
  ]
}
{
  "exerciseId": "Chapter21_exercise",
  "languageId": "rust",
  "code": "use std::collections::HashMap;\nuse std::f64::consts::PI;\nuse tokio::fs;\nuse tokio::io::{self, AsyncReadExt, AsyncWriteExt};\n\n// Step 1: User Management System\n#[derive(Debug, Clone)]\npub struct User {\n    pub id: u32,\n    pub name: String,\n    pub email: String,\n    pub is_active: bool,\n}\n\npub struct UserManager {\n    users: HashMap<u32, User>,\n    next_id: u32,\n}\n\nimpl UserManager {\n    /// Creates a new user manager instance.\n    pub fn new() -> Self {\n        UserManager {\n            users: HashMap::new(),\n            next_id: 1,\n        }\n    }\n    \n    /// Adds a new user to the system.\n    ///\n    /// # Arguments\n    ///\n    /// * `name` - The user's full name\n    /// * `email` - The user's email address\n    ///\n    /// # Returns\n    ///\n    /// Returns the ID of the newly created user, or an error if validation fails.\n    pub fn add_user(&mut self, name: String, email: String) -> Result<u32, String> {\n        // Validate input parameters\n        if name.trim().is_empty() {\n            return Err(\"User name cannot be empty\".to_string());\n        }\n        \n        if !email.contains('@') {\n            return Err(\"Invalid email format\".to_string());\n        }\n        \n        // Check if email already exists\n        let email_exists = self.users.values().any(|user| user.email == email);\n        if email_exists {\n            return Err(\"Email already exists\".to_string());\n        }\n        \n        let user_id = self.next_id;\n        let new_user = User {\n            id: user_id,\n            name: name.trim().to_string(),\n            email: email.to_lowercase(),\n            is_active: true,\n        };\n        \n        self.users.insert(user_id, new_user);\n        self.next_id += 1;\n        \n        Ok(user_id)\n    }\n    \n    /// Retrieves a user by their ID.\n    ///\n    /// # Arguments\n    ///\n    /// * `id` - The user's unique identifier\n    ///\n    /// # Returns\n    ///\n    /// Returns `Some(user)` if found, `None` otherwise.\n    pub fn get_user(&self, id: u32) -> Option<&User> {\n        self.users.get(&id)\n    }\n    \n    /// Updates a user's email address.\n    ///\n    /// # Arguments\n    ///\n    /// * `id` - The user's unique identifier\n    /// * `new_email` - The new email address\n    ///\n    /// # Returns\n    ///\n    /// Returns `Ok(())` on success, or an error message on failure.\n    pub fn update_user_email(&mut self, id: u32, new_email: String) -> Result<(), String> {\n        // Validate email format\n        if !new_email.contains('@') {\n            return Err(\"Invalid email format\".to_string());\n        }\n        \n        // Check if email already exists for another user\n        let email_exists = self.users.values().any(|user| user.email == new_email && user.id != id);\n        if email_exists {\n            return Err(\"Email already exists\".to_string());\n        }\n        \n        match self.users.get_mut(&id) {\n            Some(user) => {\n                user.email = new_email.to_lowercase();\n                Ok(())\n            },\n            None => Err(\"User not found\".to_string()),\n        }\n    }\n    \n    /// Deactivates a user account.\n    ///\n    /// # Arguments\n    ///\n    /// * `id` - The user's unique identifier\n    ///\n    /// # Returns\n    ///\n    /// Returns `Ok(())` on success, or an error message if user not found.\n    pub fn deactivate_user(&mut self, id: u32) -> Result<(), String> {\n        match self.users.get_mut(&id) {\n            Some(user) => {\n                user.is_active = false;\n                Ok(())\n            },\n            None => Err(\"User not found\".to_string()),\n        }\n    }\n}\n\n// Step 2: Data Processing with Functional Programming\n/// Processes a vector of numbers using functional programming principles.\n///\n/// # Arguments\n///\n/// * `numbers` - A vector of integers to process\n///\n/// # Returns\n///\n/// Returns a tuple containing (even_squares, sum, average).\npub fn process_numbers(numbers: Vec<i32>) -> (Vec<i32>, i32, f64) {\n    // Filter even numbers and square them\n    let even_squares: Vec<i32> = numbers.iter()\n        .filter(|&&x| x % 2 == 0)\n        .map(|&x| x * x)\n        .collect();\n    \n    // Calculate sum using iterator\n    let sum: i32 = numbers.iter().sum();\n    \n    // Calculate average\n    let average = if numbers.is_empty() {\n        0.0\n    } else {\n        sum as f64 / numbers.len() as f64\n    };\n    \n    (even_squares, sum, average)\n}\n\n/// Groups words by their length using functional programming.\n///\n/// # Arguments\n///\n/// * `words` - A vector of strings to group\n///\n/// # Returns\n///\n/// Returns a HashMap where keys are word lengths and values are vectors of words.\npub fn group_words_by_length(words: Vec<String>) -> HashMap<usize, Vec<String>> {\n    words.into_iter()\n        .fold(HashMap::new(), |mut groups, word| {\n            groups.entry(word.len()).or_insert(Vec::new()).push(word);\n            groups\n        })\n}\n\n// Step 3: Shape Calculations with Enums and Traits\n#[derive(Debug, Clone, Copy)]\npub enum Shape {\n    Circle(f64), // radius\n    Rectangle(f64, f64), // width, height\n    Triangle(f64, f64, f64), // sides a, b, c\n}\n\npub trait ShapeCalculations {\n    /// Calculates the area of the shape.\n    fn area(&self) -> f64;\n    \n    /// Calculates the perimeter of the shape.\n    fn perimeter(&self) -> f64;\n    \n    /// Returns a descriptive string for the shape.\n    fn description(&self) -> String;\n}\n\nimpl ShapeCalculations for Shape {\n    fn area(&self) -> f64 {\n        match self {\n            Shape::Circle(radius) => PI * radius * radius,\n            Shape::Rectangle(width, height) => width * height,\n            Shape::Triangle(a, b, c) => {\n                // Using Heron's formula\n                let s = (a + b + c) / 2.0;\n                (s * (s - a) * (s - b) * (s - c)).sqrt()\n            }\n        }\n    }\n    \n    fn perimeter(&self) -> f64 {\n        match self {\n            Shape::Circle(radius) => 2.0 * PI * radius,\n            Shape::Rectangle(width, height) => 2.0 * (width + height),\n            Shape::Triangle(a, b, c) => a + b + c,\n        }\n    }\n    \n    fn description(&self) -> String {\n        match self {\n            Shape::Circle(radius) => format!(\"Circle with radius {:.2}\", radius),\n            Shape::Rectangle(width, height) => format!(\"Rectangle with width {:.2} and height {:.2}\", width, height),\n            Shape::Triangle(a, b, c) => format!(\"Triangle with sides {:.2}, {:.2}, {:.2}\", a, b, c),\n        }\n    }\n}\n\n// Step 4: Configuration System\n#[derive(Debug, Clone)]\npub struct ApplicationConfig {\n    pub database_url: String,\n    pub max_connections: u32,\n    pub enable_logging: bool,\n    pub server_port: u16,\n}\n\nimpl ApplicationConfig {\n    /// Creates a new application configuration with default values.\n    ///\n    /// # Examples\n    ///\n    /// ```\n    /// let config = ApplicationConfig::new();\n    /// assert_eq!(config.server_port, 8080);\n    /// ```\n    pub fn new() -> Self {\n        ApplicationConfig {\n            database_url: \"postgresql://localhost/mydb\".to_string(),\n            max_connections: 10,\n            enable_logging: true,\n            server_port: 8080,\n        }\n    }\n    \n    /// Sets the database URL for the configuration.\n    ///\n    /// # Arguments\n    ///\n    /// * `url` - The database connection URL\n    ///\n    /// # Returns\n    ///\n    /// Returns the configuration instance for method chaining.\n    pub fn with_database_url(mut self, url: String) -> Self {\n        self.database_url = url;\n        self\n    }\n    \n    /// Sets the maximum number of connections.\n    ///\n    /// # Arguments\n    ///\n    /// * `connections` - The maximum number of connections (must be > 0)\n    ///\n    /// # Returns\n    ///\n    /// Returns the configuration instance for method chaining.\n    pub fn with_max_connections(mut self, connections: u32) -> Self {\n        if connections == 0 {\n            panic!(\"Maximum connections must be greater than 0\");\n        }\n        self.max_connections = connections;\n        self\n    }\n    \n    /// Enables or disables logging.\n    ///\n    /// # Arguments\n    ///\n    /// * `enabled` - Whether logging should be enabled\n    ///\n    /// # Returns\n    ///\n    /// Returns the configuration instance for method chaining.\n    pub fn with_logging(mut self, enabled: bool) -> Self {\n        self.enable_logging = enabled;\n        self\n    }\n}\n\n// Step 5: Async File Operations\n/// Asynchronously reads the content of a file.\n///\n/// # Arguments\n///\n/// * `file_path` - The path to the file to read\n///\n/// # Returns\n///\n/// Returns the file content as a String, or an IO error.\npub async fn read_file_content_async(file_path: &str) -> Result<String, io::Error> {\n    let mut file = fs::File::open(file_path).await?;\n    let mut content = String::new();\n    file.read_to_string(&mut content).await?;\n    Ok(content)\n}\n\n/// Asynchronously writes content to a file.\n///\n/// # Arguments\n///\n/// * `file_path` - The path to the file to write\n/// * `content` - The content to write to the file\n///\n/// # Returns\n///\n/// Returns `Ok(())` on success, or an IO error.\npub async fn write_file_content_async(file_path: &str, content: &str) -> Result<(), io::Error> {\n    let mut file = fs::File::create(file_path).await?;\n    file.write_all(content.as_bytes()).await?;\n    Ok(())\n}\n\n/// Asynchronously processes a file by reading from input and writing to output.\n///\n/// # Arguments\n///\n/// * `input_path` - The path to the input file\n/// * `output_path` - The path to the output file\n///\n/// # Returns\n///\n/// Returns `Ok(())` on success, or an IO error.\npub async fn process_file_async(input_path: &str, output_path: &str) -> Result<(), io::Error> {\n    // Read input file\n    let content = read_file_content_async(input_path).await?;\n    \n    // Process content (convert to uppercase for this example)\n    let processed_content = content.to_uppercase();\n    \n    // Write to output file\n    write_file_content_async(output_path, &processed_content).await?;\n    \n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_user_management() {\n        let mut manager = UserManager::new();\n        \n        // Test adding users\n        let user_id = manager.add_user(\"Alice\".to_string(), \"alice@example.com\".to_string()).unwrap();\n        assert_eq!(user_id, 1);\n        \n        // Test getting user\n        let user = manager.get_user(1).unwrap();\n        assert_eq!(user.name, \"Alice\");\n        assert!(user.is_active);\n        \n        // Test updating email\n        manager.update_user_email(1, \"alice.new@example.com\".to_string()).unwrap();\n        let updated_user = manager.get_user(1).unwrap();\n        assert_eq!(updated_user.email, \"alice.new@example.com\");\n        \n        // Test deactivating user\n        manager.deactivate_user(1).unwrap();\n        let deactivated_user = manager.get_user(1).unwrap();\n        assert!(!deactivated_user.is_active);\n        \n        // Test error cases\n        assert!(manager.add_user(\"\".to_string(), \"test@example.com\".to_string()).is_err());\n        assert!(manager.add_user(\"Bob\".to_string(), \"invalid-email\".to_string()).is_err());\n        assert!(manager.update_user_email(999, \"test@example.com\".to_string()).is_err());\n    }\n    \n    #[test]\n    fn test_data_processing() {\n        let numbers = vec![1, 2, 3, 4, 5, 6];\n        let (even_squares, sum, average) = process_numbers(numbers);\n        \n        assert_eq!(even_squares, vec![4, 16, 36]); // 2^2, 4^2, 6^2\n        assert_eq!(sum, 21); // 1+2+3+4+5+6\n        assert!((average - 3.5).abs() < 0.001); // 21/6\n        \n        let words = vec![\n            \"hello\".to_string(),\n            \"world\".to_string(),\n            \"hi\".to_string(),\n            \"rust\".to_string(),\n        ];\n        let grouped = group_words_by_length(words);\n        \n        assert_eq!(grouped.get(&2), Some(&vec![\"hi\".to_string()]));\n        assert_eq!(grouped.get(&4), Some(&vec![\"rust\".to_string()]));\n        assert_eq!(grouped.get(&5), Some(&vec![\"hello\".to_string(), \"world\".to_string()]));\n    }\n    \n    #[test]\n    fn test_shape_calculations() {\n        let circle = Shape::Circle(5.0);\n        let rectangle = Shape::Rectangle(4.0, 6.0);\n        let triangle = Shape::Triangle(3.0, 4.0, 5.0);\n        \n        // Test circle\n        assert!((circle.area() - 78.53981633974483).abs() < 0.001);\n        assert!((circle.perimeter() - 31.41592653589793).abs() < 0.001);\n        assert_eq!(circle.description(), \"Circle with radius 5.00\");\n        \n        // Test rectangle\n        assert_eq!(rectangle.area(), 24.0);\n        assert_eq!(rectangle.perimeter(), 20.0);\n        assert_eq!(rectangle.description(), \"Rectangle with width 4.00 and height 6.00\");\n        \n        // Test triangle\n        assert!((triangle.area() - 6.0).abs() < 0.001); // Right triangle area\n        assert_eq!(triangle.perimeter(), 12.0);\n        assert_eq!(triangle.description(), \"Triangle with sides 3.00, 4.00, 5.00\");\n    }\n    \n    #[test]\n    fn test_configuration_system() {\n        // Test default configuration\n        let config = ApplicationConfig::new();\n        assert_eq!(config.server_port, 8080);\n        assert_eq!(config.max_connections, 10);\n        assert!(config.enable_logging);\n        \n        // Test builder pattern\n        let custom_config = ApplicationConfig::new()\n            .with_database_url(\"mysql://localhost/test\".to_string())\n            .with_max_connections(20)\n            .with_logging(false);\n        \n        assert_eq!(custom_config.database_url, \"mysql://localhost/test\");\n        assert_eq!(custom_config.max_connections, 20);\n        assert!(!custom_config.enable_logging);\n    }\n    \n    #[tokio::test]\n    async fn test_async_file_operations() {\n        let test_content = \"Hello, Rust!\\nThis is a test file.\\n\";\n        let input_path = \"test_input.txt\";\n        let output_path = \"test_output.txt\";\n        \n        // Write test file\n        write_file_content_async(input_path, test_content).await.unwrap();\n        \n        // Read and verify\n        let read_content = read_file_content_async(input_path).await.unwrap();\n        assert_eq!(read_content, test_content);\n        \n        // Process file (convert to uppercase)\n        process_file_async(input_path, output_path).await.unwrap();\n        \n        // Read processed file\n        let processed_content = read_file_content_async(output_path).await.unwrap();\n        assert_eq!(processed_content, test_content.to_uppercase());\n        \n        // Cleanup\n        std::fs::remove_file(input_path).unwrap();\n        std::fs::remove_file(output_path).unwrap();\n    }\n}",
  "explanation": "This solution demonstrates comprehensive application of Rust's readability principles from Chapter 21. It implements a user management system with proper error handling, functional programming for data processing, enums and traits for shape calculations, a well-documented configuration system following naming conventions, and async file operations. The code follows all the best practices outlined in the chapter including descriptive naming, comprehensive documentation, pattern matching, functional programming, and proper error handling.",
  "keyPoints": [
    "Use descriptive names with snake_case for variables and functions",
    "Add comprehensive documentation comments (///) for all public APIs",
    "Leverage Result and Option for safe error handling instead of panics",
    "Use pattern matching with match expressions for clear control flow",
    "Apply functional programming with iterators, map, filter, and collect",
    "Implement traits to define shared behavior across types",
    "Use async/await for asynchronous operations with proper error propagation",
    "Follow builder pattern for complex object construction",
    "Use boolean prefixes (is_, has_, can_) for clarity",
    "Keep functions focused on single responsibilities with clear purposes"
  ]
}
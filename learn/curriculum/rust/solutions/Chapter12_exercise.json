{
  "exerciseId": "Chapter12_exercise",
  "languageId": "rust",
  "code": "pub struct Fibonacci {\n    a: u64,\n    b: u64,\n}\n\nimpl Fibonacci {\n    pub fn new() -> Self {\n        Fibonacci { a: 0, b: 1 }\n    }\n}\n\nimpl Iterator for Fibonacci {\n    type Item = u64;\n\n    fn next(&mut self) -> Option<Self::Item> {\n        let current = self.a;\n        self.a = self.b;\n        self.b = current + self.b;\n        Some(current)\n    }\n}\n\npub fn filter_and_map<T, F, G, V>(\n    collection: Vec<T>,\n    filter_fn: F,\n    map_fn: G,\n) -> Vec<V>\nwhere\n    F: Fn(&T) -> bool,\n    G: Fn(T) -> V,\n{\n    collection\n        .into_iter()\n        .filter(filter_fn)\n        .map(map_fn)\n        .collect()\n}\n\npub fn demonstrate_closures() {\n    // Fn - immutable borrow\n    let x = 5;\n    let immutable_closure = |y| x + y;\n    println!(\"Fn closure: {}\", immutable_closure(3));\n\n    // FnMut - mutable borrow\n    let mut z = 10;\n    let mut mutable_closure = |y| {\n        z += y;\n        z\n    };\n    println!(\"FnMut closure: {}\", mutable_closure(5));\n\n    // FnOnce - ownership\n    let data = vec![1, 2, 3];\n    let once_closure = move |multiplier| {\n        data.iter().map(|&x| x * multiplier).collect::<Vec<_>>()\n    };\n    println!(\"FnOnce closure: {:?}\", once_closure(2));\n}\n\n// Custom iterator adapter\npub trait CustomIteratorExt: Iterator {\n    fn sum_even_squares(self) -> u64\n    where\n        Self::Item: Into<u64> + Copy,\n    {\n        self.filter(|&x| {\n            let num: u64 = x.into();\n            num % 2 == 0\n        })\n        .map(|x| {\n            let num: u64 = x.into();\n            num * num\n        })\n        .sum()\n    }\n}\n\nimpl<I: Iterator> CustomIteratorExt for I {}\n\npub fn higher_order_function<F>(operation: F) -> u64\nwhere\n    F: Fn(Vec<i32>) -> u64,\n{\n    let data = vec![1, 2, 3, 4, 5];\n    operation(data)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_fibonacci_iterator() {\n        let mut fib = Fibonacci::new();\n        assert_eq!(fib.next(), Some(0));\n        assert_eq!(fib.next(), Some(1));\n        assert_eq!(fib.next(), Some(1));\n        assert_eq!(fib.next(), Some(2));\n        assert_eq!(fib.next(), Some(3));\n    }\n\n    #[test]\n    fn test_filter_and_map() {\n        let numbers = vec![1, 2, 3, 4, 5, 6];\n        let result = filter_and_map(\n            numbers,\n            |&x| x % 2 == 0, // even numbers\n            |x| x * x,       // square them\n        );\n        assert_eq!(result, vec![4, 16, 36]);\n    }\n\n    #[test]\n    fn test_closure_capture_modes() {\n        // Test that demonstrate_closures runs without panicking\n        demonstrate_closures();\n    }\n\n    #[test]\n    fn test_custom_iterator_methods() {\n        let numbers = vec![1u64, 2, 3, 4];\n        let sum = numbers.into_iter().sum_even_squares();\n        assert_eq!(sum, 4 + 16); // 2^2 + 4^2 = 4 + 16 = 20\n    }\n\n    #[test]\n    fn test_higher_order_function() {\n        let sum_operation = |data: Vec<i32>| data.iter().map(|&x| x as u64).sum();\n        let result = higher_order_function(sum_operation);\n        assert_eq!(result, 15); // 1+2+3+4+5 = 15\n    }\n\n    #[test]\n    fn test_iterator_adapters() {\n        let numbers = vec![1, 2, 3, 4, 5];\n        let result: Vec<i32> = numbers\n            .iter()\n            .filter(|&&x| x > 3)\n            .map(|&x| x * 2)\n            .collect();\n        assert_eq!(result, vec![8, 10]);\n    }\n\n    #[test]\n    fn test_performance_comparison() {\n        let numbers: Vec<i32> = (1..1000).collect();\n\n        // Functional approach\n        let start = std::time::Instant::now();\n        let functional_sum: i32 = numbers.iter().filter(|&&x| x % 2 == 0).sum();\n        let functional_time = start.elapsed();\n\n        // Imperative approach\n        let start = std::time::Instant::now();\n        let mut imperative_sum = 0;\n        for &num in &numbers {\n            if num % 2 == 0 {\n                imperative_sum += num;\n            }\n        }\n        let imperative_time = start.elapsed();\n\n        assert_eq!(functional_sum, imperative_sum);\n        // Performance should be comparable (functional might be slightly slower due to overhead)\n        assert!(functional_time.as_nanos() < imperative_time.as_nanos() * 2);\n    }\n\n    #[test]\n    fn test_real_world_example() {\n        // Simulate processing user data\n        let users = vec![(\"Alice\", 25), (\"Bob\", 30), (\"Charlie\", 35)];\n\n        let adult_names: Vec<&str> = users\n            .iter()\n            .filter(|&&(_, age)| age >= 30)\n            .map(|&(name, _)| name)\n            .collect();\n\n        assert_eq!(adult_names, vec![\"Bob\", \"Charlie\"]);\n    }\n}",
  "explanation": "This solution demonstrates comprehensive functional programming in Rust using iterators and closures. The Fibonacci iterator shows custom iterator implementation, filter_and_map demonstrates higher-order functions, and the custom iterator extension shows how to add methods to existing iterators.\n\nKey concepts demonstrated:\n- Custom iterator implementation with the Iterator trait\n- Closure capture modes (Fn, FnMut, FnOnce) with different borrowing semantics\n- Iterator adapters (filter, map, collect) for functional data processing\n- Higher-order functions that accept closures as parameters\n- Custom iterator extension traits for reusable functionality\n- Performance comparison between imperative and functional approaches\n- Real-world data processing examples using functional patterns",
  "keyPoints": [
    "Implement Iterator trait for custom types to create lazy sequences",
    "Use closures for data transformation, filtering, and custom logic",
    "Fn, FnMut, and FnOnce represent different closure capture capabilities",
    "Iterator adapters provide composable, lazy data processing",
    "Higher-order functions enable reusable algorithms with customizable behavior",
    "Functional approaches can be as performant as imperative code",
    "Custom iterator extensions add domain-specific functionality"
  ]
}
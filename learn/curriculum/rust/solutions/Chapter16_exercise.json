{
  "exerciseId": "chapter16_exercise",
  "languageId": "rust",
  "code": "use std::time::Duration;\nuse tokio_stream::{self as stream, StreamExt};\nuse futures::join;\n\nasync fn simple_async() {\n    println!(\"Hello from async function!\");\n    tokio::time::sleep(Duration::from_millis(100)).await;\n    println!(\"Async function completed!\");\n}\n\nasync fn async_with_return(value: i32) -> i32 {\n    tokio::time::sleep(Duration::from_millis(50)).await;\n    value * 2\n}\n\nasync fn timeout_example() -> Result<String, Duration> {\n    match tokio::time::timeout(Duration::from_millis(200), async {\n        tokio::time::sleep(Duration::from_millis(100)).await;\n        \"Success\".to_string()\n    }).await {\n        Ok(message) => Ok(message),\n        Err(_) => Err(Duration::from_millis(200)),\n    }\n}\n\nfn create_number_stream() -> impl stream::Stream<Item = i32> {\n    stream::iter(1..=5)\n        .then(|n| async move {\n            tokio::time::sleep(Duration::from_millis(100)).await;\n            n\n        })\n}\n\nasync fn spawn_task_example() -> String {\n    let handle = tokio::spawn(async {\n        for i in 1..=3 {\n            println!(\"Task: {}\", i);\n            tokio::time::sleep(Duration::from_millis(200)).await;\n        }\n    });\n    \n    handle.await.unwrap();\n    \"Task completed\".to_string()\n}\n\nasync fn join_futures_example() -> String {\n    let future1 = async {\n        tokio::time::sleep(Duration::from_millis(100)).await;\n        \"Future 1 done\"\n    };\n    \n    let future2 = async {\n        tokio::time::sleep(Duration::from_millis(150)).await;\n        \"Future 2 done\"\n    };\n    \n    let (result1, result2) = join!(future1, future2);\n    println!(\"{} and {}\", result1, result2);\n    \"All futures completed\".to_string()\n}\n\n#[tokio::main]\nasync fn main() {\n    // Call simple_async and await it\n    simple_async().await;\n    \n    // Call async_with_return with value 5 and print result\n    let result = async_with_return(5).await;\n    println!(\"Result: {}\", result);\n    \n    // Call timeout_example and handle the result\n    match timeout_example().await {\n        Ok(message) => println!(\"Timeout result: {}\", message),\n        Err(duration) => println!(\"Timeout elapsed: {:?}\", duration),\n    }\n    \n    // Create a stream that yields numbers 1-5 with 100ms delay between each\n    let mut number_stream = create_number_stream();\n    while let Some(number) = number_stream.next().await {\n        println!(\"Stream value: {}\", number);\n    }\n    \n    // Spawn a task that prints numbers 1-3 with 200ms delay\n    spawn_task_example().await;\n    \n    // Use join! to wait for multiple futures\n    join_futures_example().await;\n}",
  "explanation": "This solution demonstrates comprehensive async Rust programming concepts including basic async/await usage, futures with return values, timeout handling, stream creation and consumption, task spawning, and joining multiple futures concurrently.",
  "keyPoints": [
    "Use tokio::time::sleep for async delays instead of std::thread::sleep",
    "Async functions return futures that must be awaited to get their results",
    "tokio::time::timeout provides timeout functionality for async operations",
    "Streams can be created from iterators and processed asynchronously",
    "tokio::spawn creates concurrent tasks that run independently",
    "futures::join! macro waits for multiple futures to complete concurrently",
    "Always use #[tokio::main] or similar runtime setup for async main functions"
  ]
}
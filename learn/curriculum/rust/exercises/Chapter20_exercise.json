{
  "id": "Chapter20_exercise",
  "title": "Multithreaded Web Server Exercise",
  "description": "Build a multithreaded web server that handles HTTP requests concurrently using a thread pool. Implement TCP connection handling, HTTP request parsing, response generation, and graceful shutdown. The server should support basic routing and serve static content.\n\nSteps:\n1. Create a basic single-threaded web server that listens on TCP port 7878\n2. Parse HTTP GET requests and serve appropriate responses\n3. Implement a ThreadPool for concurrent request handling\n4. Add graceful shutdown functionality\n5. Support multiple routes (/home, /about, /contact)",
  "difficulty": "expert",
  "starterCode": "// Step 1: Basic TCP server setup\nuse std::io::{BufReader, prelude::*};\nuse std::net::{TcpListener, TcpStream};\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    \n    println!(\"Server listening on http://127.0.0.1:7878\");\n    \n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n        handle_connection(stream);\n    }\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&stream);\n    let request_line = buf_reader.lines().next().unwrap().unwrap();\n    \n    println!(\"Received request: {}\", request_line);\n    \n    // TODO: Parse request and send appropriate response\n    let response = \"HTTP/1.1 200 OK\\r\\nContent-Length: 13\\r\\n\\r\\nHello, World!\";\n    stream.write_all(response.as_bytes()).unwrap();\n}\n\n// Step 2: HTTP request parsing and routing\n// TODO: Implement request parsing and routing logic\n\n// Step 3: ThreadPool implementation\npub struct ThreadPool {\n    // TODO: Define ThreadPool struct with workers and sender\n}\n\nimpl ThreadPool {\n    pub fn new(size: usize) -> Self {\n        // TODO: Create thread pool with specified number of workers\n        // Use channels for communication between main thread and workers\n    }\n    \n    pub fn execute<F>(&self, f: F)\n    where\n        F: FnOnce() + Send + 'static,\n    {\n        // TODO: Send job to worker threads via channel\n    }\n}\n\n// TODO: Implement Worker struct and Drop trait for ThreadPool\n\n// Step 4: Update main to use ThreadPool\n// TODO: Modify main function to use ThreadPool for concurrent request handling\n\n// Step 5: Add graceful shutdown\n// TODO: Implement graceful shutdown when receiving SIGINT (Ctrl+C)\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::net::TcpStream;\n    use std::io::Write;\n    \n    #[test]\n    fn test_thread_pool_creation() {\n        let pool = ThreadPool::new(4);\n        // Test that thread pool is created successfully\n    }\n    \n    #[test]\n    fn test_basic_http_response() {\n        // This test would require starting a server in a separate thread\n        // For now, just test the response formatting logic\n        let response = \"HTTP/1.1 200 OK\\r\\nContent-Length: 13\\r\\n\\r\\nHello, World!\";\n        assert!(response.contains(\"HTTP/1.1 200 OK\"));\n        assert!(response.contains(\"Content-Length: 13\"));\n    }\n    \n    #[test]\n    fn test_request_parsing() {\n        let request = \"GET /home HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n\";\n        // TODO: Test parsing logic\n        assert!(request.starts_with(\"GET\"));\n    }\n}",
  "tests": [
    {
      "name": "ThreadPool creation and basic functionality",
      "call": "test_thread_pool_creation",
      "type": "unit_test"
    },
    {
      "name": "HTTP response formatting",
      "call": "test_basic_http_response",
      "type": "unit_test"
    },
    {
      "name": "HTTP request parsing",
      "call": "test_request_parsing",
      "type": "unit_test"
    }
  ],
  "hints": [
    "Use TcpListener::bind() to listen on a specific address and port",
    "Parse HTTP requests by reading the first line and extracting method, path, and version",
    "Use channels (mpsc) for communication between ThreadPool and Worker threads",
    "Wrap the receiver in Arc<Mutex<>> to share it safely between threads",
    "Implement graceful shutdown by dropping the sender and joining worker threads",
    "Handle different routes by matching on the request path",
    "Use BufReader to read lines from the TCP stream efficiently"
  ],
  "tags": [
    "tcp",
    "http",
    "concurrency",
    "thread-pool",
    "channels",
    "web-server"
  ]
}
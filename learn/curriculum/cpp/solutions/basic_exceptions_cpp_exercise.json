{
  "exerciseId": "basic_exceptions_cpp_exercise",
  "title": "Basic Exception Handling Exercise - Solution",
  "description": "Complete implementation of a safe calculator with proper exception handling",
  "code": "// Basic Exception Handling Exercise - Solution\n// Complete implementation of a safe calculator with proper exception handling\n\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <limits>\n#include <sstream>\n#include <vector>\n\n// Custom exception classes\nclass CalculatorError : public std::exception {\nprotected:\n    std::string message_;\npublic:\n    CalculatorError(const std::string& message) : message_(message) {}\n    const char* what() const noexcept override {\n        return message_.c_str();\n    }\n};\n\nclass DivisionByZeroError : public CalculatorError {\npublic:\n    DivisionByZeroError() : CalculatorError(\"Division by zero\") {}\n};\n\nclass OverflowError : public CalculatorError {\npublic:\n    OverflowError(const std::string& operation) \n        : CalculatorError(operation + \" overflow\") {}\n};\n\nclass InvalidOperationError : public CalculatorError {\npublic:\n    InvalidOperationError(const std::string& operation)\n        : CalculatorError(\"Unknown operation '\" + operation + \"'\") {}\n};\n\nclass ParseError : public CalculatorError {\npublic:\n    ParseError(const std::string& input)\n        : CalculatorError(\"Invalid input format: '\" + input + \"'\") {}\n};\n\n// Safe arithmetic operations with overflow checking\nlong long safe_add(long long a, long long b) {\n    if (a > 0 && b > 0 && a > std::numeric_limits<long long>::max() - b) {\n        throw OverflowError(\"Addition\");\n    }\n    if (a < 0 && b < 0 && a < std::numeric_limits<long long>::min() - b) {\n        throw OverflowError(\"Addition\");\n    }\n    return a + b;\n}\n\nlong long safe_subtract(long long a, long long b) {\n    if (a > 0 && b < 0 && a > std::numeric_limits<long long>::max() + b) {\n        throw OverflowError(\"Subtraction\");\n    }\n    if (a < 0 && b > 0 && a < std::numeric_limits<long long>::min() + b) {\n        throw OverflowError(\"Subtraction\");\n    }\n    return a - b;\n}\n\nlong long safe_multiply(long long a, long long b) {\n    if (a != 0 && b != 0) {\n        if (a > 0 && b > 0 && a > std::numeric_limits<long long>::max() / b) {\n            throw OverflowError(\"Multiplication\");\n        }\n        if (a < 0 && b < 0 && a < std::numeric_limits<long long>::max() / b) {\n            throw OverflowError(\"Multiplication\");\n        }\n        if (a > 0 && b < 0 && b < std::numeric_limits<long long>::min() / a) {\n            throw OverflowError(\"Multiplication\");\n        }\n        if (a < 0 && b > 0 && a < std::numeric_limits<long long>::min() / b) {\n            throw OverflowError(\"Multiplication\");\n        }\n    }\n    return a * b;\n}\n\nlong long safe_divide(long long a, long long b) {\n    if (b == 0) {\n        throw DivisionByZeroError();\n    }\n    return a / b;\n}\n\n// Calculator function\nlong long calculate(const std::string& operation, long long a, long long b) {\n    if (operation == \"add\") {\n        return safe_add(a, b);\n    } else if (operation == \"subtract\") {\n        return safe_subtract(a, b);\n    } else if (operation == \"multiply\") {\n        return safe_multiply(a, b);\n    } else if (operation == \"divide\") {\n        return safe_divide(a, b);\n    } else {\n        throw InvalidOperationError(operation);\n    }\n}\n\n// Parse input line into operation and operands\nstd::tuple<std::string, long long, long long> parse_input(const std::string& line) {\n    std::istringstream iss(line);\n    std::string operation;\n    long long a, b;\n    \n    if (!(iss >> operation >> a >> b)) {\n        throw ParseError(line);\n    }\n    \n    return {operation, a, b};\n}\n\nint main() {\n    std::string line;\n    \n    std::cout << \"Safe Calculator - Enter operations (or 'quit' to exit):\" << std::endl;\n    \n    while (true) {\n        std::cout << \"> \";\n        if (!std::getline(std::cin, line)) {\n            break;\n        }\n        \n        if (line.empty()) {\n            continue;\n        }\n        \n        if (line == \"quit\") {\n            std::cout << \"Goodbye!\" << std::endl;\n            break;\n        }\n        \n        try {\n            auto [operation, a, b] = parse_input(line);\n            long long result = calculate(operation, a, b);\n            std::cout << \"Result: \" << result << std::endl;\n            \n        } catch (const CalculatorError& e) {\n            std::cout << \"Error: \" << e.what() << std::endl;\n        } catch (const std::exception& e) {\n            std::cout << \"Unexpected error: \" << e.what() << std::endl;\n        }\n    }\n    \n    return 0;\n}",
  "explanation": "This solution demonstrates comprehensive exception handling with custom exception classes, safe arithmetic operations with overflow checking, and proper input parsing. The calculator handles division by zero, arithmetic overflow, invalid operations, and malformed input.",
  "keyPoints": [
    "Custom exception classes provide specific error information",
    "Safe arithmetic operations prevent overflow/underflow",
    "Exception hierarchy allows for specific error handling",
    "Input parsing is isolated and can throw parse errors",
    "Multiple catch blocks handle different exception types appropriately",
    "Program remains robust even with invalid input"
  ]
}
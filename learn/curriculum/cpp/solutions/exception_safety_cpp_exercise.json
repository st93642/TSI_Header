{
  "exerciseId": "exception_safety_cpp_exercise",
  "title": "Exception Safety and RAII Exercise - Solution",
  "description": "Complete implementation of exception-safe container and file processor with RAII",
  "code": "// Exception Safety and RAII Exercise - Solution\n// Complete implementation of exception-safe container and file processor\n\n#include <iostream>\n#include <vector>\n#include <memory>\n#include <string>\n#include <fstream>\n#include <stdexcept>\n#include <algorithm>\n#include <sstream>\n\n// RAII file handle implementation\nclass FileHandle {\nprivate:\n    std::ifstream file_;\n    std::string filename_;\n    \npublic:\n    FileHandle(const std::string& filename) : filename_(filename) {\n        file_.open(filename);\n        if (!file_.is_open()) {\n            throw std::runtime_error(\"Failed to open file '\" + filename + \"'\");\n        }\n    }\n    \n    ~FileHandle() {\n        if (file_.is_open()) {\n            file_.close();\n        }\n    }\n    \n    FileHandle(const FileHandle&) = delete;\n    FileHandle& operator=(const FileHandle&) = delete;\n    \n    FileHandle(FileHandle&& other) noexcept \n        : file_(std::move(other.file_)), filename_(std::move(other.filename_)) {\n        // other.file_ is now moved-from, which is safe\n    }\n    \n    FileHandle& operator=(FileHandle&& other) noexcept {\n        if (this != &other) {\n            if (file_.is_open()) {\n                file_.close();\n            }\n            file_ = std::move(other.file_);\n            filename_ = std::move(other.filename_);\n        }\n        return *this;\n    }\n    \n    std::ifstream& file() { return file_; }\n    const std::string& filename() const { return filename_; }\n    bool is_open() const { return file_.is_open(); }\n};\n\n// Exception-safe container with strong exception safety\nclass SafeVector {\nprivate:\n    std::unique_ptr<int[]> data_;\n    size_t size_;\n    size_t capacity_;\n    \n    void resize(size_t new_capacity) {\n        if (new_capacity <= capacity_) return;\n        \n        std::unique_ptr<int[]> new_data(new int[new_capacity]);\n        \n        // Copy existing data\n        for (size_t i = 0; i < size_; ++i) {\n            new_data[i] = data_[i];\n        }\n        \n        // Update members atomically\n        data_ = std::move(new_data);\n        capacity_ = new_capacity;\n    }\n    \npublic:\n    SafeVector() : size_(0), capacity_(0) {}\n    \n    SafeVector(const SafeVector& other) : SafeVector() {\n        reserve(other.size_);\n        for (size_t i = 0; i < other.size_; ++i) {\n            data_[i] = other.data_[i];\n        }\n        size_ = other.size_;\n    }\n    \n    SafeVector& operator=(const SafeVector& other) {\n        if (this != &other) {\n            SafeVector temp(other);  // May throw\n            swap(temp);              // No-throw\n        }\n        return *this;\n    }\n    \n    SafeVector(SafeVector&& other) noexcept \n        : data_(std::move(other.data_)), \n          size_(other.size_), \n          capacity_(other.capacity_) {\n        other.size_ = 0;\n        other.capacity_ = 0;\n    }\n    \n    SafeVector& operator=(SafeVector&& other) noexcept {\n        if (this != &other) {\n            data_ = std::move(other.data_);\n            size_ = other.size_;\n            capacity_ = other.capacity_;\n            other.size_ = 0;\n            other.capacity_ = 0;\n        }\n        return *this;\n    }\n    \n    void swap(SafeVector& other) noexcept {\n        std::swap(data_, other.data_);\n        std::swap(size_, other.size_);\n        std::swap(capacity_, other.capacity_);\n    }\n    \n    int& operator[](size_t index) { \n        if (index >= size_) throw std::out_of_range(\"Index out of range\");\n        return data_[index]; \n    }\n    \n    const int& operator[](size_t index) const { \n        if (index >= size_) throw std::out_of_range(\"Index out of range\");\n        return data_[index]; \n    }\n    \n    size_t size() const { return size_; }\n    size_t capacity() const { return capacity_; }\n    bool empty() const { return size_ == 0; }\n    \n    void push_back(int value) {\n        if (size_ == capacity_) {\n            reserve(capacity_ == 0 ? 1 : capacity_ * 2);\n        }\n        data_[size_++] = value;\n    }\n    \n    void reserve(size_t new_capacity) {\n        if (new_capacity <= capacity_) return;\n        resize(new_capacity);\n    }\n    \n    void clear() noexcept { \n        size_ = 0; \n    }\n    \n    int* begin() { return data_.get(); }\n    int* end() { return data_.get() + size_; }\n    const int* begin() const { return data_.get(); }\n    const int* end() const { return data_.get() + size_; }\n};\n\n// File processor with exception safety\nclass FileProcessor {\nprivate:\n    SafeVector data_;\n    size_t lines_processed_ = 0;\n    \npublic:\n    void process_file(const std::string& filename) {\n        FileHandle file(filename);  // RAII - file closed automatically\n        \n        std::cout << \"Processing file: \" << filename << std::endl;\n        \n        std::string line;\n        size_t line_count = 0;\n        \n        // Read lines safely\n        while (std::getline(file.file(), line)) {\n            ++line_count;\n            \n            // Parse integer from line\n            std::istringstream iss(line);\n            int value;\n            if (iss >> value) {\n                data_.push_back(value);  // Strong exception safety\n            } else {\n                throw std::runtime_error(\"Invalid data on line \" + \n                                       std::to_string(line_count) + \": \" + line);\n            }\n            \n            if (line_count % 10 == 0) {\n                std::cout << \"Read \" << line_count << \" lines...\" << std::endl;\n            }\n        }\n        \n        lines_processed_ = line_count;\n        std::cout << \"Processing complete.\" << std::endl;\n    }\n    \n    const SafeVector& data() const { return data_; }\n    \n    void print_summary() const {\n        std::cout << \"Lines processed: \" << lines_processed_ << std::endl;\n        std::cout << \"Data points: \" << data_.size() << std::endl;\n        \n        if (!data_.empty()) {\n            // Find min/max safely\n            auto [min_it, max_it] = std::minmax_element(data_.begin(), data_.end());\n            std::cout << \"Min value: \" << *min_it << std::endl;\n            std::cout << \"Max value: \" << *max_it << std::endl;\n            \n            // Calculate sum safely\n            long long sum = 0;\n            for (int value : data_) {\n                sum += value;\n            }\n            std::cout << \"Sum: \" << sum << std::endl;\n            std::cout << \"Average: \" << static_cast<double>(sum) / data_.size() << std::endl;\n        }\n    }\n};\n\nint main(int argc, char* argv[]) {\n    if (argc < 2) {\n        std::cout << \"Usage: \" << argv[0] << \" <filename>\" << std::endl;\n        return 1;\n    }\n    \n    FileProcessor processor;\n    \n    try {\n        processor.process_file(argv[1]);\n        processor.print_summary();\n        std::cout << \"File closed successfully.\" << std::endl;\n    } catch (const std::exception& e) {\n        std::cout << \"Error: \" << e.what() << std::endl;\n        return 1;\n    }\n    \n    return 0;\n}",
  "explanation": "This solution demonstrates comprehensive exception safety with RAII resource management. The FileHandle class ensures files are always closed, SafeVector provides strong exception safety through copy-and-swap, and FileProcessor shows safe file processing with proper error handling.",
  "keyPoints": [
    "RAII ensures resources are cleaned up automatically",
    "Copy-and-swap provides strong exception safety",
    "Smart pointers prevent resource leaks",
    "Exception-safe operations maintain valid object state",
    "Move semantics enable efficient resource transfer",
    "Proper error handling prevents undefined behavior"
  ]
}
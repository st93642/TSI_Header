{
  "exerciseId": "file_streams_cpp_exercise",
  "title": "File Streams and Serialization Exercise - Solution",
  "description": "Complete implementation of file I/O operations with text/binary serialization and configuration parsing",
  "code": "// File Streams and Serialization Exercise - Solution\n// Complete implementation of comprehensive file I/O operations\n\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <stdexcept>\n#include <unordered_map>\n#include <algorithm>\n#include <cctype>\n\n// Text File Writer Implementation\nvoid text_file_writer(const std::string& filename) {\n    std::ofstream file(filename);\n    if (!file) {\n        throw std::runtime_error(\"Cannot open file for writing: \" + filename);\n    }\n    \n    std::string line;\n    std::cout << \"Enter text (type 'quit' to finish):\" << std::endl;\n    \n    while (std::getline(std::cin, line)) {\n        if (line == \"quit\") break;\n        file << line << std::endl;\n    }\n    \n    std::cout << \"Text written to \" << filename << std::endl;\n}\n\n// File Statistics Implementation\nstruct FileStats {\n    size_t lines = 0;\n    size_t words = 0;\n    size_t characters = 0;\n};\n\nFileStats analyze_file(const std::string& filename) {\n    FileStats stats;\n    std::ifstream file(filename);\n    if (!file) {\n        throw std::runtime_error(\"Cannot open file for reading: \" + filename);\n    }\n    \n    std::string line;\n    while (std::getline(file, line)) {\n        stats.lines++;\n        stats.characters += line.length() + 1; // +1 for newline\n        \n        std::istringstream iss(line);\n        std::string word;\n        while (iss >> word) {\n            stats.words++;\n        }\n    }\n    \n    return stats;\n}\n\n// Student Database Implementation\nstruct Student {\n    std::string name;\n    int id;\n    std::vector<double> grades;\n    \n    double get_average() const {\n        if (grades.empty()) return 0.0;\n        double sum = 0.0;\n        for (double grade : grades) sum += grade;\n        return sum / grades.size();\n    }\n    \n    void serialize_text(std::ofstream& out) const {\n        out << \"Student{\" << std::endl;\n        out << \"  name: \\\"\" << name << \"\\\",\" << std::endl;\n        out << \"  id: \" << id << \",\" << std::endl;\n        out << \"  grades: [\";\n        for (size_t i = 0; i < grades.size(); ++i) {\n            out << grades[i];\n            if (i < grades.size() - 1) out << \", \";\n        }\n        out << \"]\" << std::endl;\n        out << \"}\" << std::endl;\n    }\n    \n    void deserialize_text(std::ifstream& in) {\n        std::string line;\n        std::getline(in, line); // Skip opening brace\n        \n        // Read name\n        std::getline(in, line);\n        size_t start = line.find('\"');\n        size_t end = line.rfind('\"');\n        if (start != std::string::npos && end != std::string::npos) {\n            name = line.substr(start + 1, end - start - 1);\n        }\n        \n        // Read ID\n        std::getline(in, line);\n        size_t colon_pos = line.find(':');\n        if (colon_pos != std::string::npos) {\n            std::string id_str = line.substr(colon_pos + 1);\n            if (!id_str.empty() && id_str.back() == ',') id_str.pop_back();\n            id = std::stoi(id_str);\n        }\n        \n        // Read grades\n        std::getline(in, line);\n        colon_pos = line.find(':');\n        if (colon_pos != std::string::npos) {\n            std::string grades_str = line.substr(colon_pos + 1);\n            grades.clear();\n            std::istringstream iss(grades_str);\n            std::string token;\n            while (std::getline(iss, token, ',')) {\n                // Remove brackets and whitespace\n                token.erase(std::remove(token.begin(), token.end(), '['), token.end());\n                token.erase(std::remove(token.begin(), token.end(), ']'), token.end());\n                token.erase(std::remove(token.begin(), token.end(), ' '), token.end());\n                if (!token.empty()) {\n                    grades.push_back(std::stod(token));\n                }\n            }\n        }\n        \n        std::getline(in, line); // Skip closing brace\n    }\n};\n\nclass StudentDatabase {\nprivate:\n    std::vector<Student> students_;\n    std::string filename_;\n    \npublic:\n    StudentDatabase(const std::string& filename) : filename_(filename) {\n        load_from_file();\n    }\n    \n    void add_student(const Student& student) {\n        students_.push_back(student);\n        save_to_file();\n    }\n    \n    Student* find_student(int id) {\n        for (auto& student : students_) {\n            if (student.id == id) return &student;\n        }\n        return nullptr;\n    }\n    \n    void display_all() const {\n        for (const auto& student : students_) {\n            std::cout << \"Name: \" << student.name \n                      << \", ID: \" << student.id \n                      << \", Average: \" << student.get_average() << std::endl;\n        }\n    }\n    \nprivate:\n    void load_from_file() {\n        std::ifstream file(filename_);\n        if (!file) return; // File doesn't exist yet\n        \n        students_.clear();\n        std::string line;\n        while (std::getline(file, line)) {\n            if (line.find(\"Student{\") != std::string::npos) {\n                Student student;\n                student.deserialize_text(file);\n                students_.push_back(student);\n            }\n        }\n    }\n    \n    void save_to_file() const {\n        std::ofstream file(filename_);\n        if (!file) {\n            throw std::runtime_error(\"Cannot save database to file\");\n        }\n        \n        for (const auto& student : students_) {\n            student.serialize_text(file);\n            file << std::endl;\n        }\n    }\n};\n\n// Configuration Parser Implementation\nclass Config {\nprivate:\n    std::unordered_map<std::string, std::string> settings_;\n    \npublic:\n    bool load(const std::string& filename) {\n        std::ifstream file(filename);\n        if (!file) return false;\n        \n        std::string line;\n        while (std::getline(file, line)) {\n            // Skip comments and empty lines\n            if (line.empty() || line[0] == '#') continue;\n            \n            size_t equals_pos = line.find('=');\n            if (equals_pos != std::string::npos) {\n                std::string key = line.substr(0, equals_pos);\n                std::string value = line.substr(equals_pos + 1);\n                \n                // Trim whitespace\n                key.erase(key.find_last_not_of(\" \\t\") + 1);\n                key.erase(0, key.find_first_not_of(\" \\t\"));\n                value.erase(value.find_last_not_of(\" \\t\") + 1);\n                value.erase(0, value.find_first_not_of(\" \\t\"));\n                \n                settings_[key] = value;\n            }\n        }\n        \n        return true;\n    }\n    \n    std::string get(const std::string& key, const std::string& default_value = \"\") const {\n        auto it = settings_.find(key);\n        return it != settings_.end() ? it->second : default_value;\n    }\n    \n    void set(const std::string& key, const std::string& value) {\n        settings_[key] = value;\n    }\n    \n    bool save(const std::string& filename) const {\n        std::ofstream file(filename);\n        if (!file) return false;\n        \n        for (const auto& pair : settings_) {\n            file << pair.first << \" = \" << pair.second << std::endl;\n        }\n        \n        return true;\n    }\n};\n\n// Binary Serialization Example\nclass Person {\nprivate:\n    std::string name_;\n    int age_;\n    double salary_;\n    \npublic:\n    Person() = default;\n    Person(const std::string& name, int age, double salary)\n        : name_(name), age_(age), salary_(salary) {}\n    \n    void serialize_binary(std::ofstream& out) const {\n        // Write string length first, then string data\n        size_t name_len = name_.size();\n        out.write(reinterpret_cast<const char*>(&name_len), sizeof(name_len));\n        out.write(name_.c_str(), name_len);\n        \n        // Write primitive data\n        out.write(reinterpret_cast<const char*>(&age_), sizeof(age_));\n        out.write(reinterpret_cast<const char*>(&salary_), sizeof(salary_));\n    }\n    \n    void deserialize_binary(std::ifstream& in) {\n        // Read string length, then string data\n        size_t name_len;\n        in.read(reinterpret_cast<char*>(&name_len), sizeof(name_len));\n        \n        name_.resize(name_len);\n        in.read(&name_[0], name_len);\n        \n        // Read primitive data\n        in.read(reinterpret_cast<char*>(&age_), sizeof(age_));\n        in.read(reinterpret_cast<char*>(&salary_), sizeof(salary_));\n    }\n    \n    void print() const {\n        std::cout << \"Name: \" << name_ << \", Age: \" << age_ \n                  << \", Salary: $\" << salary_ << std::endl;\n    }\n};\n\n// Main function with comprehensive command interface\nint main(int argc, char* argv[]) {\n    if (argc < 2) {\n        std::cout << \"Usage: \" << argv[0] << \" <command> [args...]\" << std::endl;\n        std::cout << \"Commands:\" << std::endl;\n        std::cout << \"  write <filename>     - Write text to file from console\" << std::endl;\n        std::cout << \"  stats <filename>     - Show file statistics\" << std::endl;\n        std::cout << \"  db-add <name> <id>   - Add student to database\" << std::endl;\n        std::cout << \"  db-show              - Show all students\" << std::endl;\n        std::cout << \"  config <filename>    - Load and display config\" << std::endl;\n        std::cout << \"  binary-demo         - Demonstrate binary serialization\" << std::endl;\n        return 1;\n    }\n    \n    std::string command = argv[1];\n    \n    try {\n        if (command == \"write\" && argc >= 3) {\n            text_file_writer(argv[2]);\n        } else if (command == \"stats\" && argc >= 3) {\n            FileStats stats = analyze_file(argv[2]);\n            std::cout << \"Lines: \" << stats.lines << std::endl;\n            std::cout << \"Words: \" << stats.words << std::endl;\n            std::cout << \"Characters: \" << stats.characters << std::endl;\n        } else if (command == \"db-add\" && argc >= 4) {\n            StudentDatabase db(\"students.txt\");\n            Student student;\n            student.name = argv[2];\n            student.id = std::stoi(argv[3]);\n            // In a real implementation, you'd read grades from additional args\n            student.grades = {85.0, 92.0, 78.0}; // Sample grades\n            db.add_student(student);\n            std::cout << \"Student added successfully\" << std::endl;\n        } else if (command == \"db-show\") {\n            StudentDatabase db(\"students.txt\");\n            db.display_all();\n        } else if (command == \"config\" && argc >= 3) {\n            Config config;\n            if (config.load(argv[2])) {\n                std::cout << \"theme = \" << config.get(\"theme\", \"default\") << std::endl;\n                std::cout << \"font_size = \" << config.get(\"font_size\", \"12\") << std::endl;\n                std::cout << \"debug = \" << config.get(\"debug\", \"false\") << std::endl;\n            } else {\n                std::cout << \"Failed to load config file\" << std::endl;\n            }\n        } else if (command == \"binary-demo\") {\n            // Demonstrate binary serialization\n            Person person(\"John Doe\", 30, 55000.0);\n            \n            // Serialize\n            {\n                std::ofstream file(\"person.bin\", std::ios::binary);\n                person.serialize_binary(file);\n            }\n            \n            // Deserialize\n            Person loaded_person;\n            {\n                std::ifstream file(\"person.bin\", std::ios::binary);\n                loaded_person.deserialize_binary(file);\n            }\n            \n            std::cout << \"Original: \";\n            person.print();\n            std::cout << \"Loaded: \";\n            loaded_person.print();\n        } else {\n            std::cout << \"Unknown command or insufficient arguments\" << std::endl;\n            return 1;\n        }\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return 1;\n    }\n    \n    std::cout << \"File operations completed successfully\" << std::endl;\n    return 0;\n}",
  "explanation": "This solution demonstrates comprehensive file I/O operations including text file writing, file statistics analysis, student database with text serialization, configuration file parsing, and binary serialization examples. The implementation showcases proper error handling, RAII principles, and different serialization approaches.",
  "keyPoints": [
    "RAII ensures automatic file closure and resource management",
    "Text serialization is portable but verbose; binary is efficient but platform-dependent",
    "Always validate file operations and handle errors gracefully",
    "Configuration files provide flexible application settings",
    "Serialization enables object persistence across program runs",
    "File positioning allows random access to large datasets",
    "Different file modes serve different purposes (text/binary, read/write/append)"
  ]
}
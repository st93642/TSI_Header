{
  "exerciseId": "union_find_disjoint_sets_cpp_exercise",
  "languageId": "cpp",
  "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nclass DisjointSetForest {\npublic:\n    explicit DisjointSetForest(std::size_t n)\n        : parent_(n), rank_(n, 0), component_size_(n, 1), components_(n) {\n        for (std::size_t i = 0; i < n; ++i) {\n            parent_[i] = i;\n        }\n    }\n\n    std::size_t find(std::size_t node) {\n        if (parent_[node] != node) {\n            parent_[node] = find(parent_[node]);\n        }\n        return parent_[node];\n    }\n\n    bool unite(std::size_t a, std::size_t b) {\n        std::size_t rootA = find(a);\n        std::size_t rootB = find(b);\n        if (rootA == rootB) {\n            return false;\n        }\n\n        if (rank_[rootA] < rank_[rootB]) {\n            std::swap(rootA, rootB);\n        }\n\n        parent_[rootB] = rootA;\n        component_size_[rootA] += component_size_[rootB];\n        component_size_[rootB] = 0;\n        if (rank_[rootA] == rank_[rootB]) {\n            ++rank_[rootA];\n        }\n        --components_;\n        return true;\n    }\n\n    bool connected(std::size_t a, std::size_t b) {\n        return find(a) == find(b);\n    }\n\n    std::size_t componentSize(std::size_t node) {\n        return component_size_[find(node)];\n    }\n\n    std::size_t components() const {\n        return components_;\n    }\n\nprivate:\n    std::vector<std::size_t> parent_;\n    std::vector<std::size_t> rank_;\n    std::vector<std::size_t> component_size_;\n    std::size_t components_;\n};\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    std::size_t n, q;\n    if (!(std::cin >> n >> q)) {\n        return 0;\n    }\n\n    DisjointSetForest dsu(n);\n\n    while (q--) {\n        std::string op;\n        std::cin >> op;\n        if (op == \"UNION\") {\n            std::size_t a, b;\n            std::cin >> a >> b;\n            dsu.unite(a, b);\n        } else if (op == \"CHECK\") {\n            std::size_t a, b;\n            std::cin >> a >> b;\n            std::cout << (dsu.connected(a, b) ? \"YES\" : \"NO\") << '\\n';\n        } else if (op == \"SIZE\") {\n            std::size_t node;\n            std::cin >> node;\n            std::cout << dsu.componentSize(node) << '\\n';\n        }\n    }\n\n    return 0;\n}\n",
  "explanation": "The solution implements a classic disjoint-set forest with union-by-rank and path compression. Each node begins as its own parent, and `find` flattens paths recursively. `unite` swaps roots to keep the deepest rank on top, merges component sizes, and only increments the rank when both trees match height. The main loop reads commands, applies unions, prints connectivity checks as YES/NO, and reports component sizes directly from the representative.",
  "keyPoints": [
    "Initialise every parent to itself so singleton components form the base case.",
    "Path compression rewrites parent pointers recursively, shrinking tree height over time.",
    "Union-by-rank (size) keeps shallower trees under deeper ones, preventing skewed forests.",
    "Component sizes must follow the representative so SIZE queries answer in O(Î±(n))."
  ]
}

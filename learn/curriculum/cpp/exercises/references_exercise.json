{
  "id": "references_exercise",
  "title": "Exercise 4.4: Adjust Boundaries with References",
  "description": "Modify range boundaries in place using references, then report the changes in a formatted string.",
  "difficulty": "intermediate",
  "tags": [
    "references",
    "functions",
    "formatting",
    "validation"
  ],
  "variants": [
    {
      "id": "references_cpp",
      "title": "Exercise 4.4: Adjust Boundaries with References (C++)",
      "language": "cpp",
      "difficulty": "intermediate",
      "starterCode": "#include <iostream>\n#include <sstream>\n\n// Implement adjust_boundaries() with reference parameters that modify the caller's variables.\n// Required prototype (declare above main, define after main):\n//   std::string adjust_boundaries(int& minimum, int& maximum, int adjustment);\n// Requirements (align with Chapter 9 guidance on references):\n//   1. Capture the original minimum and maximum before making changes.\n//   2. Increase both minimum and maximum by the adjustment value.\n//   3. If the adjusted minimum becomes greater than the adjusted maximum, swap the two values so minimum <= maximum.\n//   4. Build a std::ostringstream containing exactly these four lines (match spacing, capitalization, and line order):\n//        Original Min: <original minimum>\n//        Original Max: <original maximum>\n//        Adjusted Min: <new minimum>\n//        Adjusted Max: <new maximum>\n//   5. Return the string from adjust_boundaries(); do NOT print inside the function.\n//   6. The caller (main) prints the returned string followed by std::endl.\n\nstd::string adjust_boundaries(int& minimum, int& maximum, int adjustment);\n\nint main() {\n    int lower {70};\n    int upper {95};\n    std::cout << adjust_boundaries(lower, upper, 5) << std::endl;\n\n    int rangeMin {88};\n    int rangeMax {90};\n    std::cout << adjust_boundaries(rangeMin, rangeMax, -5) << std::endl;\n\n    return 0;\n}\n\n// Define adjust_boundaries() after main following the rules above.\n\n",
      "tests": [
        {
          "name": "positive_adjustment",
          "description": "Increasing both boundaries keeps order intact.",
          "type": "output",
          "call": "int minimum {70}; int maximum {95}; std::cout << adjust_boundaries(minimum, maximum, 5);",
          "expected": "Original Min: 70\nOriginal Max: 95\nAdjusted Min: 75\nAdjusted Max: 100"
        },
        {
          "name": "negative_adjustment",
          "description": "Decreasing both boundaries maintains order when adjustment is negative.",
          "type": "output",
          "call": "int minimum {88}; int maximum {90}; std::cout << adjust_boundaries(minimum, maximum, -5);",
          "expected": "Original Min: 88\nOriginal Max: 90\nAdjusted Min: 83\nAdjusted Max: 85"
        },
        {
          "name": "swap_required",
          "description": "Adjustment that inverts the range should swap values so min <= max.",
          "type": "output",
          "call": "int minimum {10}; int maximum {12}; std::cout << adjust_boundaries(minimum, maximum, -15);",
          "expected": "Original Min: 10\nOriginal Max: 12\nAdjusted Min: -5\nAdjusted Max: -3"
        }
      ],
      "hints": [
        "Store copies of minimum and maximum before modifying so you can report the originals.",
        "Apply the adjustment directly to the reference parameters (minimum += adjustment, etc.).",
        "If minimum > maximum after the adjustment, use std::swap(minimum, maximum).",
        "Build the response with std::ostringstream and return out.str();",
        "Leave printing to the caller so tests can capture the returned string."
      ]
    }
  ]
}

{
  "id": "file_streams_cpp_exercise",
  "title": "File Streams and Serialization Exercise",
  "description": "Practice file input/output operations and object serialization using C++ streams.\n\nSteps:\n1. Implement a text file writer that reads from console and writes to file\n2. Create a file statistics program that analyzes text files\n3. Build a student database with binary serialization for data persistence\n4. Implement a configuration file parser\n\nExpected output/results: Programs should handle file operations safely, provide meaningful error messages, and demonstrate proper binary serialization techniques for data persistence.",
  "difficulty": "intermediate",
  "duration": 60,
  "type": "output",
  "task": "Implement a comprehensive file I/O system with text and binary operations, including binary serialization for custom objects and configuration file parsing.",
  "inputFormat": "Programs should accept command-line arguments for filenames and read data from standard input or files as specified.",
  "outputFormat": "Display results to console, write data to files, and handle errors gracefully with informative messages.",
  "tests": [
    {
      "name": "Text file writing and reading",
      "type": "output",
      "expected": "File operations completed successfully"
    },
    {
      "name": "File statistics analysis",
      "type": "output",
      "expected": "Lines: 5\nWords: 12\nCharacters: 67"
    },
    {
      "name": "Student database operations",
      "type": "output",
      "expected": "Student added successfully\nName: Alice Johnson, ID: 12345, Average: 88.3333"
    }
  ],
  "hints": [
    "Use RAII principles for file stream management",
    "Always check file operation success with if (!file)",
    "Binary serialization is efficient for complex data structures",
    "Use binary mode for data persistence and text mode for human-readable files",
    "Implement proper error handling for file operations",
    "Consider data structure layout when designing binary formats"
  ],
  "starterCode": "// File Streams and Serialization Exercise\n// Implement comprehensive file I/O operations\n\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <stdexcept>\n#include <unordered_map>\n#include <algorithm>\n\n// TODO: Implement Text File Writer\n\n// Create a program that reads lines from console and writes to file until \"quit\" is entered\nvoid text_file_writer(const std::string& filename) {\n    std::ofstream file(filename);\n    if (!file) {\n        throw std::runtime_error(\"Cannot open file for writing: \" + filename);\n    }\n    \n    std::string line;\n    std::cout << \"Enter text (type 'quit' to finish):\" << std::endl;\n    \n    while (std::getline(std::cin, line)) {\n        if (line == \"quit\") break;\n        file << line << std::endl;\n    }\n}\n\n// TODO: Implement File Statistics\n// Analyze a text file and report lines, words, and characters\nstruct FileStats {\n    size_t lines = 0;\n    size_t words = 0;\n    size_t characters = 0;\n};\n\nFileStats analyze_file(const std::string& filename) {\n    FileStats stats;\n    std::ifstream file(filename);\n    if (!file) {\n        throw std::runtime_error(\"Cannot open file for reading: \" + filename);\n    }\n    \n    std::string line;\n    while (std::getline(file, line)) {\n        stats.lines++;\n        stats.characters += line.length() + 1; // +1 for newline\n        \n        std::istringstream iss(line);\n        std::string word;\n        while (iss >> word) {\n            stats.words++;\n        }\n    }\n    \n    return stats;\n}\n\n// TODO: Implement Simple Student Database\n// Use binary serialization for simplicity\nstruct Student {\n    std::string name;\n    int id;\n    std::vector<double> grades;\n    \n    double get_average() const {\n        if (grades.empty()) return 0.0;\n        double sum = 0.0;\n        for (double grade : grades) sum += grade;\n        return sum / grades.size();\n    }\n    \n    // Binary serialization\n    void serialize(std::ofstream& out) const {\n        // Write name length and name\n        size_t name_len = name.length();\n        out.write(reinterpret_cast<const char*>(&name_len), sizeof(name_len));\n        out.write(name.c_str(), name_len);\n        \n        // Write id and grades\n        out.write(reinterpret_cast<const char*>(&id), sizeof(id));\n        \n        size_t grades_size = grades.size();\n        out.write(reinterpret_cast<const char*>(&grades_size), sizeof(grades_size));\n        out.write(reinterpret_cast<const char*>(grades.data()), grades_size * sizeof(double));\n    }\n    \n    // Binary deserialization\n    bool deserialize(std::ifstream& in) {\n        // Read name\n        size_t name_len;\n        if (!in.read(reinterpret_cast<char*>(&name_len), sizeof(name_len))) return false;\n        name.resize(name_len);\n        if (!in.read(&name[0], name_len)) return false;\n        \n        // Read id and grades\n        if (!in.read(reinterpret_cast<char*>(&id), sizeof(id))) return false;\n        \n        size_t grades_size;\n        if (!in.read(reinterpret_cast<char*>(&grades_size), sizeof(grades_size))) return false;\n        grades.resize(grades_size);\n        if (!in.read(reinterpret_cast<char*>(grades.data()), grades_size * sizeof(double))) return false;\n        \n        return true;\n    }\n};\n\nclass StudentDatabase {\nprivate:\n    std::vector<Student> students_;\n    std::string filename_;\n    \npublic:\n    StudentDatabase(const std::string& filename) : filename_(filename) {\n        load_from_file();\n    }\n    \n    void add_student(const Student& student) {\n        students_.push_back(student);\n        save_to_file();\n    }\n    \n    void display_all() const {\n        for (const auto& student : students_) {\n            std::cout << \"Name: \" << student.name \n                      << \", ID: \" << student.id \n                      << \", Average: \" << student.get_average() << std::endl;\n        }\n    }\n    \nprivate:\n    void load_from_file() {\n        std::ifstream file(filename_, std::ios::binary);\n        if (!file) return; // File doesn't exist yet\n        \n        students_.clear();\n        Student student;\n        while (student.deserialize(file)) {\n            students_.push_back(student);\n        }\n    }\n    \n    void save_to_file() const {\n        std::ofstream file(filename_, std::ios::binary);\n        if (!file) {\n            throw std::runtime_error(\"Cannot save database to file\");\n        }\n        \n        for (const auto& student : students_) {\n            student.serialize(file);\n        }\n    }\n};\n\n// TODO: Implement Configuration Parser\nclass Config {\nprivate:\n    std::unordered_map<std::string, std::string> settings_;\n    \npublic:\n    bool load(const std::string& filename) {\n        std::ifstream file(filename);\n        if (!file) return false;\n        \n        std::string line;\n        while (std::getline(file, line)) {\n            // Skip comments and empty lines\n            if (line.empty() || line[0] == '#') continue;\n            \n            size_t equals_pos = line.find('=');\n            if (equals_pos != std::string::npos) {\n                std::string key = line.substr(0, equals_pos);\n                std::string value = line.substr(equals_pos + 1);\n                \n                // Trim whitespace\n                key.erase(key.find_last_not_of(\" \\t\") + 1);\n                key.erase(0, key.find_first_not_of(\" \\t\"));\n                value.erase(value.find_last_not_of(\" \\t\") + 1);\n                value.erase(0, value.find_first_not_of(\" \\t\"));\n                \n                settings_[key] = value;\n            }\n        }\n        \n        return true;\n    }\n    \n    std::string get(const std::string& key, const std::string& default_value = \"\") const {\n        auto it = settings_.find(key);\n        return it != settings_.end() ? it->second : default_value;\n    }\n    \n    void set(const std::string& key, const std::string& value) {\n        settings_[key] = value;\n    }\n    \n    bool save(const std::string& filename) const {\n        std::ofstream file(filename);\n        if (!file) return false;\n        \n        for (const auto& pair : settings_) {\n            file << pair.first << \" = \" << pair.second << std::endl;\n        }\n        \n        return true;\n    }\n};\n\n// TODO: Implement main function with command-line interface\nint main(int argc, char* argv[]) {\n    if (argc < 2) {\n        std::cout << \"Usage: \" << argv[0] << \" <command> [args...]\" << std::endl;\n        std::cout << \"Commands:\" << std::endl;\n        std::cout << \"  write <filename>     - Write text to file\" << std::endl;\n        std::cout << \"  stats <filename>     - Show file statistics\" << std::endl;\n        std::cout << \"  db-add <name> <id>   - Add student to database\" << std::endl;\n        std::cout << \"  db-show              - Show all students\" << std::endl;\n        std::cout << \"  config <filename>    - Load and display config\" << std::endl;\n        return 1;\n    }\n    \n    std::string command = argv[1];\n    \n    try {\n        if (command == \"write\" && argc >= 3) {\n            text_file_writer(argv[2]);\n        } else if (command == \"stats\" && argc >= 3) {\n            FileStats stats = analyze_file(argv[2]);\n            std::cout << \"Lines: \" << stats.lines << std::endl;\n            std::cout << \"Words: \" << stats.words << std::endl;\n            std::cout << \"Characters: \" << stats.characters << std::endl;\n        } else if (command == \"db-add\" && argc >= 4) {\n            StudentDatabase db(\"students.txt\");\n            Student student;\n            student.name = argv[2];\n            student.id = std::stoi(argv[3]);\n            // In a real implementation, you'd read grades from additional args\n            student.grades = {85.0, 92.0, 78.0}; // Sample grades\n            db.add_student(student);\n            std::cout << \"Student added successfully\" << std::endl;\n        } else if (command == \"db-show\") {\n            StudentDatabase db(\"students.txt\");\n            db.display_all();\n        } else if (command == \"config\" && argc >= 3) {\n            Config config;\n            if (config.load(argv[2])) {\n                std::cout << \"theme = \" << config.get(\"theme\", \"default\") << std::endl;\n                std::cout << \"font_size = \" << config.get(\"font_size\", \"12\") << std::endl;\n            } else {\n                std::cout << \"Failed to load config file\" << std::endl;\n            }\n        } else {\n            std::cout << \"Unknown command or insufficient arguments\" << std::endl;\n            return 1;\n        }\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return 1;\n    }\n    \n    return 0;\n}",
  "solution": "file_streams_cpp_exercise.json"
}
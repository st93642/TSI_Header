{
  "id": "chapter_06_pointers_and_references_exercise",
  "title": "Exercise 6: Pointer Navigation Lab",
  "description": "Practice pointer arithmetic, reference semantics, and shared ownership by producing a deterministic status report.",
  "difficulty": "advanced",
  "tags": ["pointers", "references", "ownership", "ptrdiff_t", "smart pointers"],
  "starterCode": "#include <iostream>\n#include <vector>\n#include <memory>\n#include <cstddef>\n\n// Offline blueprint: implement each helper before printing the verification lines.\n// Follow the exact output format so automated tests can compare results.\n\nstd::ptrdiff_t pointer_span(const int* start, const int* finish) {\n    // TODO: Return the distance in elements between finish and start using pointer subtraction\n    (void)start;\n    (void)finish;\n    return 0;\n}\n\nvoid reseat_pointer(int*& target, int* replacement) {\n    // TODO: Update the pointer reference so target now points to replacement\n    (void)target;\n    (void)replacement;\n}\n\nint apply_alias(int& target, int delta) {\n    // TODO: Modify the aliased target by delta and return the new value\n    (void)target;\n    (void)delta;\n    return 0;\n}\n\nstd::size_t count_shared(const std::shared_ptr<std::vector<int>>& log) {\n    // TODO: Report the current shared ownership count for the temperature log\n    (void)log;\n    return 0;\n}\n\nbool probe_expired(const std::weak_ptr<std::vector<int>>& probe) {\n    // TODO: Return true when the observed shared_ptr has expired\n    (void)probe;\n    return false;\n}\n\nint main() {\n    int values[]{5, 15, 25, 35, 45};\n    std::ptrdiff_t span = pointer_span(values + 1, values + 4);\n\n    int* anchor = values;\n    reseat_pointer(anchor, values + 3);\n    int reseated_value = *anchor;\n\n    int alias_target = values[0];\n    int alias_result = apply_alias(alias_target, 7);\n\n    auto shared_log = std::make_shared<std::vector<int>>(std::initializer_list<int>{42, 48, 51});\n    auto extra_owner = shared_log;\n    std::size_t owners_before_reset = count_shared(shared_log);\n\n    std::weak_ptr<std::vector<int>> watcher = shared_log;\n    bool expired_before = probe_expired(watcher);\n\n    extra_owner.reset();\n    shared_log.reset();\n    bool expired_after = probe_expired(watcher);\n\n    // Output blueprint (follow exactly after finishing the functions):\n    // Pointer span: <value>\n    // Pointer value after reseat: <value>\n    // Alias result: <value>\n    // Shared owners (before reset): <value>\n    // Weak expired before reset: <yes/no>\n    // Weak expired after reset: <yes/no>\n\n    std::cout << \"Pointer span: \" << span << '\\n';\n    std::cout << \"Pointer value after reseat: \" << reseated_value << '\\n';\n    std::cout << \"Alias result: \" << alias_result << '\\n';\n    std::cout << \"Shared owners (before reset): \" << owners_before_reset << '\\n';\n    std::cout << \"Weak expired before reset: \" << (expired_before ? \"yes\" : \"no\") << '\\n';\n    std::cout << \"Weak expired after reset: \" << (expired_after ? \"yes\" : \"no\") << '\\n';\n\n    return 0;\n}\n",
  "tests": [
    {
      "name": "chapter_06_pointer_report",
      "description": "Aggregated pointer report covers spans, reseating, aliasing, and shared ownership",
      "input": "",
      "expected": "Pointer span: 3\nPointer value after reseat: 35\nAlias result: 12\nShared owners (before reset): 2\nWeak expired before reset: no\nWeak expired after reset: yes\n",
      "type": "output"
    }
  ],
  "hints": [
    "Subtracting two pointers yields a std::ptrdiff_t measured in element counts",
    "Reseating requires passing the pointer by reference so the caller sees the change",
    "A reference parameter lets you update the caller's variable without returning an address",
    "std::shared_ptr::use_count() reports active owners; copy the pointer to observe the increment",
    "Lock a std::weak_ptr before accessing the underlying object and test the result for expiration"
  ]
}

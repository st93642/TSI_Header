#*****************************************************************************#
#                                                                             #
#  test_codebase_crystal.txt                              TTTTTTTT SSSSSSS II #
#                                                            TT    SS      II #
#  By: st93642@students.tsi.lv                               TT    SSSSSSS II #
#                                                            TT         SS II #
#  Created: Sep 29 2025 00:16 st93642                        TT    SSSSSSS II #
#  Updated: Sep 29 2025 00:16 st93642                                         #
#                                                                             #
#   Transport and Telecommunication Institute - Riga, Latvia                  #
#                       https://tsi.lv                                        #
#*****************************************************************************#
# Basic Crystal program
# Crystal is a compiled language with Ruby-like syntax

# Define a module
module TSIExample
  VERSION = "1.0.0"

  # Define a class with type annotations
  class Person
    property name : String
    property age : Int32

    def initialize(@name : String, @age : Int32 = 20)
    end

    def greet : String
      "Hello, I'm #{@name}, #{@age} years old!"
    end

    def celebrate_birthday : Int32
      @age += 1
      @age
    end
  end

  # Define a struct (value type)
  struct Point
    property x : Float64
    property y : Float64

    def initialize(@x : Float64 = 0.0, @y : Float64 = 0.0)
    end

    def distance_from_origin : Float64
      Math.sqrt(@x ** 2 + @y ** 2)
    end

    def +(other : Point) : Point
      Point.new(@x + other.x, @y + other.y)
    end
  end

  # Define an enum
  enum Status
    Active
    Inactive
    Suspended
  end

  # Generic class
  class Container(T)
    def initialize
      @items = [] of T
    end

    def add(item : T) : Nil
      @items << item
    end

    def get(index : Int32) : T
      @items[index]
    end

    def size : Int32
      @items.size
    end

    def each(&block : T ->)
      @items.each do |item|
        yield item
      end
    end
  end

  # Module with utility functions
  module Utils
    def self.factorial(n : Int32) : Int32
      return 1 if n <= 1
      n * factorial(n - 1)
    end

    def self.fibonacci(n : Int32) : Int32
      return n if n <= 1
      fibonacci(n - 1) + fibonacci(n - 2)
    end

    def self.process_array(arr : Array(Int32)) : Array(Int32)
      arr.map { |x| x * 2 }
    end
  end

  # Class with inheritance
  class Student < Person
    property student_id : String
    property major : String

    def initialize(name : String, age : Int32, @student_id : String, @major : String = "Computer Science")
      super(name, age)
    end

    def study : String
      "#{@name} is studying #{@major}"
    end
  end

  # Struct with methods
  struct Rectangle
    property width : Float64
    property height : Float64

    def initialize(@width : Float64, @height : Float64)
    end

    def area : Float64
      @width * @height
    end

    def perimeter : Float64
      2 * (@width + @height)
    end

    def to_s : String
      "Rectangle(#{@width} x #{@height})"
    end
  end
end

# Main program
def main : Nil
  puts "Hello, World!"
  puts "This is a basic Crystal program."

  # Create instances
  person = TSIExample::Person.new("TSI Student", 20)
  puts person.greet

  # Celebrate birthday
  new_age = person.celebrate_birthday
  puts "After birthday: #{new_age} years old"

  # Work with structs
  point1 = TSIExample::Point.new(3.0, 4.0)
  point2 = TSIExample::Point.new(1.0, 2.0)
  point3 = point1 + point2
  puts "Point distance: #{point3.distance_from_origin}"

  # Use generic container
  container = TSIExample::Container(Int32).new
  container.add(10)
  container.add(20)
  container.add(30)
  puts "Container size: #{container.size}"
  puts "First item: #{container.get(0)}"

  # Iterate over container
  print "Container items: "
  container.each do |item|
    print "#{item} "
  end
  puts

  # Use utility functions
  puts "Factorial of 5: #{TSIExample::Utils.factorial(5)}"
  puts "Fibonacci of 8: #{TSIExample::Utils.fibonacci(8)}"

  # Process array
  numbers = [1, 2, 3, 4, 5]
  doubled = TSIExample::Utils.process_array(numbers)
  puts "Original: #{numbers}"
  puts "Doubled: #{doubled}"

  # Work with student
  student = TSIExample::Student.new("Alice", 22, "S12345", "Engineering")
  puts student.greet
  puts student.study

  # Work with rectangle
  rect = TSIExample::Rectangle.new(10.0, 5.0)
  puts rect.to_s
  puts "Area: #{rect.area}"
  puts "Perimeter: #{rect.perimeter}"

  # Demonstrate enums
  status = TSIExample::Status::Active
  puts "Status: #{status}"

  # Demonstrate type checking
  if status.is_a?(TSIExample::Status)
    puts "Status is valid"
  end

  # Demonstrate array operations
  names = ["Alice", "Bob", "Charlie"]
  filtered_names = names.select { |name| name.size > 3 }
  puts "Names longer than 3 chars: #{filtered_names}"

  # Demonstrate hash/map
  scores = {"Alice" => 95, "Bob" => 87, "Charlie" => 92}
  puts "Average score: #{scores.values.sum / scores.size}"

  # Demonstrate blocks and closures
  multiplier = ->(x : Int32, factor : Int32) { x * factor }
  result = multiplier.call(5, 3)
  puts "5 * 3 = #{result}"

  puts "Crystal program completed successfully!"
end

# Execute main function
main

# Example of macro usage (commented out as it's advanced)
# macro define_method(name, content)
#   def {{name}}
#     {{content}}
#   end
# end
#
# class Example
#   define_method :hello, "Hello from macro!"
# end
#
# Example.new.hello # => "Hello from macro!"

# Example of fiber usage (commented out)
# channel = Channel(Int32).new
#
# spawn do
#   5.times do |i|
#     sleep 0.1
#     channel.send(i)
#   end
# end
#
# 5.times do
#   value = channel.receive
#   puts "Received: #{value}"
# end

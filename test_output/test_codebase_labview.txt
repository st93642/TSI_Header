// ************************************************************************* //
//                                                                           //
//  test_codebase_labview.txt                            TTTTTTTT SSSSSSS II //
//                                                          TT    SS      II //
//  By: st93642@students.tsi.lv                             TT    SSSSSSS II //
//                                                          TT         SS II //
//  Created: Sep 28 2025 23:09 st93642                      TT    SSSSSSS II //
//  Updated: Sep 28 2025 23:09 st93642                                       //
//                                                                           //
//   Transport and Telecommunication Institute - Riga, Latvia                //
//                       https://tsi.lv                                      //
// ************************************************************************* //
// Basic LabVIEW program
// LabVIEW (Laboratory Virtual Instrument Engineering Workbench) is a graphical programming language

// Define a VI (Virtual Instrument) structure
// In LabVIEW, programs are called Virtual Instruments (VIs)

// Front Panel Controls and Indicators
// Numeric Controls: Temperature_Setpoint, Pressure_Limit, Flow_Rate
// Boolean Controls: Start_Button, Stop_Button, Emergency_Stop
// String Controls: Operator_Name, Test_Description
// Array Controls: Data_Array, Measurement_Values
// Cluster Controls: Sensor_Data (Temperature, Pressure, Flow)

// Block Diagram Code Structure

// Initialize variables and controls
// Temperature_Setpoint = 25.0
// Pressure_Limit = 100.0
// Flow_Rate = 10.0
// Start_Button = FALSE
// Stop_Button = FALSE
// Emergency_Stop = FALSE

// Main program loop structure
While Loop:
    // Read front panel controls
    Temperature_Value = Read Temperature Sensor
    Pressure_Value = Read Pressure Sensor
    Flow_Value = Read Flow Sensor

    // Process data
    If Temperature_Value > Temperature_Setpoint Then
        Activate_Cooling = TRUE
    Else
        Activate_Cooling = FALSE
    End If

    If Pressure_Value > Pressure_Limit Then
        Alarm_Pressure = TRUE
        Emergency_Stop = TRUE
    Else
        Alarm_Pressure = FALSE
    End If

    // Control actuators
    If Start_Button = TRUE AND Emergency_Stop = FALSE Then
        Pump_Status = TRUE
        Valve_Status = TRUE
    Else
        Pump_Status = FALSE
        Valve_Status = FALSE
    End If

    // Data logging
    Current_Time = Get Current Time
    Log_Data = Concatenate [Current_Time, Temperature_Value, Pressure_Value, Flow_Value]
    Write to File: "process_log.txt"

    // Update front panel indicators
    Temperature_Indicator = Temperature_Value
    Pressure_Indicator = Pressure_Value
    Flow_Indicator = Flow_Value
    Status_Indicator = "Running"

    // Check stop conditions
    If Stop_Button = TRUE OR Emergency_Stop = TRUE Then
        Exit Loop
    End If

    // Wait for next iteration (100ms)
    Wait 100ms
End While

// Cleanup and finalization
Close File: "process_log.txt"
Status_Indicator = "Stopped"

// SubVI Examples

// SubVI: Temperature_Controller
// Inputs: Current_Temp, Setpoint
// Outputs: Control_Signal
Function Temperature_Controller(Current_Temp, Setpoint)
    Error = Setpoint - Current_Temp
    Integral = Integral + Error * 0.1
    Derivative = (Error - Previous_Error) / 0.1
    Control_Signal = Kp * Error + Ki * Integral + Kd * Derivative
    Previous_Error = Error
    Return Control_Signal
End Function

// SubVI: Data_Acquisition
// Inputs: Channel_Number, Samples
// Outputs: Data_Array
Function Data_Acquisition(Channel_Number, Samples)
    Initialize Array: Data_Array[Samples]
    For i = 0 to Samples-1
        Data_Array[i] = Read Analog Channel(Channel_Number)
        Wait 1ms
    Next i
    Return Data_Array
End Function

// SubVI: PID_Controller
// Inputs: Setpoint, Process_Value, Kp, Ki, Kd
// Outputs: Control_Output
Function PID_Controller(Setpoint, Process_Value, Kp, Ki, Kd)
    Error = Setpoint - Process_Value
    Proportional = Kp * Error

    Integral_Sum = Integral_Sum + Error * Sample_Time
    Integral = Ki * Integral_Sum

    Derivative = Kd * (Error - Previous_Error) / Sample_Time
    Previous_Error = Error

    Control_Output = Proportional + Integral + Derivative

    // Anti-windup
    If Control_Output > Output_Max Then
        Control_Output = Output_Max
        Integral_Sum = Integral_Sum - Error * Sample_Time
    Else If Control_Output < Output_Min Then
        Control_Output = Output_Min
        Integral_Sum = Integral_Sum - Error * Sample_Time
    End If

    Return Control_Output
End Function

// Event Structure Example
Event Structure:
    Case: Start_Button.Value_Change
        Start_Process = TRUE
        Status_Text = "Process Started"

    Case: Stop_Button.Value_Change
        Stop_Process = TRUE
        Status_Text = "Process Stopped"

    Case: Emergency_Stop.Value_Change
        Emergency_Stop = TRUE
        Status_Text = "EMERGENCY STOP ACTIVATED"

    Case: Timeout (1000ms)
        // Periodic updates
        Update_Display()
End Event Structure

// State Machine Example
State Machine:
    States:
        Initialize:
            Initialize_Variables()
            Next_State = "Idle"

        Idle:
            If Start_Button = TRUE Then
                Next_State = "Running"
            End If

        Running:
            Execute_Process_Loop()
            If Stop_Button = TRUE Then
                Next_State = "Stopping"
            End If
            If Emergency_Stop = TRUE Then
                Next_State = "Emergency"
            End If

        Stopping:
            Cleanup_Process()
            Next_State = "Idle"

        Emergency:
            Emergency_Shutdown()
            Next_State = "Idle"

    Current_State = Initialize
End State Machine

// Queue and Notifier Examples
// Message Queue for inter-VI communication
Message_Queue = Create Queue("Commands")
Enqueue Message_Queue: "START_PROCESS"
Enqueue Message_Queue: "SET_TEMPERATURE:25.0"

// Notifier for event broadcasting
Status_Notifier = Create Notifier("Status_Updates")
Send Notification Status_Notifier: "Process Complete"

// Property Node Examples
// Control properties
Temperature_Control.Visible = TRUE
Temperature_Control.Enabled = TRUE
Temperature_Control.Background_Color = "White"

// Indicator properties
Status_Indicator.Value = "Ready"
Status_Indicator.Text_Color = "Green"

// VI Properties
VI_Window.Title = "TSI LabVIEW Application"
VI_Window.Auto_Center = TRUE

// Error Handling
Error_Cluster = No Error
Try:
    // Code that might produce errors
    Open_File = Open "data.txt"
    If Open_File.Error = TRUE Then
        Error_Cluster = Open_File.Error
    End If
Catch:
    Error_Cluster = Error.Code
    Error_Message = "File operation failed"
Finally:
    Close_File = Close Open_File
End Try

// Global Variables (use sparingly)
Global.TSI_Application_Version = "1.0.0"
Global.Operator_Name = "Default_Operator"
Global.Last_Error_Code = 0

// Functional Global Variables (FGVs)
Function Global_Variable(Operation, Value)
    Static Data = Initialize_Global_Data()

    Case Operation:
        "Initialize":
            Data = Initialize_Global_Data()
        "Set_Value":
            Data.Value = Value
        "Get_Value":
            Return Data.Value
        "Increment":
            Data.Value = Data.Value + 1
            Return Data.Value
End Function

// Polymorphic VI Example
// VI that accepts different data types
Function Process_Data(Data)
    If Data.Type = "Numeric" Then
        Result = Data * 2.0
    Else If Data.Type = "String" Then
        Result = Concatenate("Processed: ", Data)
    Else If Data.Type = "Boolean" Then
        Result = NOT Data
    Else
        Result = "Unknown Data Type"
    End If
    Return Result
End Function

// XControl Example (Custom Control)
// XControl: Numeric_Input_With_Units
// Facade VI: Display and input handling
// State: Current_Value, Units, Min_Value, Max_Value
// Methods: Set_Value, Get_Value, Set_Units, Validate_Input

// Express VI Usage Examples
// DAQ Assistant: Analog Input, 1 Channel, Continuous
// File I/O: Write to Spreadsheet File
// Signal Processing: Filter, Statistics, Generation
// Instrument Control: GPIB, Serial, Ethernet

// Report Generation
Report_Handle = New Report()
Set Report Title: "TSI LabVIEW Test Report"
Set Report Header: "Generated on " + Current_Date_Time

Add Text Section: "Test Results Summary"
Add Table: Test_Data_Array
Add Graph: Measurement_Chart

Save Report: "test_report.html"
Dispose Report Handle: Report_Handle

// Web Services
// VI Server for remote access
VI_Server.Enabled = TRUE
VI_Server.Port = 3363

// TCP/IP Communication
TCP_Listener = Create TCP Listener(Port: 6340)
While Running:
    Connection = Wait for TCP Connection()
    Received_Data = Read TCP Data(Connection)
    Processed_Data = Process_Received_Data(Received_Data)
    Write TCP Data(Connection, Processed_Data)
    Close TCP Connection(Connection)
End While

// Database Connectivity
Database_Handle = Open Database Connection("TSI_Data.db")
SQL_Query = "SELECT * FROM Measurements WHERE Date > ?"
Query_Result = Execute Query(Database_Handle, SQL_Query, Start_Date)
Process_Query_Results(Query_Result)
Close Database Connection(Database_Handle)

// Configuration File Handling
Config_File = Open Config File("settings.ini")
Application_Settings = Read Config Section(Config_File, "Application")
DAQ_Settings = Read Config Section(Config_File, "DAQ")
Close Config File(Config_File)

// Unit Testing Framework
Test_Framework = Initialize Test Framework()
Add Test Case: "Temperature_Controller_Test"
Add Test Case: "PID_Controller_Test"
Add Test Case: "Data_Acquisition_Test"

Run All Tests()
Generate Test Report()

// Memory Management
Request Deallocation: Large_Data_Array
Force Garbage Collection()

// Performance Optimization
// Use shift registers instead of local variables in loops
// Minimize front panel updates in tight loops
// Use subVIs for code reusability
// Profile VI performance with built-in tools

// Best Practices Demonstrated:
// 1. Modular design with subVIs
// 2. Error handling throughout
// 3. State machines for complex logic
// 4. Event-driven programming
// 5. Data flow paradigm
// 6. Hierarchical design
// 7. Documentation and comments
// 8. Consistent naming conventions
// 9. Icon and connector pane design
// 10. Version control integration

// LabVIEW program completed successfully!
